{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u03bbORM \u03bbORM is an ORM that allows us to perform distributed queries on different database engines. In \u03bbORM, queries are defined using lambda expressions based on a domain model which abstracts us from the infrastructure. For example, in a query you can obtain or modify records from different entities, where some persist in MySQL, others in Postgres, and others in Mongo. \u03bbORM allows you to define different scenarios for the same domain. For example, in one scenario, the infrastructure may consist of distributed instances across SQL Server, MongoDB, and Oracle, while in another scenario it may be a single Postgres instance. This allows the CQRS pattern to be implemented through configuration, without needing to write a single line of code. view example In addition to being used as a Node.js library, it can be consumed from a command line interface (CLI), a REST service, or a REST service client in other programming languages. Query Language Example of a query where orders and their details associated with a customer are obtained: const query = (country: string) => Products .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .sort(p => desc(p.largestPrice)); // Run the query passing the value of the country parameter const result = await orm.execute(query, { country: 'ARG' }); In this example: Define a query that returns a list of product categories along with the maximum price of each category. Filter products based on price and supplier's country or stock availability Group products by category and calculate the maximum price Map each product to an object with category name and maximum price Sort the products by largest price in descending order view: queries | select | join | grouping | include | insert | bulkInsert | update | delete | repository | usage | metadata Include The include allows us to obtain the entity data and its relationships in the same query. These data may be in different databases. \\ In this example the query is expressed as a text string. (Which is another alternative to the lambda expression) import { orm } from '../../lib' (async () => { try { await orm.init('./config/northwind.yaml') const query = `Orders .filter(p => p.id === id) .include(p => [ p.customer.map(p => p.name), p.details .include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice]) ] )` const params = { id: 102 } const result = await orm.execute(query, params, { stage: 'PostgreSQL' }) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.message) } finally { await orm.end() } })() Result: [ { \"id\": 102, \"customerId\": \"SPLIR\", \"employeeId\": 7, \"orderDate\": \"1996-11-07T23:00:00.000Z\", \"requiredDate\": \"1996-12-05T23:00:00.000Z\", \"shippedDate\": \"1996-11-14T23:00:00.000Z\", \"shipViaId\": 1, \"freight\": 8.63, \"name\": \"Split Rail Beer & Ale\", \"address\": \"P.O. Box 555\", \"city\": \"Lander\", \"region\": \"WY\", \"postalCode\": \"82520\", \"country\": \"USA\", \"customer\": { \"name\": \"Split Rail Beer & Ale\" }, \"details\": [ { \"quantity\": 24, \"unitPrice\": 5.9, \"product\": { \"name\": \"Tourtire\", \"category\": { \"name\": \"Meat/Poultry\" } } } ] } ] more info: include Schema Configuration Through the schema, you can define entities, enumerations, indexes, unique keys, default values, constraints, mapping, sources, stages, listeners, etc. The schema can be defined in a JSON or YAML format. Conditions or actions are performed using the same expression language that is used to define queries. view: schema | definition | use | expressions | environment Variables | composite | listener | multiple stages | multiple sources | push | pull | fetch | introspect | incorporate Contributing Would you like to contribute? Read our contribution guidelines to learn more. There are many ways to help! Documentation Full documentation is available in the Wiki . All Labs You can access various labs at lambdaorm labs Related projects Lambda ORM CLI : Command line interface for \u03bbORM Lambda ORM Service : REST service for \u03bbORM Client Node : HTTP client for \u03bbORM Client Kotlin : HTTP client for \u03bbORM for Kotlin 3xpr : Extensible expression engine, which allows evaluating mathematical and logical expressions.","title":"Home"},{"location":"#orm","text":"\u03bbORM is an ORM that allows us to perform distributed queries on different database engines. In \u03bbORM, queries are defined using lambda expressions based on a domain model which abstracts us from the infrastructure. For example, in a query you can obtain or modify records from different entities, where some persist in MySQL, others in Postgres, and others in Mongo. \u03bbORM allows you to define different scenarios for the same domain. For example, in one scenario, the infrastructure may consist of distributed instances across SQL Server, MongoDB, and Oracle, while in another scenario it may be a single Postgres instance. This allows the CQRS pattern to be implemented through configuration, without needing to write a single line of code. view example In addition to being used as a Node.js library, it can be consumed from a command line interface (CLI), a REST service, or a REST service client in other programming languages.","title":"\u03bbORM"},{"location":"#query-language","text":"Example of a query where orders and their details associated with a customer are obtained: const query = (country: string) => Products .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .sort(p => desc(p.largestPrice)); // Run the query passing the value of the country parameter const result = await orm.execute(query, { country: 'ARG' }); In this example: Define a query that returns a list of product categories along with the maximum price of each category. Filter products based on price and supplier's country or stock availability Group products by category and calculate the maximum price Map each product to an object with category name and maximum price Sort the products by largest price in descending order view: queries | select | join | grouping | include | insert | bulkInsert | update | delete | repository | usage | metadata","title":"Query Language"},{"location":"#include","text":"The include allows us to obtain the entity data and its relationships in the same query. These data may be in different databases. \\ In this example the query is expressed as a text string. (Which is another alternative to the lambda expression) import { orm } from '../../lib' (async () => { try { await orm.init('./config/northwind.yaml') const query = `Orders .filter(p => p.id === id) .include(p => [ p.customer.map(p => p.name), p.details .include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice]) ] )` const params = { id: 102 } const result = await orm.execute(query, params, { stage: 'PostgreSQL' }) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.message) } finally { await orm.end() } })() Result: [ { \"id\": 102, \"customerId\": \"SPLIR\", \"employeeId\": 7, \"orderDate\": \"1996-11-07T23:00:00.000Z\", \"requiredDate\": \"1996-12-05T23:00:00.000Z\", \"shippedDate\": \"1996-11-14T23:00:00.000Z\", \"shipViaId\": 1, \"freight\": 8.63, \"name\": \"Split Rail Beer & Ale\", \"address\": \"P.O. Box 555\", \"city\": \"Lander\", \"region\": \"WY\", \"postalCode\": \"82520\", \"country\": \"USA\", \"customer\": { \"name\": \"Split Rail Beer & Ale\" }, \"details\": [ { \"quantity\": 24, \"unitPrice\": 5.9, \"product\": { \"name\": \"Tourtire\", \"category\": { \"name\": \"Meat/Poultry\" } } } ] } ] more info: include","title":"Include"},{"location":"#schema-configuration","text":"Through the schema, you can define entities, enumerations, indexes, unique keys, default values, constraints, mapping, sources, stages, listeners, etc. The schema can be defined in a JSON or YAML format. Conditions or actions are performed using the same expression language that is used to define queries. view: schema | definition | use | expressions | environment Variables | composite | listener | multiple stages | multiple sources | push | pull | fetch | introspect | incorporate","title":"Schema Configuration"},{"location":"#contributing","text":"Would you like to contribute? Read our contribution guidelines to learn more. There are many ways to help!","title":"Contributing"},{"location":"#documentation","text":"Full documentation is available in the Wiki .","title":"Documentation"},{"location":"#all-labs","text":"You can access various labs at lambdaorm labs","title":"All Labs"},{"location":"#related-projects","text":"Lambda ORM CLI : Command line interface for \u03bbORM Lambda ORM Service : REST service for \u03bbORM Client Node : HTTP client for \u03bbORM Client Kotlin : HTTP client for \u03bbORM for Kotlin 3xpr : Extensible expression engine, which allows evaluating mathematical and logical expressions.","title":"Related projects"},{"location":"BulkInsert/","text":"BulkInsert BulkInsert is a database operation that allows inserting multiple records into a table at once, rather than inserting them one by one. This operation is particularly useful when dealing with large datasets or when performance optimization is needed. Advantages of BulkInsert: Improved Performance : BulkInsert significantly reduces the number of round trips between the application and the database, resulting in improved performance. Instead of executing multiple individual insert statements, a single bulk insert statement is executed, which reduces overhead and latency. Reduced Database Load : By minimizing the number of database transactions, BulkInsert helps in reducing the load on the database server, which can improve overall system performance, especially in high-traffic environments. Atomicity : BulkInsert operations are typically atomic, meaning that either all records are inserted successfully, or none are. This ensures data integrity and consistency in the database. Simplicity : Using BulkInsert simplifies the application code by reducing the number of database interactions required. This leads to cleaner and more maintainable code. Scalability : BulkInsert is well-suited for handling large datasets, making it scalable for applications that need to process and insert a significant amount of data efficiently. Overall, BulkInsert is a powerful database operation that can significantly improve the performance and efficiency of data insertion tasks in applications dealing with large volumes of data. BulkInsert in one entity Lambda: // Bulk insert operation for Categories entity Categories.bulkInsert() SQL Result: -- Bulk insertion into Categories table with provided values INSERT INTO Categories(CategoryName,Description) VALUES ? BulkInsert with include related entity Lambda: // Bulk insert operation for Orders entity and including details Orders.bulkInsert().include(p => p.details) SQL Result: -- Bulk insertion into Orders table with provided values INSERT INTO Orders(CustomerID,EmployeeID,OrderDate,RequiredDate,ShippedDate,ShipVia,Freight,ShipName,ShipAddress,ShipCity,ShipRegion,ShipPostalCode,ShipCountry) VALUES ? -- Bulk insertion into Order Details table with provided values INSERT INTO `Order Details`(OrderID,ProductID,UnitPrice,Quantity,Discount) VALUES ? Code example import { orm } from '../../lib' import { Categories } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const categories = [ { name: 'Beverages4', description: 'Soft drinks, coffees, teas, beers, and ales', id: 12 }, { name: 'Condiments4', description: 'Sweet and savory sauces, relishes, spreads, and seasonings', id: 13 } ] // Define a query for bulk insert operation for categories const query = () => Categories.bulkInsert() // Execute the query using the ORM, passing the query function and the categories data const result = await orm.execute(query, categories) // return ids of records inserted console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Bulk Insert"},{"location":"BulkInsert/#bulkinsert","text":"BulkInsert is a database operation that allows inserting multiple records into a table at once, rather than inserting them one by one. This operation is particularly useful when dealing with large datasets or when performance optimization is needed.","title":"BulkInsert"},{"location":"BulkInsert/#advantages-of-bulkinsert","text":"Improved Performance : BulkInsert significantly reduces the number of round trips between the application and the database, resulting in improved performance. Instead of executing multiple individual insert statements, a single bulk insert statement is executed, which reduces overhead and latency. Reduced Database Load : By minimizing the number of database transactions, BulkInsert helps in reducing the load on the database server, which can improve overall system performance, especially in high-traffic environments. Atomicity : BulkInsert operations are typically atomic, meaning that either all records are inserted successfully, or none are. This ensures data integrity and consistency in the database. Simplicity : Using BulkInsert simplifies the application code by reducing the number of database interactions required. This leads to cleaner and more maintainable code. Scalability : BulkInsert is well-suited for handling large datasets, making it scalable for applications that need to process and insert a significant amount of data efficiently. Overall, BulkInsert is a powerful database operation that can significantly improve the performance and efficiency of data insertion tasks in applications dealing with large volumes of data.","title":"Advantages of BulkInsert:"},{"location":"BulkInsert/#bulkinsert-in-one-entity","text":"Lambda: // Bulk insert operation for Categories entity Categories.bulkInsert() SQL Result: -- Bulk insertion into Categories table with provided values INSERT INTO Categories(CategoryName,Description) VALUES ?","title":"BulkInsert in one entity"},{"location":"BulkInsert/#bulkinsert-with-include-related-entity","text":"Lambda: // Bulk insert operation for Orders entity and including details Orders.bulkInsert().include(p => p.details) SQL Result: -- Bulk insertion into Orders table with provided values INSERT INTO Orders(CustomerID,EmployeeID,OrderDate,RequiredDate,ShippedDate,ShipVia,Freight,ShipName,ShipAddress,ShipCity,ShipRegion,ShipPostalCode,ShipCountry) VALUES ? -- Bulk insertion into Order Details table with provided values INSERT INTO `Order Details`(OrderID,ProductID,UnitPrice,Quantity,Discount) VALUES ?","title":"BulkInsert with include related entity"},{"location":"BulkInsert/#code-example","text":"import { orm } from '../../lib' import { Categories } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const categories = [ { name: 'Beverages4', description: 'Soft drinks, coffees, teas, beers, and ales', id: 12 }, { name: 'Condiments4', description: 'Sweet and savory sauces, relishes, spreads, and seasonings', id: 13 } ] // Define a query for bulk insert operation for categories const query = () => Categories.bulkInsert() // Execute the query using the ORM, passing the query function and the categories data const result = await orm.execute(query, categories) // return ids of records inserted console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Delete/","text":"Delete Delete record for filter Lambda: // Deleting records from OrderDetails where orderId matches the provided id OrderDetails.delete().filter(p => p.orderId === id) SQL Result: -- Deleting records from Order Details where OrderID matches the provided id DELETE o FROM `Order Details` AS o WHERE o.OrderID = ? Delete with default filter In the case that delete() is used and no filter is specified, it is assumed that it will be filtered by the primary key Lambda: // Deleting records from OrderDetails filtered by the primary key (OrderID) OrderDetails.delete() SQL Result: -- Deleting records from Order Details where OrderID matches the primary key DELETE o FROM `Order Details` AS o WHERE o.OrderID = ? Delete all records If you want to delete all the records of an entity, you should use deleteAll instead of delete. This is done to avoid deleting all records by mistake. Lambda: // Deleting all records from OrderDetails OrderDetails.deleteAll() SQL Result: -- Deleting all records from Order Details DELETE o FROM `Order Details` AS o Delete entity an related entity Lambda: // Deleting orders and their details Orders.delete().include(p => p.details) SQL Result: -- Deleting orders where OrderID matches the provided id DELETE o FROM Orders AS o WHERE o.OrderID = ? -- Deleting order details where OrderID and ProductID match the provided ids DELETE o1 FROM `Order Details` AS o1 WHERE (o1.OrderID = ? AND o1.ProductID = ?) Code example import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { id: 1, customerId: 'ALFKI', employeeId: 6, orderDate: '1997-08-24T22:00:00.000Z', requiredDate: '1997-09-21T22:00:00.000Z', shippedDate: '1997-09-01T22:00:00.000Z', shipViaId: 1, freight: '29.4600', name: 'Alfreds Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 1, productId: 28, unitPrice: '45.6000', quantity: '15.0000', discount: '0.0000' }, { orderId: 1, productId: 39, unitPrice: '18.0000', quantity: '21.0000', discount: '0.0000' } ] } // Defining a query to delete orders and include details const query = () => Orders.delete().include(p => p.details) // Executing the query using the ORM with the specified order parameter await orm.execute(query, order) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Delete"},{"location":"Delete/#delete","text":"","title":"Delete"},{"location":"Delete/#delete-record-for-filter","text":"Lambda: // Deleting records from OrderDetails where orderId matches the provided id OrderDetails.delete().filter(p => p.orderId === id) SQL Result: -- Deleting records from Order Details where OrderID matches the provided id DELETE o FROM `Order Details` AS o WHERE o.OrderID = ?","title":"Delete record for filter"},{"location":"Delete/#delete-with-default-filter","text":"In the case that delete() is used and no filter is specified, it is assumed that it will be filtered by the primary key Lambda: // Deleting records from OrderDetails filtered by the primary key (OrderID) OrderDetails.delete() SQL Result: -- Deleting records from Order Details where OrderID matches the primary key DELETE o FROM `Order Details` AS o WHERE o.OrderID = ?","title":"Delete with default filter"},{"location":"Delete/#delete-all-records","text":"If you want to delete all the records of an entity, you should use deleteAll instead of delete. This is done to avoid deleting all records by mistake. Lambda: // Deleting all records from OrderDetails OrderDetails.deleteAll() SQL Result: -- Deleting all records from Order Details DELETE o FROM `Order Details` AS o","title":"Delete all records"},{"location":"Delete/#delete-entity-an-related-entity","text":"Lambda: // Deleting orders and their details Orders.delete().include(p => p.details) SQL Result: -- Deleting orders where OrderID matches the provided id DELETE o FROM Orders AS o WHERE o.OrderID = ? -- Deleting order details where OrderID and ProductID match the provided ids DELETE o1 FROM `Order Details` AS o1 WHERE (o1.OrderID = ? AND o1.ProductID = ?)","title":"Delete entity an related entity"},{"location":"Delete/#code-example","text":"import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { id: 1, customerId: 'ALFKI', employeeId: 6, orderDate: '1997-08-24T22:00:00.000Z', requiredDate: '1997-09-21T22:00:00.000Z', shippedDate: '1997-09-01T22:00:00.000Z', shipViaId: 1, freight: '29.4600', name: 'Alfreds Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 1, productId: 28, unitPrice: '45.6000', quantity: '15.0000', discount: '0.0000' }, { orderId: 1, productId: 39, unitPrice: '18.0000', quantity: '21.0000', discount: '0.0000' } ] } // Defining a query to delete orders and include details const query = () => Orders.delete().include(p => p.details) // Executing the query using the ORM with the specified order parameter await orm.execute(query, order) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Expression/","text":"Lambda expressions The lambda expressions are written based on the programming language itself, referring to the business model, completely abstracting from the database language and its structure. Lambda: // Select states where the first character of the name is 'A' States.filter(p => upper(substring(p.name, 0, 1)) == \"A\") // Map each selected state to an object with country and state properties .map(p => { country: p.country.name, state: p.name }) // Sort the results first by country in ascending order and then by state in descending order .sort(p => [p.country, desc(p.state)]) // Paginate the results to show the first page of 10 records .page(1, 10) SQL Result: -- Select the country name and state name SELECT c.NAME AS country, s.NAME AS \"state\" -- From the states table with alias 's' FROM TBL_STATES s -- Inner join with the countries table with alias 'c' on the country ID INNER JOIN TBL_COUNTRIES c ON c.ID = o.CountryID -- Filter states where the first character of the name is 'A' WHERE UPPER(SUBSTR(s.NAME, 0, 1)) = 'A' -- Order the results first by country name in ascending order and then by state name in descending order ORDER BY country, \"state\" DESC -- Apply pagination to skip the first row and fetch the next 10 rows OFFSET 1 ROWS FETCH NEXT 10 ROWS ONLY Advantage: Use of the same programming language. It is not necessary to learn a new language. Easy to write and understand expressions. Use of the intellisense offered by the IDE to write the expressions. Avoid syntax errors. Query Expressions: Method Description SQL Equivalent filter To filter the records. WHERE examples having To filter on groupings. HAVING examples map To specify the fields to return. SELECT examples distinct to specify the fields to return by sending duplicate records. examples first returns the first record SELECT + ORDER BY + LIMIT examples last returns the last record SELECT + ORDER BY DESC + LIMIT examples sort To specify the order in which the records are returned. ORDER BY examples page To paginate. LIMIT (MySQL) examples include To get records of related entities examples insert To insert records INSERT examples update To update records always including a filter UPDATE with WHERE examples updateAll to be able to update all the records of an entity UPDATE without WHERE examples delete To delete records always including a filter DELETE with WHERE examples deleteAll To be able to delete all records of an entity DELETE without WHERE examples bulkInsert to insert records in bulk INSERT examples There are no methods for the INNER JOIN clause since it is deduced when navigating through the relations of a property. There are no methods for the GROUP BY clause since this is deduced when grouping methods are used. Operators The operators used are the same as those of javascript. Category Operators Arithmetic -, +, , /, *, //, % more info Bitwise ~,&,^,<<,>> more info Comparison ==, ===, !=, !==, >, <, >=, <= more info Logical !, && more info Array [] more info Functions Category functions Numeric abs, ceil, cos, exp, ln, log, remainder, round, sign, sin, tan, trunc... more info String chr, lower, lpad, ltrim, replace, rpad, rtrim, substr, trim, upper, concat... more info Datetime curtime, today, now, time, date, dateTime, year, month, day, weekday, hours... more info Convert toString, toJson, toNumber more info Nullable nvl, nvl2, isNull, isNotNull more info General as, distinct more info Sort asc, desc more info Condition between, includes more info Group avg, count, first, last, max, min, sum more info Metadata user, source more info","title":"Expression"},{"location":"Expression/#lambda-expressions","text":"The lambda expressions are written based on the programming language itself, referring to the business model, completely abstracting from the database language and its structure. Lambda: // Select states where the first character of the name is 'A' States.filter(p => upper(substring(p.name, 0, 1)) == \"A\") // Map each selected state to an object with country and state properties .map(p => { country: p.country.name, state: p.name }) // Sort the results first by country in ascending order and then by state in descending order .sort(p => [p.country, desc(p.state)]) // Paginate the results to show the first page of 10 records .page(1, 10) SQL Result: -- Select the country name and state name SELECT c.NAME AS country, s.NAME AS \"state\" -- From the states table with alias 's' FROM TBL_STATES s -- Inner join with the countries table with alias 'c' on the country ID INNER JOIN TBL_COUNTRIES c ON c.ID = o.CountryID -- Filter states where the first character of the name is 'A' WHERE UPPER(SUBSTR(s.NAME, 0, 1)) = 'A' -- Order the results first by country name in ascending order and then by state name in descending order ORDER BY country, \"state\" DESC -- Apply pagination to skip the first row and fetch the next 10 rows OFFSET 1 ROWS FETCH NEXT 10 ROWS ONLY","title":"Lambda expressions"},{"location":"Expression/#advantage","text":"Use of the same programming language. It is not necessary to learn a new language. Easy to write and understand expressions. Use of the intellisense offered by the IDE to write the expressions. Avoid syntax errors.","title":"Advantage:"},{"location":"Expression/#query-expressions","text":"Method Description SQL Equivalent filter To filter the records. WHERE examples having To filter on groupings. HAVING examples map To specify the fields to return. SELECT examples distinct to specify the fields to return by sending duplicate records. examples first returns the first record SELECT + ORDER BY + LIMIT examples last returns the last record SELECT + ORDER BY DESC + LIMIT examples sort To specify the order in which the records are returned. ORDER BY examples page To paginate. LIMIT (MySQL) examples include To get records of related entities examples insert To insert records INSERT examples update To update records always including a filter UPDATE with WHERE examples updateAll to be able to update all the records of an entity UPDATE without WHERE examples delete To delete records always including a filter DELETE with WHERE examples deleteAll To be able to delete all records of an entity DELETE without WHERE examples bulkInsert to insert records in bulk INSERT examples There are no methods for the INNER JOIN clause since it is deduced when navigating through the relations of a property. There are no methods for the GROUP BY clause since this is deduced when grouping methods are used.","title":"Query Expressions:"},{"location":"Expression/#operators","text":"The operators used are the same as those of javascript. Category Operators Arithmetic -, +, , /, *, //, % more info Bitwise ~,&,^,<<,>> more info Comparison ==, ===, !=, !==, >, <, >=, <= more info Logical !, && more info Array [] more info","title":"Operators"},{"location":"Expression/#functions","text":"Category functions Numeric abs, ceil, cos, exp, ln, log, remainder, round, sign, sin, tan, trunc... more info String chr, lower, lpad, ltrim, replace, rpad, rtrim, substr, trim, upper, concat... more info Datetime curtime, today, now, time, date, dateTime, year, month, day, weekday, hours... more info Convert toString, toJson, toNumber more info Nullable nvl, nvl2, isNull, isNotNull more info General as, distinct more info Sort asc, desc more info Condition between, includes more info Group avg, count, first, last, max, min, sum more info Metadata user, source more info","title":"Functions"},{"location":"Features/","text":"Features Supports MySQL, MariaDB, PostgresSQL, Oracle, SqlServer, SqlJs and MongoDB. Query Language Simple query language based on javascript lambda expressions. Can write the expression as javascript code or as a string Crud clauses Implicit joins and group by Eager loading using the Include() method. Query expression metadata Repositories and custom repositories Transactions and distributed transactions Schema Configuration Decoupling the domain model from infrastructure Configuration in json or yml formats Definition of mappings between domain and infrastructure Extends entities Environment variables define indices, unique keys and constraints Conditions and actions are based on the expression engine 3xpr Synchronization Performance and Optimization BulkInsert High performance queries Connection pooling Listeners and subscribers TypeScript and JavaScript support CLI Support support REST API Support HTTP Client Support Node Client Kotlin Client (In Progress) Java Client (Coming Soon) C# Client (Coming Soon) Python Client (Coming Soon)","title":"Features"},{"location":"Features/#features","text":"Supports MySQL, MariaDB, PostgresSQL, Oracle, SqlServer, SqlJs and MongoDB. Query Language Simple query language based on javascript lambda expressions. Can write the expression as javascript code or as a string Crud clauses Implicit joins and group by Eager loading using the Include() method. Query expression metadata Repositories and custom repositories Transactions and distributed transactions Schema Configuration Decoupling the domain model from infrastructure Configuration in json or yml formats Definition of mappings between domain and infrastructure Extends entities Environment variables define indices, unique keys and constraints Conditions and actions are based on the expression engine 3xpr Synchronization Performance and Optimization BulkInsert High performance queries Connection pooling Listeners and subscribers TypeScript and JavaScript support CLI Support support REST API Support HTTP Client Support Node Client Kotlin Client (In Progress) Java Client (Coming Soon) C# Client (Coming Soon) Python Client (Coming Soon)","title":"Features"},{"location":"Grouping/","text":"Grouping In the case of grouping, it is not necessary to define it explicitly, since it is deduced when one of the grouping functions is used. \\ The fields by which they are grouped are deduced by which they are contained with some of the grouping functions. Grouping Functions Function Description avg Calculates the average of the specified columns in a set of rows count Calculating the number of rows in a set. first Returns the first value of the selected column last Returns the last value of the selected column. max Calculating the maximum. min Calculating the minimum. sum Calculating the sum. Grouping by sum with order and filter Filters order details based on customer name Maps the results to get the order date and the total calculated as the sum of (quantity * unit price) Orders the results in descending order by total Lambda: OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) SQL Result: -- Selects order date and calculates the sum of (quantity * unit price) as 'total' -- Performs inner join with Orders and Customers table to get additional customer information -- Filters the results based on customer company name -- Groups the results by order date -- Orders the results in descending order by total SELECT o1.OrderDate AS `order`, SUM(o.Quantity * o.UnitPrice) AS `total` FROM `Order Details` o INNER JOIN Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Customers c ON c.CustomerID = o1.CustomerID WHERE c.CompanyName = ? GROUP BY o1.OrderDate ORDER BY `total` desc Grouping and Having Filters products based on price and supplier country, or stock quantity Filters the results based on maximum price Maps the results to get the product category and maximum price Sorts the results in descending order by maximum price Lambda: Products .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) SQL Result: -- Selects product category and calculates the maximum price as 'largestPrice' -- Performs inner join with Suppliers and Categories tables to get additional product information -- Filters the results based on price and supplier country, or stock quantity -- Groups the results by product category -- Filters the results based on maximum price -- Orders the results in descending order by maximum price SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS `largestPrice` FROM Products p INNER JOIN Suppliers s ON s.SupplierID = p.SupplierID INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE ((p.UnitPrice > 5 AND s.Country = ?) OR p.UnitsInStock < 3) GROUP BY c.CategoryName HAVING MAX(p.UnitPrice) > 50 ORDER BY `largestPrice` desc Code example import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts a country parameter // Filtering products based on price and supplier country, or stock quantity // Filtering the results based on maximum price // Mapping the results to get the product category and maximum price // Sorting the results in descending order by maximum price const query = (country:string) => Products .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) const result = await orm.execute(query, {country:'ARG'}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Grouping"},{"location":"Grouping/#grouping","text":"In the case of grouping, it is not necessary to define it explicitly, since it is deduced when one of the grouping functions is used. \\ The fields by which they are grouped are deduced by which they are contained with some of the grouping functions.","title":"Grouping"},{"location":"Grouping/#grouping-functions","text":"Function Description avg Calculates the average of the specified columns in a set of rows count Calculating the number of rows in a set. first Returns the first value of the selected column last Returns the last value of the selected column. max Calculating the maximum. min Calculating the minimum. sum Calculating the sum.","title":"Grouping Functions"},{"location":"Grouping/#grouping-by-sum-with-order-and-filter","text":"Filters order details based on customer name Maps the results to get the order date and the total calculated as the sum of (quantity * unit price) Orders the results in descending order by total Lambda: OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) SQL Result: -- Selects order date and calculates the sum of (quantity * unit price) as 'total' -- Performs inner join with Orders and Customers table to get additional customer information -- Filters the results based on customer company name -- Groups the results by order date -- Orders the results in descending order by total SELECT o1.OrderDate AS `order`, SUM(o.Quantity * o.UnitPrice) AS `total` FROM `Order Details` o INNER JOIN Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Customers c ON c.CustomerID = o1.CustomerID WHERE c.CompanyName = ? GROUP BY o1.OrderDate ORDER BY `total` desc","title":"Grouping by sum with order and filter"},{"location":"Grouping/#grouping-and-having","text":"Filters products based on price and supplier country, or stock quantity Filters the results based on maximum price Maps the results to get the product category and maximum price Sorts the results in descending order by maximum price Lambda: Products .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) SQL Result: -- Selects product category and calculates the maximum price as 'largestPrice' -- Performs inner join with Suppliers and Categories tables to get additional product information -- Filters the results based on price and supplier country, or stock quantity -- Groups the results by product category -- Filters the results based on maximum price -- Orders the results in descending order by maximum price SELECT c.CategoryName AS `category`, MAX(p.UnitPrice) AS `largestPrice` FROM Products p INNER JOIN Suppliers s ON s.SupplierID = p.SupplierID INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE ((p.UnitPrice > 5 AND s.Country = ?) OR p.UnitsInStock < 3) GROUP BY c.CategoryName HAVING MAX(p.UnitPrice) > 50 ORDER BY `largestPrice` desc","title":"Grouping and Having"},{"location":"Grouping/#code-example","text":"import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts a country parameter // Filtering products based on price and supplier country, or stock quantity // Filtering the results based on maximum price // Mapping the results to get the product category and maximum price // Sorting the results in descending order by maximum price const query = (country:string) => Products .filter(p => (p.price > 5 && p.supplier.country == country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) const result = await orm.execute(query, {country:'ARG'}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Include/","text":"Include \u03bbORM includes the include method to load related entities, both for OneToMany, manyToOne, and oneToOne relationships. We can also apply filters or bring us some fields from related entities. For each include, a statement is executed that fetches all the necessary records, then the objects with relationships are assembled in memory. In this way, multiple executions are avoided, considerably improving performance. Includes can be used in selects, inserts, updates, deletes, and bulkInserts. Include relation OneToMany In this example the data of an Order and the customer is obtained Lambda: // Filters orders based on ID matching the provided parameter and includes customer details Orders.filter(p => p.id == id).include(p => p.customer) SQL Result: -- Selects order details from the Orders table where the OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects customer details from the Customers table where the CustomerID matches the provided parameter -- The CustomerID is expected to be in the result set of the previous query SELECT c.CustomerID AS `id`, c.CompanyName AS `name`, c.ContactName AS `contact`, c.ContactTitle AS `phone`, c.Address AS `address`, c.City AS `city`, c.Region AS `region`, c.PostalCode AS `postalCode`, c.Country AS `country` FROM Customers c WHERE c.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ] Include relation OneToMany and manyToOne In this example, the data of an Order, the customer and the details of the related Order are obtained. Lambda: // Filters orders based on the provided ID and includes details and customers Orders.filter(p => p.id == id).include(p => [p.details,p.customer]) SQL Result: -- Selects order details from the Orders table where OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects order details from the Order Details table where OrderID is in the result set of the previous query SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects customer details from the Customers table where CustomerID is in the result set of the previous query -- CustomerID is expected to be in the result set of the previous query SELECT c.CustomerID AS `id`, c.CompanyName AS `name`, c.ContactName AS `contact`, c.ContactTitle AS `phone`, c.Address AS `address`, c.City AS `city`, c.Region AS `region`, c.PostalCode AS `postalCode`, c.Country AS `country` FROM Customers c WHERE c.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"details\": [ { \"orderId\": 10248, \"productId\": 11, \"unitPrice\": 14, \"quantity\": 12, \"discount\": 0 }, { \"orderId\": 10248, \"productId\": 42, \"unitPrice\": 9.8, \"quantity\": 10, \"discount\": 0 }, { \"orderId\": 10248, \"productId\": 72, \"unitPrice\": 34.8, \"quantity\": 5, \"discount\": 0 } ], \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ] Nested includes In this example, in the relationship with Orders detail, its relationship with Product is brought and in turn for each product its relationship with Category is brought. Lambda: // Filters orders based on the provided ID and includes details (with product and category) and customers Orders .filter(p => p.id == id) .include(p => [p.details.include(q => q.product.include(r => r.category)), p.customer]) SQL Result: -- Selects order details from the Orders table where OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects order details from the Order Details table where OrderID is in the result set of the previous query SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects product details from the Products table where ProductID is in the result set of the previous query -- ProductID is expected to be in the result set of the previous query SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p WHERE p.ProductID IN (?) -- Selects category details from the Categories table where CategoryID is in the result set of the previous query -- CategoryID is expected to be in the result set of the previous query SELECT c.CategoryID AS `id`, c.CategoryName AS `name`, c.Description AS `description` FROM Categories c WHERE c.CategoryID IN (?) -- Selects customer details from the Customers table where CustomerID is in the result set of the previous query -- CustomerID is expected to be in the result set of the previous query SELECT c1.CustomerID AS `id`, c1.CompanyName AS `name`, c1.ContactName AS `contact`, c1.ContactTitle AS `phone`, c1.Address AS `address`, c1.City AS `city`, c1.Region AS `region`, c1.PostalCode AS `postalCode`, c1.Country AS `country` FROM Customers c1 WHERE c1.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"details\": [ { \"orderId\": 10248, \"productId\": 11, \"unitPrice\": 14, \"quantity\": 12, \"discount\": 0, \"product\": { \"id\": 11, \"name\": \"Queso Cabrales\", \"supplierId\": 5, \"categoryId\": 4, \"quantity\": \"1 kg pkg.\", \"price\": 21, \"inStock\": 22, \"onOrder\": 30, \"reorderLevel\": 30, \"discontinued\": false, \"category\": { \"id\": 4, \"name\": \"Dairy Products\", \"description\": \"Cheeses\" } } }, { \"orderId\": 10248, \"productId\": 42, \"unitPrice\": 9.8, \"quantity\": 10, \"discount\": 0, \"product\": { \"id\": 42, \"name\": \"Singaporean Hokkien Fried Mee\", \"supplierId\": 20, \"categoryId\": 5, \"quantity\": \"32 - 1 kg pkgs.\", \"price\": 14, \"inStock\": 26, \"onOrder\": 0, \"reorderLevel\": 0, \"discontinued\": true, \"category\": { \"id\": 5, \"name\": \"Grains/Cereals\", \"description\": \"Breads, crackers, pasta, and cereal\" } } }, { \"orderId\": 10248, \"productId\": 72, \"unitPrice\": 34.8, \"quantity\": 5, \"discount\": 0, \"product\": { \"id\": 72, \"name\": \"Mozzarella di Giovanni\", \"supplierId\": 14, \"categoryId\": 4, \"quantity\": \"24 - 200 g pkgs.\", \"price\": 34.8, \"inStock\": 14, \"onOrder\": 0, \"reorderLevel\": 0, \"discontinued\": false, \"category\": { \"id\": 4, \"name\": \"Dairy Products\", \"description\": \"Cheeses\" } } } ], \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ] includes with some fields In this example some fields are brought from the main entity as well as from the included entities. This allows us to create queries that return only the data we need. Lambda: // Filters orders based on the provided ID and includes customer details, order details (with product category), and order date Orders.filter(p => p.id === id) .include(p => [ // Includes customer name and concatenated address p.customer.map(p => ( { name:p.name, address:concat(p.address,', ',p.city,' (', p.postalCode,') ', p.country) })), // Includes order details with product names and quantities p.details.include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice])]) // Maps to retrieve order dates .map(p => p.orderDate) SQL Result: -- Selects order dates from the Orders table where OrderID matches the provided parameter -- Parameterized query: OrderID is replaced with the provided parameter SELECT o.OrderDate AS `orderDate` FROM Orders o WHERE o.OrderID = ? -- Selects customer company name and concatenated address from the Customers table where CustomerID is in the result set of the previous query -- Parameterized query: CustomerID is replaced with the result set of the previous query SELECT c.CompanyName AS `name`, CONCAT(c.Address,', ',c.City,' (',c.PostalCode,') ',c.Country) AS `address` FROM Customers c WHERE c.CustomerID IN (?) -- Selects order details (quantity and unit price) from the Order Details table where OrderID is in the result set of the previous query -- Parameterized query: OrderID is replaced with the result set of the previous query SELECT o1.Quantity AS `quantity`, o1.UnitPrice AS `unitPrice` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects product names from the Products table where ProductID is in the result set of the previous query -- Parameterized query: ProductID is replaced with the result set of the previous query SELECT p.ProductName AS `name` FROM Products p WHERE p.ProductID IN (?) -- Parameterized query: ProductID is replaced with the result set of the previous query -- Parameterized query: CategoryID is replaced with the result set of the previous query SELECT c1.CategoryName AS `name` FROM Categories c1 WHERE c1.CategoryID IN (?) Data Result: [ [ { \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"customer\": { \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l'Abbaye, Reims (51100) France\" }, \"details\": [ { \"quantity\": 12, \"unitPrice\": 14, \"product\": { \"name\": \"Queso Cabrales\", \"category\": { \"name\": \"Dairy Products\" } } }, { \"quantity\": 10, \"unitPrice\": 9.8, \"product\": { \"name\": \"Singaporean Hokkien Fried Mee\", \"category\": { \"name\": \"Grains/Cereals\" } } }, { \"quantity\": 5, \"unitPrice\": 34.8, \"product\": { \"name\": \"Mozzarella di Giovanni\", \"category\": { \"name\": \"Dairy Products\" } } } ] } ] ] Code example import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts an order ID parameter // Filtering orders based on ID matching the provided parameter // Including related entities such as customer details and order details // Including customer details // Including order details with product information const query = (id:number) => Orders .filter(p => p.id === id) .include(p => [ p.customer.map(p => ( { name:p.name, address:concat(p.address,', ',p.city,' (', p.postalCode,') ', p.country) })), p.details.include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice])]) .map(p => p.orderDate) // Executing the query with an order ID parameter of 830 const result = await orm.execute(query, {id: 830}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Include"},{"location":"Include/#include","text":"\u03bbORM includes the include method to load related entities, both for OneToMany, manyToOne, and oneToOne relationships. We can also apply filters or bring us some fields from related entities. For each include, a statement is executed that fetches all the necessary records, then the objects with relationships are assembled in memory. In this way, multiple executions are avoided, considerably improving performance. Includes can be used in selects, inserts, updates, deletes, and bulkInserts.","title":"Include"},{"location":"Include/#include-relation-onetomany","text":"In this example the data of an Order and the customer is obtained Lambda: // Filters orders based on ID matching the provided parameter and includes customer details Orders.filter(p => p.id == id).include(p => p.customer) SQL Result: -- Selects order details from the Orders table where the OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects customer details from the Customers table where the CustomerID matches the provided parameter -- The CustomerID is expected to be in the result set of the previous query SELECT c.CustomerID AS `id`, c.CompanyName AS `name`, c.ContactName AS `contact`, c.ContactTitle AS `phone`, c.Address AS `address`, c.City AS `city`, c.Region AS `region`, c.PostalCode AS `postalCode`, c.Country AS `country` FROM Customers c WHERE c.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ]","title":"Include relation OneToMany"},{"location":"Include/#include-relation-onetomany-and-manytoone","text":"In this example, the data of an Order, the customer and the details of the related Order are obtained. Lambda: // Filters orders based on the provided ID and includes details and customers Orders.filter(p => p.id == id).include(p => [p.details,p.customer]) SQL Result: -- Selects order details from the Orders table where OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects order details from the Order Details table where OrderID is in the result set of the previous query SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects customer details from the Customers table where CustomerID is in the result set of the previous query -- CustomerID is expected to be in the result set of the previous query SELECT c.CustomerID AS `id`, c.CompanyName AS `name`, c.ContactName AS `contact`, c.ContactTitle AS `phone`, c.Address AS `address`, c.City AS `city`, c.Region AS `region`, c.PostalCode AS `postalCode`, c.Country AS `country` FROM Customers c WHERE c.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"details\": [ { \"orderId\": 10248, \"productId\": 11, \"unitPrice\": 14, \"quantity\": 12, \"discount\": 0 }, { \"orderId\": 10248, \"productId\": 42, \"unitPrice\": 9.8, \"quantity\": 10, \"discount\": 0 }, { \"orderId\": 10248, \"productId\": 72, \"unitPrice\": 34.8, \"quantity\": 5, \"discount\": 0 } ], \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ]","title":"Include relation OneToMany and manyToOne"},{"location":"Include/#nested-includes","text":"In this example, in the relationship with Orders detail, its relationship with Product is brought and in turn for each product its relationship with Category is brought. Lambda: // Filters orders based on the provided ID and includes details (with product and category) and customers Orders .filter(p => p.id == id) .include(p => [p.details.include(q => q.product.include(r => r.category)), p.customer]) SQL Result: -- Selects order details from the Orders table where OrderID matches the provided parameter SELECT o.OrderID AS `id`, o.CustomerID AS `customerId`, o.EmployeeID AS `employeeId`, o.OrderDate AS `orderDate`, o.RequiredDate AS `requiredDate`, o.ShippedDate AS `shippedDate`, o.ShipVia AS `shipViaId`, o.Freight AS `freight`, o.ShipName AS `name`, o.ShipAddress AS `address`, o.ShipCity AS `city`, o.ShipRegion AS `region`, o.ShipPostalCode AS `postalCode`, o.ShipCountry AS `country` FROM Orders o WHERE o.OrderID = ? -- Selects order details from the Order Details table where OrderID is in the result set of the previous query SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects product details from the Products table where ProductID is in the result set of the previous query -- ProductID is expected to be in the result set of the previous query SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p WHERE p.ProductID IN (?) -- Selects category details from the Categories table where CategoryID is in the result set of the previous query -- CategoryID is expected to be in the result set of the previous query SELECT c.CategoryID AS `id`, c.CategoryName AS `name`, c.Description AS `description` FROM Categories c WHERE c.CategoryID IN (?) -- Selects customer details from the Customers table where CustomerID is in the result set of the previous query -- CustomerID is expected to be in the result set of the previous query SELECT c1.CustomerID AS `id`, c1.CompanyName AS `name`, c1.ContactName AS `contact`, c1.ContactTitle AS `phone`, c1.Address AS `address`, c1.City AS `city`, c1.Region AS `region`, c1.PostalCode AS `postalCode`, c1.Country AS `country` FROM Customers c1 WHERE c1.CustomerID IN (?) Data Result: [ { \"id\": 10248, \"customerId\": \"VINET\", \"employeeId\": 5, \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"requiredDate\": \"1996-07-31T22:00:00.000Z\", \"shippedDate\": \"1996-07-15T22:00:00.000Z\", \"shipViaId\": 3, \"freight\": 32.38, \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l-Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\", \"details\": [ { \"orderId\": 10248, \"productId\": 11, \"unitPrice\": 14, \"quantity\": 12, \"discount\": 0, \"product\": { \"id\": 11, \"name\": \"Queso Cabrales\", \"supplierId\": 5, \"categoryId\": 4, \"quantity\": \"1 kg pkg.\", \"price\": 21, \"inStock\": 22, \"onOrder\": 30, \"reorderLevel\": 30, \"discontinued\": false, \"category\": { \"id\": 4, \"name\": \"Dairy Products\", \"description\": \"Cheeses\" } } }, { \"orderId\": 10248, \"productId\": 42, \"unitPrice\": 9.8, \"quantity\": 10, \"discount\": 0, \"product\": { \"id\": 42, \"name\": \"Singaporean Hokkien Fried Mee\", \"supplierId\": 20, \"categoryId\": 5, \"quantity\": \"32 - 1 kg pkgs.\", \"price\": 14, \"inStock\": 26, \"onOrder\": 0, \"reorderLevel\": 0, \"discontinued\": true, \"category\": { \"id\": 5, \"name\": \"Grains/Cereals\", \"description\": \"Breads, crackers, pasta, and cereal\" } } }, { \"orderId\": 10248, \"productId\": 72, \"unitPrice\": 34.8, \"quantity\": 5, \"discount\": 0, \"product\": { \"id\": 72, \"name\": \"Mozzarella di Giovanni\", \"supplierId\": 14, \"categoryId\": 4, \"quantity\": \"24 - 200 g pkgs.\", \"price\": 34.8, \"inStock\": 14, \"onOrder\": 0, \"reorderLevel\": 0, \"discontinued\": false, \"category\": { \"id\": 4, \"name\": \"Dairy Products\", \"description\": \"Cheeses\" } } } ], \"customer\": { \"id\": \"VINET\", \"name\": \"Vins et alcools Chevalier\", \"contact\": \"Paul Henriot\", \"phone\": \"Accounting Manager\", \"address\": \"59 rue de l'Abbaye\", \"city\": \"Reims\", \"region\": null, \"postalCode\": \"51100\", \"country\": \"France\" } } ]","title":"Nested includes"},{"location":"Include/#includes-with-some-fields","text":"In this example some fields are brought from the main entity as well as from the included entities. This allows us to create queries that return only the data we need. Lambda: // Filters orders based on the provided ID and includes customer details, order details (with product category), and order date Orders.filter(p => p.id === id) .include(p => [ // Includes customer name and concatenated address p.customer.map(p => ( { name:p.name, address:concat(p.address,', ',p.city,' (', p.postalCode,') ', p.country) })), // Includes order details with product names and quantities p.details.include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice])]) // Maps to retrieve order dates .map(p => p.orderDate) SQL Result: -- Selects order dates from the Orders table where OrderID matches the provided parameter -- Parameterized query: OrderID is replaced with the provided parameter SELECT o.OrderDate AS `orderDate` FROM Orders o WHERE o.OrderID = ? -- Selects customer company name and concatenated address from the Customers table where CustomerID is in the result set of the previous query -- Parameterized query: CustomerID is replaced with the result set of the previous query SELECT c.CompanyName AS `name`, CONCAT(c.Address,', ',c.City,' (',c.PostalCode,') ',c.Country) AS `address` FROM Customers c WHERE c.CustomerID IN (?) -- Selects order details (quantity and unit price) from the Order Details table where OrderID is in the result set of the previous query -- Parameterized query: OrderID is replaced with the result set of the previous query SELECT o1.Quantity AS `quantity`, o1.UnitPrice AS `unitPrice` FROM `Order Details` o1 WHERE o1.OrderID IN (?) -- Selects product names from the Products table where ProductID is in the result set of the previous query -- Parameterized query: ProductID is replaced with the result set of the previous query SELECT p.ProductName AS `name` FROM Products p WHERE p.ProductID IN (?) -- Parameterized query: ProductID is replaced with the result set of the previous query -- Parameterized query: CategoryID is replaced with the result set of the previous query SELECT c1.CategoryName AS `name` FROM Categories c1 WHERE c1.CategoryID IN (?) Data Result: [ [ { \"orderDate\": \"1996-07-03T22:00:00.000Z\", \"customer\": { \"name\": \"Vins et alcools Chevalier\", \"address\": \"59 rue de l'Abbaye, Reims (51100) France\" }, \"details\": [ { \"quantity\": 12, \"unitPrice\": 14, \"product\": { \"name\": \"Queso Cabrales\", \"category\": { \"name\": \"Dairy Products\" } } }, { \"quantity\": 10, \"unitPrice\": 9.8, \"product\": { \"name\": \"Singaporean Hokkien Fried Mee\", \"category\": { \"name\": \"Grains/Cereals\" } } }, { \"quantity\": 5, \"unitPrice\": 34.8, \"product\": { \"name\": \"Mozzarella di Giovanni\", \"category\": { \"name\": \"Dairy Products\" } } } ] } ] ]","title":"includes with some fields"},{"location":"Include/#code-example","text":"import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts an order ID parameter // Filtering orders based on ID matching the provided parameter // Including related entities such as customer details and order details // Including customer details // Including order details with product information const query = (id:number) => Orders .filter(p => p.id === id) .include(p => [ p.customer.map(p => ( { name:p.name, address:concat(p.address,', ',p.city,' (', p.postalCode,') ', p.country) })), p.details.include(p => p.product .include(p => p.category.map(p => p.name)) .map(p => p.name)) .map(p => [p.quantity, p.unitPrice])]) .map(p => p.orderDate) // Executing the query with an order ID parameter of 830 const result = await orm.execute(query, {id: 830}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Insert/","text":"Insert Since the queries are based on both the expression and the definition in the schema, in the case of wanting to insert all the fields it is not necessary to define them since it is assumed if none are defined. The mapping to the source(s) is resolved according to the mapping configuration associated with each source in the schema. Insert Simple In the case that the fields to be inserted are not specified, it is assumed that an object with all fields will be passed. Lambda: // Inserting into Categories table without specifying fields Categories.insert() SQL Result: -- Inserting into Categories table with CategoryName and Description fields INSERT INTO Categories(CategoryName,Description) VALUES(?,?) Insert specific In this case, only the fields that are specified will be inserted Lambda: // Inserting into Categories table with only the name field specified Categories.insert({ name: name }) SQL Result: -- Inserting into Categories table with CategoryName field specified INSERT INTO Categories(CategoryName) VALUES(?) Insert with include In the case that we need to insert an object which in turn has a relation, we can insert the set using include. Lambda: // Inserting into Orders table and including details Orders.insert().include(p => p.details) SQL Result: -- Inserting into Orders table with all required fields INSERT INTO Orders(CustomerID,EmployeeID,OrderDate,RequiredDate,ShippedDate,ShipVia,Freight,ShipName,ShipAddress,ShipCity,ShipRegion,ShipPostalCode,ShipCountry) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?) -- Inserting into Order Details table with all required fields INSERT INTO `Order Details`(OrderID,ProductID,UnitPrice,Quantity,Discount) VALUES(?,?,?,?,?) Code example import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { customerId: 'VINET', employeeId: 5, orderDate: '1996-07-03T22:00:00.000Z', requiredDate: '1996-07-31T22:00:00.000Z', shippedDate: '1996-07-15T22:00:00.000Z', shipViaId: 3, freight: 32.38, name: 'Vins et alcools Chevalier', address: '59 rue de l-Abbaye', city: 'Reims', postalCode: '51100', country: 'France', details: [ { productId: 11, unitPrice: 14, quantity: 12, discount: 10, orderId: 833 }, { productId: 42, unitPrice: 9.8, quantity: 10, discount: 10, orderId: 833 } ] } // Defining a query to insert into Orders and include details const query = () => Orders.insert().include(p => p.details) // Executing the query using the ORM with the specified order parameter const result = await orm.execute(query, order) // return ID of order created console.log(JSON.stringify(result)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Insert"},{"location":"Insert/#insert","text":"Since the queries are based on both the expression and the definition in the schema, in the case of wanting to insert all the fields it is not necessary to define them since it is assumed if none are defined. The mapping to the source(s) is resolved according to the mapping configuration associated with each source in the schema.","title":"Insert"},{"location":"Insert/#insert-simple","text":"In the case that the fields to be inserted are not specified, it is assumed that an object with all fields will be passed. Lambda: // Inserting into Categories table without specifying fields Categories.insert() SQL Result: -- Inserting into Categories table with CategoryName and Description fields INSERT INTO Categories(CategoryName,Description) VALUES(?,?)","title":"Insert Simple"},{"location":"Insert/#insert-specific","text":"In this case, only the fields that are specified will be inserted Lambda: // Inserting into Categories table with only the name field specified Categories.insert({ name: name }) SQL Result: -- Inserting into Categories table with CategoryName field specified INSERT INTO Categories(CategoryName) VALUES(?)","title":"Insert specific"},{"location":"Insert/#insert-with-include","text":"In the case that we need to insert an object which in turn has a relation, we can insert the set using include. Lambda: // Inserting into Orders table and including details Orders.insert().include(p => p.details) SQL Result: -- Inserting into Orders table with all required fields INSERT INTO Orders(CustomerID,EmployeeID,OrderDate,RequiredDate,ShippedDate,ShipVia,Freight,ShipName,ShipAddress,ShipCity,ShipRegion,ShipPostalCode,ShipCountry) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?) -- Inserting into Order Details table with all required fields INSERT INTO `Order Details`(OrderID,ProductID,UnitPrice,Quantity,Discount) VALUES(?,?,?,?,?)","title":"Insert with include"},{"location":"Insert/#code-example","text":"import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { customerId: 'VINET', employeeId: 5, orderDate: '1996-07-03T22:00:00.000Z', requiredDate: '1996-07-31T22:00:00.000Z', shippedDate: '1996-07-15T22:00:00.000Z', shipViaId: 3, freight: 32.38, name: 'Vins et alcools Chevalier', address: '59 rue de l-Abbaye', city: 'Reims', postalCode: '51100', country: 'France', details: [ { productId: 11, unitPrice: 14, quantity: 12, discount: 10, orderId: 833 }, { productId: 42, unitPrice: 9.8, quantity: 10, discount: 10, orderId: 833 } ] } // Defining a query to insert into Orders and include details const query = () => Orders.insert().include(p => p.details) // Executing the query using the ORM with the specified order parameter const result = await orm.execute(query, order) // return ID of order created console.log(JSON.stringify(result)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Join/","text":"Join Join statements are implicit when they add fields through their relationships. Join simple Retrieves the product name and its category through a relationship. Lambda: Products.map(p => ({ name: p.name, category: p.category.name })) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID Join with distinct and sort Retrieves distinct values of quantity per unit and category, sorted by category. Lambda: Products .distinct(p => ({ quantity: p.quantity, category: p.category.name })) .sort(p => p.category) SQL Result: -- Selects distinct values of quantity per unit as `quantity` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Orders the results by `category`. SELECT DISTINCT p.QuantityPerUnit AS `quantity`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ORDER BY `category` Join with filter Retrieves the product name and its category, but only for products with a price greater than 10. Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name })) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Filters products with a price greater than 10. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > 10 Join and pagination Retrieves the product name and its category for products with a price greater than 10, ordered by category and paginated. Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Filters products with a price greater than 10. -- Orders the results by `category` and limits them to 10 results per page, starting from page 1. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > 10 ORDER BY `category` LIMIT 0,10 Multiple Join and grouping Retrieves the order date and the total for each order for a specific customer, ordered by total in descending order. Lambda: OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) SQL Result: -- Selects the order date as `order` and the sum of quantity times unit price as `total`. -- Performs inner joins between the Order Details table and the Orders and Customers tables using OrderID and CustomerID respectively. -- Filters orders associated with the provided customer name. -- Groups the results by order date. -- Orders the results by `total` in descending order. SELECT o1.OrderDate AS `order`, SUM(o.Quantity * o.UnitPrice) AS `total` FROM `Order Details` o INNER JOIN Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Customers c ON c.CustomerID = o1.CustomerID WHERE c.CompanyName = ? GROUP BY o1.OrderDate ORDER BY `total` desc Code example import { orm } from '../../lib' import { OrderDetails } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const query = OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) const result = await orm.execute(query, {maxPrice:10}, {stage:'MySQL'}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { await orm.end() } })()","title":"Join"},{"location":"Join/#join","text":"Join statements are implicit when they add fields through their relationships.","title":"Join"},{"location":"Join/#join-simple","text":"Retrieves the product name and its category through a relationship. Lambda: Products.map(p => ({ name: p.name, category: p.category.name })) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID","title":"Join simple"},{"location":"Join/#join-with-distinct-and-sort","text":"Retrieves distinct values of quantity per unit and category, sorted by category. Lambda: Products .distinct(p => ({ quantity: p.quantity, category: p.category.name })) .sort(p => p.category) SQL Result: -- Selects distinct values of quantity per unit as `quantity` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Orders the results by `category`. SELECT DISTINCT p.QuantityPerUnit AS `quantity`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ORDER BY `category`","title":"Join with distinct and sort"},{"location":"Join/#join-with-filter","text":"Retrieves the product name and its category, but only for products with a price greater than 10. Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name })) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Filters products with a price greater than 10. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > 10","title":"Join with filter"},{"location":"Join/#join-and-pagination","text":"Retrieves the product name and its category for products with a price greater than 10, ordered by category and paginated. Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) SQL Result: -- Selects the product name as `name` and the category name as `category`. -- Performs an inner join between the Products table and the Categories table using CategoryID. -- Filters products with a price greater than 10. -- Orders the results by `category` and limits them to 10 results per page, starting from page 1. SELECT p.ProductName AS `name`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > 10 ORDER BY `category` LIMIT 0,10","title":"Join and pagination"},{"location":"Join/#multiple-join-and-grouping","text":"Retrieves the order date and the total for each order for a specific customer, ordered by total in descending order. Lambda: OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) SQL Result: -- Selects the order date as `order` and the sum of quantity times unit price as `total`. -- Performs inner joins between the Order Details table and the Orders and Customers tables using OrderID and CustomerID respectively. -- Filters orders associated with the provided customer name. -- Groups the results by order date. -- Orders the results by `total` in descending order. SELECT o1.OrderDate AS `order`, SUM(o.Quantity * o.UnitPrice) AS `total` FROM `Order Details` o INNER JOIN Orders o1 ON o1.OrderID = o.OrderID INNER JOIN Customers c ON c.CustomerID = o1.CustomerID WHERE c.CompanyName = ? GROUP BY o1.OrderDate ORDER BY `total` desc","title":"Multiple Join and grouping"},{"location":"Join/#code-example","text":"import { orm } from '../../lib' import { OrderDetails } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const query = OrderDetails .filter(p => p.order.customer.name == customerName) .map(p => ({ order: p.order.orderDate, total: sum(p.quantity * p.unitPrice) })) .sort(p => desc(p.total)) const result = await orm.execute(query, {maxPrice:10}, {stage:'MySQL'}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { await orm.end() } })()","title":"Code example"},{"location":"Metadata/","text":"Metadata Lambda ORM has the following methods to extract metadata information from queries. To execute these methods it is not necessary to connect to the database. method Description Path parameters Get parameters in the query orm.parameters(query) model Get model of the result in an execution orm.model(query) metadata Get metadata of the query orm.metadata(query) plan Get plan in the dialect of the physical model orm.plan(query) constraints Get constraints of query orm.constraints(query) Example: import { orm } from 'lambdaorm' (async () => { try { await orm.init() const query = (id:number) => Orders.filter(p => p.id === id).include(p => p.details).map(p => ({ name: p.orderDate, customer: p.customer.name })) const parameters = await orm.parameters(query) const model = await orm.model(query) const sentences = await orm.sentence(query) const constraints = await orm.constraints(query) const plan = await orm.plan(query) console.log(JSON.stringify(parameters, null, 2)) console.log(JSON.stringify(model, null, 2)) console.log(JSON.stringify(sentences, null, 2)) console.log(JSON.stringify(constraints, null, 2)) console.log(JSON.stringify(plan, null, 2)) } catch (error) { console.log(error) } finally { await orm.end() } })() Results: Parameters: { \"id\": \"integer\" } Model: { \"name\": \"dateTime\", \"customer\": \"string\", \"details\": [ { \"orderId\": \"integer\", \"productId\": \"integer\", \"unitPrice\": \"decimal\", \"quantity\": \"decimal\", \"discount\": \"decimal\" } ] } Metadata: {\"n\":\"select\",\"t\":\"Sentence\",\"c\":[{\"n\":\"filter\",\"t\":\"Filter\",\"c\":[{\"n\":\"===\",\"t\":\"Operator\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderID\"},{\"n\":\"id\",\"t\":\"Variable\",\"c\":[],\"u\":1}]}]},{\"n\":\"Orders.o\",\"t\":\"From\",\"c\":[]},{\"n\":\"map\",\"t\":\"Map\",\"c\":[{\"n\":\"obj\",\"t\":\"Obj\",\"c\":[{\"n\":\"name\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderDate\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderDate\"}]},{\"n\":\"customer\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"name\",\"t\":\"Field\",\"c\":[],\"e\":\"Customers\",\"m\":\"c.CompanyName\"}]},{\"n\":\"__id\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderID\"}]}]}]},{\"n\":\"details\",\"t\":\"SentenceInclude\",\"c\":[{\"n\":\"select\",\"t\":\"Sentence\",\"c\":[{\"n\":\"filter\",\"t\":\"Filter\",\"c\":[{\"n\":\"includes\",\"t\":\"FunctionRef\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"},{\"n\":\"__parentId\",\"t\":\"Variable\",\"c\":[],\"u\":1}]}]},{\"n\":\"Order Details.o1\",\"t\":\"From\",\"c\":[]},{\"n\":\"map\",\"t\":\"Map\",\"c\":[{\"n\":\"obj\",\"t\":\"Obj\",\"c\":[{\"n\":\"orderId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"}]},{\"n\":\"productId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"productId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.ProductID\"}]},{\"n\":\"unitPrice\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"unitPrice\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.UnitPrice\"}]},{\"n\":\"quantity\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"quantity\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.Quantity\"}]},{\"n\":\"discount\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"discount\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.Discount\"}]},{\"n\":\"__parentId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"}]}]}]}],\"f\":[{\"name\":\"orderId\",\"type\":\"integer\"},{\"name\":\"productId\",\"type\":\"integer\"},{\"name\":\"unitPrice\",\"type\":\"decimal\"},{\"name\":\"quantity\",\"type\":\"decimal\"},{\"name\":\"discount\",\"type\":\"decimal\"},{\"name\":\"__parentId\",\"type\":\"integer\"}],\"p\":[{\"name\":\"__parentId\",\"type\":\"array\"}],\"e\":\"OrderDetails\"}],\"r\":{\"name\":\"details\",\"type\":\"manyToOne\",\"composite\":true,\"from\":\"id\",\"entity\":\"OrderDetails\",\"to\":\"orderId\"}},{\"n\":\"Customers.c\",\"t\":\"Join\",\"c\":[{\"n\":\"==\",\"t\":\"Operator\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Customers\",\"m\":\"c.CustomerID\"},{\"n\":\"customerId\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.CustomerID\"}]}]}],\"f\":[{\"name\":\"name\",\"type\":\"dateTime\"},{\"name\":\"customer\",\"type\":\"string\"},{\"name\":\"__id\",\"type\":\"integer\"}],\"p\":[{\"name\":\"id\",\"type\":\"integer\"}],\"e\":\"Orders\",\"a\":{\"name\":\"id\",\"mapping\":\"OrderID\",\"type\":\"integer\",\"autoIncrement\":true}} Plan: SELECT o.OrderDate AS `name`, c.CompanyName AS `customer`, o.OrderID AS `__id` FROM Orders o INNER JOIN Customers c ON c.CustomerID = o.CustomerID WHERE o.OrderID = ? SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount`, o1.OrderID AS `__parentId` FROM `Order Details` o1 WHERE o1.OrderID IN (?)","title":"Metadata"},{"location":"Metadata/#metadata","text":"Lambda ORM has the following methods to extract metadata information from queries. To execute these methods it is not necessary to connect to the database. method Description Path parameters Get parameters in the query orm.parameters(query) model Get model of the result in an execution orm.model(query) metadata Get metadata of the query orm.metadata(query) plan Get plan in the dialect of the physical model orm.plan(query) constraints Get constraints of query orm.constraints(query)","title":"Metadata"},{"location":"Metadata/#example","text":"import { orm } from 'lambdaorm' (async () => { try { await orm.init() const query = (id:number) => Orders.filter(p => p.id === id).include(p => p.details).map(p => ({ name: p.orderDate, customer: p.customer.name })) const parameters = await orm.parameters(query) const model = await orm.model(query) const sentences = await orm.sentence(query) const constraints = await orm.constraints(query) const plan = await orm.plan(query) console.log(JSON.stringify(parameters, null, 2)) console.log(JSON.stringify(model, null, 2)) console.log(JSON.stringify(sentences, null, 2)) console.log(JSON.stringify(constraints, null, 2)) console.log(JSON.stringify(plan, null, 2)) } catch (error) { console.log(error) } finally { await orm.end() } })()","title":"Example:"},{"location":"Metadata/#results","text":"Parameters: { \"id\": \"integer\" } Model: { \"name\": \"dateTime\", \"customer\": \"string\", \"details\": [ { \"orderId\": \"integer\", \"productId\": \"integer\", \"unitPrice\": \"decimal\", \"quantity\": \"decimal\", \"discount\": \"decimal\" } ] } Metadata: {\"n\":\"select\",\"t\":\"Sentence\",\"c\":[{\"n\":\"filter\",\"t\":\"Filter\",\"c\":[{\"n\":\"===\",\"t\":\"Operator\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderID\"},{\"n\":\"id\",\"t\":\"Variable\",\"c\":[],\"u\":1}]}]},{\"n\":\"Orders.o\",\"t\":\"From\",\"c\":[]},{\"n\":\"map\",\"t\":\"Map\",\"c\":[{\"n\":\"obj\",\"t\":\"Obj\",\"c\":[{\"n\":\"name\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderDate\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderDate\"}]},{\"n\":\"customer\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"name\",\"t\":\"Field\",\"c\":[],\"e\":\"Customers\",\"m\":\"c.CompanyName\"}]},{\"n\":\"__id\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.OrderID\"}]}]}]},{\"n\":\"details\",\"t\":\"SentenceInclude\",\"c\":[{\"n\":\"select\",\"t\":\"Sentence\",\"c\":[{\"n\":\"filter\",\"t\":\"Filter\",\"c\":[{\"n\":\"includes\",\"t\":\"FunctionRef\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"},{\"n\":\"__parentId\",\"t\":\"Variable\",\"c\":[],\"u\":1}]}]},{\"n\":\"Order Details.o1\",\"t\":\"From\",\"c\":[]},{\"n\":\"map\",\"t\":\"Map\",\"c\":[{\"n\":\"obj\",\"t\":\"Obj\",\"c\":[{\"n\":\"orderId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"}]},{\"n\":\"productId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"productId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.ProductID\"}]},{\"n\":\"unitPrice\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"unitPrice\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.UnitPrice\"}]},{\"n\":\"quantity\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"quantity\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.Quantity\"}]},{\"n\":\"discount\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"discount\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.Discount\"}]},{\"n\":\"__parentId\",\"t\":\"KeyValue\",\"c\":[{\"n\":\"orderId\",\"t\":\"Field\",\"c\":[],\"e\":\"OrderDetails\",\"m\":\"o1.OrderID\"}]}]}]}],\"f\":[{\"name\":\"orderId\",\"type\":\"integer\"},{\"name\":\"productId\",\"type\":\"integer\"},{\"name\":\"unitPrice\",\"type\":\"decimal\"},{\"name\":\"quantity\",\"type\":\"decimal\"},{\"name\":\"discount\",\"type\":\"decimal\"},{\"name\":\"__parentId\",\"type\":\"integer\"}],\"p\":[{\"name\":\"__parentId\",\"type\":\"array\"}],\"e\":\"OrderDetails\"}],\"r\":{\"name\":\"details\",\"type\":\"manyToOne\",\"composite\":true,\"from\":\"id\",\"entity\":\"OrderDetails\",\"to\":\"orderId\"}},{\"n\":\"Customers.c\",\"t\":\"Join\",\"c\":[{\"n\":\"==\",\"t\":\"Operator\",\"c\":[{\"n\":\"id\",\"t\":\"Field\",\"c\":[],\"e\":\"Customers\",\"m\":\"c.CustomerID\"},{\"n\":\"customerId\",\"t\":\"Field\",\"c\":[],\"e\":\"Orders\",\"m\":\"o.CustomerID\"}]}]}],\"f\":[{\"name\":\"name\",\"type\":\"dateTime\"},{\"name\":\"customer\",\"type\":\"string\"},{\"name\":\"__id\",\"type\":\"integer\"}],\"p\":[{\"name\":\"id\",\"type\":\"integer\"}],\"e\":\"Orders\",\"a\":{\"name\":\"id\",\"mapping\":\"OrderID\",\"type\":\"integer\",\"autoIncrement\":true}} Plan: SELECT o.OrderDate AS `name`, c.CompanyName AS `customer`, o.OrderID AS `__id` FROM Orders o INNER JOIN Customers c ON c.CustomerID = o.CustomerID WHERE o.OrderID = ? SELECT o1.OrderID AS `orderId`, o1.ProductID AS `productId`, o1.UnitPrice AS `unitPrice`, o1.Quantity AS `quantity`, o1.Discount AS `discount`, o1.OrderID AS `__parentId` FROM `Order Details` o1 WHERE o1.OrderID IN (?)","title":"Results:"},{"location":"Query-Language/","text":"Query Language The query language is based on javascript lambda expression . These Queries can be written as javascript code by browsing the business model entities. Queries can also be sent as a string \u03bbOrm translates the query into the language corresponding to each database engine. Queries type DQL Las consultas DQL (Data Query Language) son consultas utilizadas para recuperar datos de una base de datos. Las consultas DQL pueden ser bastante simples o pueden incluir cl\u00e1usulas adicionales para filtrar, ordenar o agrupar datos, as\u00ed como para realizar c\u00e1lculos y operaciones en los datos recuperados. Esto permite a los desarrolladores obtener los datos exactos que necesitan de una base de datos seg\u00fan los requisitos de la aplicaci\u00f3n. View: Select Join Grouping Include DML DML (Data Manipulation Language) queries are used to manipulate data in a database. Mainly, they include the following operations: INSERT: Used to add new records to a table. UPDATE: Used to modify existing records in a table. DELETE: Used to delete records from a table. View: Insert BulkInsert Update Delete DDL DDL (Data Definition Language) are used to define, modify and delete database structures and related objects. Mainly, they include the following operations: CREATE: Used to create new objects in the database, such as tables, indexes, views and other objects. ALTER: Used to modify the structure of existing objects in the database, such as adding, modifying or deleting columns from a table, changing the data type of a column, renaming an object, among others. DROP: Used to delete database objects, such as tables, indexes, views and other objects. These queries are created and executed when you use the schema synchronization commands. View: Push Pull Fetch Introspect Incorporate Example: // Selecting countries filtering by region and including related states starting with 'F', with pagination Countries .filter(p=> p.region == region) .map(p=> [p.name,p.subregion,p.latitude,p.longitude]) // Selecting country fields .include(p => p.states.filter(p=> substr(p.name,1,1)==\"F\") // Including states starting with 'F' .map(p=> [p.name,p.latitude,p.longitude]) ) .page(1,3) // Pagination for countries, 3 records per page where the SQL equivalent of the query is: -- Selecting countries based on region and limiting to 3 records SELECT c.name AS `name`, c.subregion AS `subregion`, c.latitude AS `latitude`, c.longitude AS `longitude`, c.iso3 AS `__iso3` FROM Countries c WHERE c.region = ? LIMIT 0,3 -- Selecting states starting with 'F' belonging to the specified countries SELECT s.NAME AS \"name\", s.LATITUDE AS \"latitude\", s.LONGITUDE AS \"longitude\", s.COUNTRY_CODE AS \"__parentId\" FROM TBL_STATES s WHERE SUBSTR(s.NAME,1,1) = 'F' AND s.s.COUNTRY_CODE IN (?) Advantage of Query Language Use of the same programming language. No need to learn a new language. queries easy to write and understand. Use of the intellisense offered by the IDE to write the expressions. Avoid syntax errors.","title":"Query Language"},{"location":"Query-Language/#query-language","text":"The query language is based on javascript lambda expression . These Queries can be written as javascript code by browsing the business model entities. Queries can also be sent as a string \u03bbOrm translates the query into the language corresponding to each database engine.","title":"Query Language"},{"location":"Query-Language/#queries-type","text":"","title":"Queries type"},{"location":"Query-Language/#dql","text":"Las consultas DQL (Data Query Language) son consultas utilizadas para recuperar datos de una base de datos. Las consultas DQL pueden ser bastante simples o pueden incluir cl\u00e1usulas adicionales para filtrar, ordenar o agrupar datos, as\u00ed como para realizar c\u00e1lculos y operaciones en los datos recuperados. Esto permite a los desarrolladores obtener los datos exactos que necesitan de una base de datos seg\u00fan los requisitos de la aplicaci\u00f3n. View: Select Join Grouping Include","title":"DQL"},{"location":"Query-Language/#dml","text":"DML (Data Manipulation Language) queries are used to manipulate data in a database. Mainly, they include the following operations: INSERT: Used to add new records to a table. UPDATE: Used to modify existing records in a table. DELETE: Used to delete records from a table. View: Insert BulkInsert Update Delete","title":"DML"},{"location":"Query-Language/#ddl","text":"DDL (Data Definition Language) are used to define, modify and delete database structures and related objects. Mainly, they include the following operations: CREATE: Used to create new objects in the database, such as tables, indexes, views and other objects. ALTER: Used to modify the structure of existing objects in the database, such as adding, modifying or deleting columns from a table, changing the data type of a column, renaming an object, among others. DROP: Used to delete database objects, such as tables, indexes, views and other objects. These queries are created and executed when you use the schema synchronization commands. View: Push Pull Fetch Introspect Incorporate","title":"DDL"},{"location":"Query-Language/#example","text":"// Selecting countries filtering by region and including related states starting with 'F', with pagination Countries .filter(p=> p.region == region) .map(p=> [p.name,p.subregion,p.latitude,p.longitude]) // Selecting country fields .include(p => p.states.filter(p=> substr(p.name,1,1)==\"F\") // Including states starting with 'F' .map(p=> [p.name,p.latitude,p.longitude]) ) .page(1,3) // Pagination for countries, 3 records per page where the SQL equivalent of the query is: -- Selecting countries based on region and limiting to 3 records SELECT c.name AS `name`, c.subregion AS `subregion`, c.latitude AS `latitude`, c.longitude AS `longitude`, c.iso3 AS `__iso3` FROM Countries c WHERE c.region = ? LIMIT 0,3 -- Selecting states starting with 'F' belonging to the specified countries SELECT s.NAME AS \"name\", s.LATITUDE AS \"latitude\", s.LONGITUDE AS \"longitude\", s.COUNTRY_CODE AS \"__parentId\" FROM TBL_STATES s WHERE SUBSTR(s.NAME,1,1) = 'F' AND s.s.COUNTRY_CODE IN (?)","title":"Example:"},{"location":"Query-Language/#advantage-of-query-language","text":"Use of the same programming language. No need to learn a new language. queries easy to write and understand. Use of the intellisense offered by the IDE to write the expressions. Avoid syntax errors.","title":"Advantage of Query Language"},{"location":"Repository/","text":"Repositories Repositories are associated with an entity and have several methods to interact with the entity. Example: import { orm } from 'lambdaorm' import { ProductRepository } from './models/northwind' (async () => { await orm.init() const productRepository = new ProductRepository('mydb') const country = 'USA' const result = await productRepository.query().filter(p => (p.price > 5 && p.supplier.country === country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) .execute({ country: country }) console.log(JSON.stringify(result, null, 2)) await orm.end() })() method Description insert To insert one record bulkInsert To insert records update To update one record updateAll to be able to update all the records of an entity delete To delete one record deleteAll delete all records of an entity get get one record first returns the first record last returns the last record take returns one record query permite realizar una consulta personalizada The repositories are generated by lambdaorm by executing the update command. When executing this command, among other tasks, a repository is created for each entity of the defined schemas. These files are only generated the first time, so it is safe to add custom methods to these repositories. Example: import { Repository, IOrm } from 'lambdaorm' import { Product, QryProduct } from './model' export class ProductRepository extends Repository<Product, QryProduct> { constructor (database?: string, Orm?:IOrm) { super('Products', database, Orm) } // Add your methods here }","title":"Repository"},{"location":"Repository/#repositories","text":"Repositories are associated with an entity and have several methods to interact with the entity. Example: import { orm } from 'lambdaorm' import { ProductRepository } from './models/northwind' (async () => { await orm.init() const productRepository = new ProductRepository('mydb') const country = 'USA' const result = await productRepository.query().filter(p => (p.price > 5 && p.supplier.country === country) || (p.inStock < 3)) .having(p => max(p.price) > 50) .map(p => ({ category: p.category.name, largestPrice: max(p.price) })) .sort(p => desc(p.largestPrice)) .execute({ country: country }) console.log(JSON.stringify(result, null, 2)) await orm.end() })() method Description insert To insert one record bulkInsert To insert records update To update one record updateAll to be able to update all the records of an entity delete To delete one record deleteAll delete all records of an entity get get one record first returns the first record last returns the last record take returns one record query permite realizar una consulta personalizada The repositories are generated by lambdaorm by executing the update command. When executing this command, among other tasks, a repository is created for each entity of the defined schemas. These files are only generated the first time, so it is safe to add custom methods to these repositories. Example: import { Repository, IOrm } from 'lambdaorm' import { Product, QryProduct } from './model' export class ProductRepository extends Repository<Product, QryProduct> { constructor (database?: string, Orm?:IOrm) { super('Products', database, Orm) } // Add your methods here }","title":"Repositories"},{"location":"Select/","text":"Select All queries are based on the schema from which it deduces the fields that an entity contains, primary key, indexes, relationships and constraints. Therefore, if you want to obtain all the fields of an entity, it is not necessary to specify them. All Fields from entity Selecting all fields from the Products entity Lambda: Products SQL Result: -- SQL query to select all fields from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p One Field Selecting only the 'name' field from the Products entity Lambda: Products.map(p => p.name) SQL Result: -- SQL query to select only the 'ProductName' field from the Products table SELECT p.ProductName FROM Products p First Selecting the first record from the Products entity Lambda: Products.first() SQL Result: -- SQL query to select the first record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p ORDER BY `id` LIMIT 0,1 Last Selecting the last record from the Products entity Lambda: Products.last() SQL Result: -- SQL query to select the last record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p ORDER BY `id` desc LIMIT 0,1 Take Selecting a single record from the Products entity Lambda: Products.take() SQL Result: -- SQL query to select a single record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p LIMIT 0,1 Distinct Selecting distinct values of quantity and category name from the Products entity Lambda: Products .distinct(p => ({ quantity: p.quantity, category: p.category.name })) .sort(p => p.category) SQL Result: -- SQL query to select distinct values of quantity and category name from the Products table SELECT DISTINCT p.QuantityPerUnit AS `quantity`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ORDER BY `category` Pagination Selecting records with price greater than 10, mapping to name and category, sorting by category, and paginating Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) SQL Result: -- Selecci\u00f3n de productos y categor\u00edas por precio unitario -- Selecciona el nombre del producto y categor\u00eda -- Filtra productos con precio superior a ? -- Ordena por categor\u00eda ascendente -- Limita a 10 resultados SELECT p.ProductName AS name, c.CategoryName AS category FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > ? ORDER BY category asc LIMIT 0,10 Usage Node import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts a maximum price parameter // Filtering products based on price greater than the maximum price parameter // Mapping the results to extract name and category // Sorting the results by category // Paginating the results to get the first 10 items const query = (maxPrice:number) => Products .filter(p => p.price > maxPrice) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) const result = await orm.execute(query, {maxPrice:10}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })() CLI lambdaorm execute -q \"Products.filter(p=>p.price>10).map(p=>({name:p.name,category:p.category.name})).sort(p=>p.category).page(1, 10)\" -d \"{\\\"maxPrice\\\":10}\" Service curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Products.filter(p=>p.price>10).map(p=>({name:p.name,category:p.category.name})).sort(p=>p.category).page(1, 10)\", \"data\": \"{\\\"maxPrice\\\":10}\" }'","title":"Select"},{"location":"Select/#select","text":"All queries are based on the schema from which it deduces the fields that an entity contains, primary key, indexes, relationships and constraints. Therefore, if you want to obtain all the fields of an entity, it is not necessary to specify them.","title":"Select"},{"location":"Select/#all-fields-from-entity","text":"Selecting all fields from the Products entity Lambda: Products SQL Result: -- SQL query to select all fields from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p","title":"All Fields from entity"},{"location":"Select/#one-field","text":"Selecting only the 'name' field from the Products entity Lambda: Products.map(p => p.name) SQL Result: -- SQL query to select only the 'ProductName' field from the Products table SELECT p.ProductName FROM Products p","title":"One Field"},{"location":"Select/#first","text":"Selecting the first record from the Products entity Lambda: Products.first() SQL Result: -- SQL query to select the first record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p ORDER BY `id` LIMIT 0,1","title":"First"},{"location":"Select/#last","text":"Selecting the last record from the Products entity Lambda: Products.last() SQL Result: -- SQL query to select the last record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p ORDER BY `id` desc LIMIT 0,1","title":"Last"},{"location":"Select/#take","text":"Selecting a single record from the Products entity Lambda: Products.take() SQL Result: -- SQL query to select a single record from the Products table SELECT p.ProductID AS `id`, p.ProductName AS `name`, p.SupplierID AS `supplierId`, p.CategoryID AS `categoryId`, p.QuantityPerUnit AS `quantity`, p.UnitPrice AS `price`, p.UnitsInStock AS `inStock`, p.UnitsOnOrder AS `onOrder`, p.ReorderLevel AS `reorderLevel`, p.Discontinued AS `discontinued` FROM Products p LIMIT 0,1","title":"Take"},{"location":"Select/#distinct","text":"Selecting distinct values of quantity and category name from the Products entity Lambda: Products .distinct(p => ({ quantity: p.quantity, category: p.category.name })) .sort(p => p.category) SQL Result: -- SQL query to select distinct values of quantity and category name from the Products table SELECT DISTINCT p.QuantityPerUnit AS `quantity`, c.CategoryName AS `category` FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID ORDER BY `category`","title":"Distinct"},{"location":"Select/#pagination","text":"Selecting records with price greater than 10, mapping to name and category, sorting by category, and paginating Lambda: Products .filter(p => p.price > 10) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) SQL Result: -- Selecci\u00f3n de productos y categor\u00edas por precio unitario -- Selecciona el nombre del producto y categor\u00eda -- Filtra productos con precio superior a ? -- Ordena por categor\u00eda ascendente -- Limita a 10 resultados SELECT p.ProductName AS name, c.CategoryName AS category FROM Products p INNER JOIN Categories c ON c.CategoryID = p.CategoryID WHERE p.UnitPrice > ? ORDER BY category asc LIMIT 0,10","title":"Pagination"},{"location":"Select/#usage","text":"","title":"Usage"},{"location":"Select/#node","text":"import { orm } from '../../lib' import { Products } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // Defining a query function that accepts a maximum price parameter // Filtering products based on price greater than the maximum price parameter // Mapping the results to extract name and category // Sorting the results by category // Paginating the results to get the first 10 items const query = (maxPrice:number) => Products .filter(p => p.price > maxPrice) .map(p => ({ name: p.name, category: p.category.name})) .sort(p => p.category) .page(1, 10) const result = await orm.execute(query, {maxPrice:10}) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Node"},{"location":"Select/#cli","text":"lambdaorm execute -q \"Products.filter(p=>p.price>10).map(p=>({name:p.name,category:p.category.name})).sort(p=>p.category).page(1, 10)\" -d \"{\\\"maxPrice\\\":10}\"","title":"CLI"},{"location":"Select/#service","text":"curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Products.filter(p=>p.price>10).map(p=>({name:p.name,category:p.category.name})).sort(p=>p.category).page(1, 10)\", \"data\": \"{\\\"maxPrice\\\":10}\" }'","title":"Service"},{"location":"Transaction/","text":"Transaction To work with transactions use the orm.transaction method. This method receives the name of the database as the first argument and as the second it is a callback function that does not pass a Transaction object, in the example we name it tr. We use the lambda or expression method to execute the sentence (as we found it written). When we reach the end and return the callback, the orm will internally execute the COMMIT, if there is an exception, internally the ROLLBACK will be executed Example: import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { customerId: 'VINET', employeeId: 5, orderDate: '1996-07-03T22:00:00.000Z', requiredDate: '1996-07-31T22:00:00.000Z', shippedDate: '1996-07-15T22:00:00.000Z', shipViaId: 3, freight: 32.38, name: 'Vins et alcools Chevalier', address: '59 rue de l-Abbaye', city: 'Reims', region: null, postalCode: '51100', country: 'France', details: [{ productId: 11, unitPrice: 14, quantity: 12, discount: !1 }, { productId: 42, unitPrice: 9.8, quantity: 10, discount: !1 }, { productId: 72, unitPrice: 34.8, quantity: 5, discount: !1 }] } orm.transaction({ stage: 'source' }, async (tr) => { // create order const orderId = await tr.execute(() => Orders.insert().include(p => p.details), order) // get order const result = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) const order2 = result[0] // updated order order2.address = 'changed 59 rue de l-Abbaye' order2.details[0].discount = true order2.details[1].unitPrice = 10 order2.details[2].quantity = 7 const updateCount = await tr.execute(() => Orders.update().include(p => p.details), order2) console.log(updateCount) // get order const order3 = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) console.log(JSON.stringify(order3)) // delete const deleteCount = await tr.execute(() => Orders.delete().include(p => p.details), order3[0]) console.log(deleteCount) // get order const order4 = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) console.log(JSON.stringify(order4)) }) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Transaction"},{"location":"Transaction/#transaction","text":"To work with transactions use the orm.transaction method. This method receives the name of the database as the first argument and as the second it is a callback function that does not pass a Transaction object, in the example we name it tr. We use the lambda or expression method to execute the sentence (as we found it written). When we reach the end and return the callback, the orm will internally execute the COMMIT, if there is an exception, internally the ROLLBACK will be executed Example: import { orm } from '../../lib' import { Orders } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') const order = { customerId: 'VINET', employeeId: 5, orderDate: '1996-07-03T22:00:00.000Z', requiredDate: '1996-07-31T22:00:00.000Z', shippedDate: '1996-07-15T22:00:00.000Z', shipViaId: 3, freight: 32.38, name: 'Vins et alcools Chevalier', address: '59 rue de l-Abbaye', city: 'Reims', region: null, postalCode: '51100', country: 'France', details: [{ productId: 11, unitPrice: 14, quantity: 12, discount: !1 }, { productId: 42, unitPrice: 9.8, quantity: 10, discount: !1 }, { productId: 72, unitPrice: 34.8, quantity: 5, discount: !1 }] } orm.transaction({ stage: 'source' }, async (tr) => { // create order const orderId = await tr.execute(() => Orders.insert().include(p => p.details), order) // get order const result = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) const order2 = result[0] // updated order order2.address = 'changed 59 rue de l-Abbaye' order2.details[0].discount = true order2.details[1].unitPrice = 10 order2.details[2].quantity = 7 const updateCount = await tr.execute(() => Orders.update().include(p => p.details), order2) console.log(updateCount) // get order const order3 = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) console.log(JSON.stringify(order3)) // delete const deleteCount = await tr.execute(() => Orders.delete().include(p => p.details), order3[0]) console.log(deleteCount) // get order const order4 = await tr.execute((id: number) => Orders.filter(p => p.id === id).include(p => p.details), { id: orderId }) console.log(JSON.stringify(order4)) }) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Transaction"},{"location":"Update/","text":"Update Since the queries are based on both the expression and the definition in the schema, in the case of wanting to update all the fields it is not necessary to define them since it is assumed if none are defined. The mapping to the source(s) is resolved according to the mapping configuration associated with each source in the schema. Update one entity complete Lambda: // Updates all fields of the Orders entity Orders.update() SQL Result: -- Updates all fields of the Orders entity where OrderID matches the provided parameter UPDATE Orders o SET CustomerID = ?, EmployeeID = ?, OrderDate = ?, RequiredDate = ?, ShippedDate = ?, ShipVia = ?, Freight = ?, ShipName = ?, ShipAddress = ?, ShipCity = ?, ShipRegion = ?, ShipPostalCode = ?, ShipCountry = ? WHERE o.OrderID = ? Update one field of entity in all records Lambda: // Updates the ShipPostalCode field in all records of the Orders entity Orders.updateAll({ postalCode: postalCode }) SQL Result: -- Updates the ShipPostalCode field in all records of the Orders entity UPDATE Orders o SET ShipPostalCode = ? Update one field of entity filtered Lambda: // Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID Orders.update({ name: entity.name }).filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ? Update one field of entity filtered and related entity Lambda: // Updates the ShipName field of the Orders entity and updates related details Orders.update({ name: entity.name }).include(p => p.details(p => p)).filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ? -- Updates UnitPrice, Quantity, and Discount fields in the Order Details table where OrderID and ProductID -- match the provided parameters UPDATE `Order Details` o1 SET UnitPrice = o1.UnitPrice,Quantity = o1.Quantity,Discount = o1.Discount WHERE (o1.OrderID = ? AND o1.ProductID = ?) Update one field of entity filtered and fields of related entity Lambda: // Updates the ShipName field of the Orders entity and updates related details' UnitPrice and ProductID Orders.update({ name: entity.name }) .include(p => p.details(p => ({ unitPrice: p.unitPrice, productId: p.productId }))) .filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ? -- Updates UnitPrice and ProductID fields in the Order Details table where OrderID and ProductID -- match the provided parameters UPDATE `Order Details` o1 SET UnitPrice = o1.UnitPrice,ProductID = o1.ProductID WHERE (o1.OrderID = ? AND o1.ProductID = ?) Update entity and multiples related entities Lambda: // Updates all fields of the Customers entity and includes related orders and details Customers.update().include(p => p.orders.include(p => p.details)) SQL Result: -- Updates all fields of the Customers entity where CustomerID matches the provided parameter UPDATE Customers c SET CustomerID = ?,CompanyName = ?,ContactName = ?,ContactTitle = ?,Address = ?,City = ?,Region = ?,PostalCode = ?,Country = ? WHERE c.CustomerID = ? -- Updates all fields of the Orders entity where CustomerID matches the provided parameter UPDATE Orders o SET CustomerID = ?,EmployeeID = ?,OrderDate = ?,RequiredDate = ?,ShippedDate = ?,ShipVia = ?,Freight = ?,ShipName = ?,ShipAddress = ?,ShipCity = ?,ShipRegion = ?,ShipPostalCode = ?,ShipCountry = ? WHERE o.OrderID = ? -- Updates all fields of the Order Details table where OrderID and ProductID match the provided parameters UPDATE `Order Details` o1 SET OrderID = ?,ProductID = ?,UnitPrice = ?,Quantity = ?,Discount = ? WHERE (o1.OrderID = ? AND o1.ProductID = ?) Code example import { orm } from '../../lib' import { Customers } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // entity customer with orders and order details const customer = { id: 'ALFKI', name: 'Alfreds Futterkiste', contact: 'Maria Anders', phone: 'Sales Representative', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', orders: [ { id: 1, customerId: 'ALFKI', employeeId: 6, orderDate: '1997-08-24T22:00:00.000Z', requiredDate: '1997-09-21T22:00:00.000Z', shippedDate: '1997-09-01T22:00:00.000Z', shipViaId: 1, freight: '29.4600', name: 'Alfreds Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 1, productId: 28, unitPrice: '45.6000', quantity: '15.0000', discount: '0.0000' }, { orderId: 1, productId: 39, unitPrice: '18.0000', quantity: '21.0000', discount: '0.0000' }, { orderId: 1, productId: 46, unitPrice: '12.0000', quantity: '2.0000', discount: '0.0000' } ] }, { id: 2, customerId: 'ALFKI', employeeId: 4, orderDate: '1997-10-02T22:00:00.000Z', requiredDate: '1997-10-30T23:00:00.000Z', shippedDate: '1997-10-12T22:00:00.000Z', shipViaId: 2, freight: '61.0200', name: 'Alfred-s Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 2, productId: 63, unitPrice: '43.9000', quantity: '20.0000', discount: '0.0000' } ] } ] } // Defining a query to update Customers and include related orders and details const query = () => Customers.update().include(p => p.orders.include(p => p.details)) // Executing the query using the ORM with the specified customer parameter const result = await orm.execute(query, customer) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Update"},{"location":"Update/#update","text":"Since the queries are based on both the expression and the definition in the schema, in the case of wanting to update all the fields it is not necessary to define them since it is assumed if none are defined. The mapping to the source(s) is resolved according to the mapping configuration associated with each source in the schema.","title":"Update"},{"location":"Update/#update-one-entity-complete","text":"Lambda: // Updates all fields of the Orders entity Orders.update() SQL Result: -- Updates all fields of the Orders entity where OrderID matches the provided parameter UPDATE Orders o SET CustomerID = ?, EmployeeID = ?, OrderDate = ?, RequiredDate = ?, ShippedDate = ?, ShipVia = ?, Freight = ?, ShipName = ?, ShipAddress = ?, ShipCity = ?, ShipRegion = ?, ShipPostalCode = ?, ShipCountry = ? WHERE o.OrderID = ?","title":"Update one entity complete"},{"location":"Update/#update-one-field-of-entity-in-all-records","text":"Lambda: // Updates the ShipPostalCode field in all records of the Orders entity Orders.updateAll({ postalCode: postalCode }) SQL Result: -- Updates the ShipPostalCode field in all records of the Orders entity UPDATE Orders o SET ShipPostalCode = ?","title":"Update one field of entity in all records"},{"location":"Update/#update-one-field-of-entity-filtered","text":"Lambda: // Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID Orders.update({ name: entity.name }).filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ?","title":"Update one field of entity filtered"},{"location":"Update/#update-one-field-of-entity-filtered-and-related-entity","text":"Lambda: // Updates the ShipName field of the Orders entity and updates related details Orders.update({ name: entity.name }).include(p => p.details(p => p)).filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ? -- Updates UnitPrice, Quantity, and Discount fields in the Order Details table where OrderID and ProductID -- match the provided parameters UPDATE `Order Details` o1 SET UnitPrice = o1.UnitPrice,Quantity = o1.Quantity,Discount = o1.Discount WHERE (o1.OrderID = ? AND o1.ProductID = ?)","title":"Update one field of entity filtered and related entity"},{"location":"Update/#update-one-field-of-entity-filtered-and-fields-of-related-entity","text":"Lambda: // Updates the ShipName field of the Orders entity and updates related details' UnitPrice and ProductID Orders.update({ name: entity.name }) .include(p => p.details(p => ({ unitPrice: p.unitPrice, productId: p.productId }))) .filter(p => p.id === entity.id) SQL Result: -- Updates the ShipName field of the Orders entity where OrderID matches the provided entity's ID UPDATE Orders o SET ShipName = ? WHERE o.OrderID = ? -- Updates UnitPrice and ProductID fields in the Order Details table where OrderID and ProductID -- match the provided parameters UPDATE `Order Details` o1 SET UnitPrice = o1.UnitPrice,ProductID = o1.ProductID WHERE (o1.OrderID = ? AND o1.ProductID = ?)","title":"Update one field of entity filtered and fields of related entity"},{"location":"Update/#update-entity-and-multiples-related-entities","text":"Lambda: // Updates all fields of the Customers entity and includes related orders and details Customers.update().include(p => p.orders.include(p => p.details)) SQL Result: -- Updates all fields of the Customers entity where CustomerID matches the provided parameter UPDATE Customers c SET CustomerID = ?,CompanyName = ?,ContactName = ?,ContactTitle = ?,Address = ?,City = ?,Region = ?,PostalCode = ?,Country = ? WHERE c.CustomerID = ? -- Updates all fields of the Orders entity where CustomerID matches the provided parameter UPDATE Orders o SET CustomerID = ?,EmployeeID = ?,OrderDate = ?,RequiredDate = ?,ShippedDate = ?,ShipVia = ?,Freight = ?,ShipName = ?,ShipAddress = ?,ShipCity = ?,ShipRegion = ?,ShipPostalCode = ?,ShipCountry = ? WHERE o.OrderID = ? -- Updates all fields of the Order Details table where OrderID and ProductID match the provided parameters UPDATE `Order Details` o1 SET OrderID = ?,ProductID = ?,UnitPrice = ?,Quantity = ?,Discount = ? WHERE (o1.OrderID = ? AND o1.ProductID = ?)","title":"Update entity and multiples related entities"},{"location":"Update/#code-example","text":"import { orm } from '../../lib' import { Customers } from '../northwind/model/__model' (async () => { try { await orm.init('./config/northwind.yaml') // entity customer with orders and order details const customer = { id: 'ALFKI', name: 'Alfreds Futterkiste', contact: 'Maria Anders', phone: 'Sales Representative', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', orders: [ { id: 1, customerId: 'ALFKI', employeeId: 6, orderDate: '1997-08-24T22:00:00.000Z', requiredDate: '1997-09-21T22:00:00.000Z', shippedDate: '1997-09-01T22:00:00.000Z', shipViaId: 1, freight: '29.4600', name: 'Alfreds Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 1, productId: 28, unitPrice: '45.6000', quantity: '15.0000', discount: '0.0000' }, { orderId: 1, productId: 39, unitPrice: '18.0000', quantity: '21.0000', discount: '0.0000' }, { orderId: 1, productId: 46, unitPrice: '12.0000', quantity: '2.0000', discount: '0.0000' } ] }, { id: 2, customerId: 'ALFKI', employeeId: 4, orderDate: '1997-10-02T22:00:00.000Z', requiredDate: '1997-10-30T23:00:00.000Z', shippedDate: '1997-10-12T22:00:00.000Z', shipViaId: 2, freight: '61.0200', name: 'Alfred-s Futterkiste', address: 'Obere Str. 57', city: 'Berlin', region: null, postalCode: '12209', country: 'Germany', details: [ { orderId: 2, productId: 63, unitPrice: '43.9000', quantity: '20.0000', discount: '0.0000' } ] } ] } // Defining a query to update Customers and include related orders and details const query = () => Customers.update().include(p => p.orders.include(p => p.details)) // Executing the query using the ORM with the specified customer parameter const result = await orm.execute(query, customer) console.log(JSON.stringify(result, null, 2)) } catch (error:any) { console.error(error.stack) } finally { // Ending the ORM connection await orm.end() } })()","title":"Code example"},{"location":"Usage/","text":"To show different ways of consuming the ORM we will propose different cases with an example domain and we will propose different infrastructures. To simplify the schema, we will omit the specification of the properties, keys, indices and relationships of the entities as well as the mapping. But you can see the complete schema in the example labs. Unique Source Schema: In the following schema we define 4 entities in the domain: Categories, Customers, Products and Orders, with Orders being an entity composed of Orders and Order Details. In infrastructure we define a single scenario that is associated with a single data source called Ordering, which is a MySQL database, which uses the default mapping. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default sources: - name: Ordering mapping: default dialect: MySQL connection: ${CNN_MYSQL} stages: - name: default sources: - name: Ordering Query: We will write the query to obtain an Order with its details belonging to a client. We will write the query using lambda expression. import { orm } from 'lambdaorm' import { Orders } from './northwind/domain/model' ( async () => { try { // Initialize the ORM by passing the schema file await orm.init('./lambdaORM.yaml') // Query const query = (customerId:string)=> Orders.filter(p =>p.customerId==customerId) .include(p=>[p.customer.map(p=>p.name),p.details .include(p=>p.product .include(p=>p.category.map(p=>p.name)) .map(p=>p.name)) .map(p=>[p.quantity,p.unitPrice])]) .page(1,1) // Execute the query const result = await orm.execute(query, {customerId: 'CENTC' }) // Print the result console.log(JSON.stringify(result,null,2)) } catch (error: any) { console.error(error) } })() Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000Z\", \"customer\": { \"name\": \"Centro comercial Moctezuma\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 8, \"product\": { \"name\": \"Sir Rodney's Scones\", \"category\": { \"name\": \"Confections\" } } }, { \"quantity\": 1, \"unitPrice\": 20.8, \"product\": { \"name\": \"Gravad lax\", \"category\": { \"name\": \"Seafood\" } } } ] } ] Multiple Sources Schema: In this case we will define a scenario where the domain entities are persisted in different data sources: The Categories, Products entities are persisted in the source Catalog, which is a MySQL database that uses the default mapping. The Customers entity is persisted in the Crm source, which is a PostgreSQL database that uses the default mapping. The Orders entity is persisted in the Ordering source, which is a MongoDB database that uses the mongoDb mapping. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default - name: mongoDb extends: default sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) Query: This time we will execute the query from the command line interface (CLI) and we will obtain the same result as in the previous case. lambdaorm execute -e \".env\" -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000Z\", \"customer\": { \"name\": \"Centro comercial Moctezuma\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 8, \"product\": { \"name\": \"Sir Rodney's Scones\", \"category\": { \"name\": \"Confections\" } } }, { \"quantity\": 1, \"unitPrice\": 20.8, \"product\": { \"name\": \"Gravad lax\", \"category\": { \"name\": \"Seafood\" } } } ] } ] view complete laboratory CQRS (Command Query Responsibility Segregation) Schema: In this case we will define 3 scenarios for the same domain. default: where data is read and written to the Catalog, Crm and Ordering sources. insights: where the data from the Insights source is read and written. cqrs: where data is read from the Insights source but persisted in the Catalog, Crm and Ordering sources. In order to synchronize the data between the Catalog, Crm and Ordering sources with Insights, we will define a listener that will be executed after each insertion, update or deletion of data in the default and cqrs scenario and will apply the same operation in the insights scenario. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default - name: mongoDb extends: default sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights - name: cqrs sources: - name: Insights condition: action == \"select\" - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) Query: In this case we will execute the query from the REST service. curl -X POST \"http://localhost:9291/execute?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\",\"data\":\"{\\\"customerId\\\": \\\"CENTC\\\"}\", \"options\":\"{\\\"stage\\\": \\\"default\\\"}\"}' Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000+02:00\", \"details\": [ { \"subTotal\": 80, \"product\": { \"name\": \"Sir Rodney's Scones\" } }, { \"subTotal\": 20.8, \"product\": { \"name\": \"Gravad lax\" } } ], \"customer\": { \"name\": \"Centro comercial Moctezuma\" } } ] Read Query Plan on Default Stage: When a query is executed in the default stage, data will be obtained from different data sources according to the stage configuration. curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\", \"options\":\"{\\\"default\\\": \\\"cqrs\\\"}\"}' Result: { \"entity\": \"Orders\", \"dialect\": \"MongoDB\", \"source\": \"Ordering\", \"sentence\": \"[{ \\\"$match\\\" : { \\\"CustomerID\\\":{{customerId}} } }, { \\\"$project\\\" :{ \\\"_id\\\": 0 , \\\"id\\\":\\\"$_id\\\", \\\"customerId\\\":\\\"$CustomerID\\\", \\\"orderDate\\\":\\\"$OrderDate\\\", \\\"__id\\\":\\\"$_id\\\", \\\"__customerId\\\":\\\"$CustomerID\\\" ,\\\"details\\\": { \\\"$map\\\":{ \\\"input\\\": \\\"$\\\\\\\"Order Details\\\\\\\"\\\", \\\"in\\\": { \\\"subTotal\\\":{ \\\"$multiply\\\" :[\\\"$$this.Quantity\\\",\\\"$$this.UnitPrice\\\"] }, \\\"__productId\\\":\\\"$$this.ProductID\\\", \\\"LambdaOrmParentId\\\":\\\"$$this.OrderID\\\" } }} }} , { \\\"$sort\\\" :{ \\\"OrderDate\\\":1 } } , { \\\"$skip\\\" : 0 }, { \\\"$limit\\\" : 1 } , { \\\"$project\\\": { \\\"_id\\\": 0 } }]\", \"children\": [ { \"entity\": \"Orders.details\", \"dialect\": \"MongoDB\", \"source\": \"Ordering\", \"children\": [ { \"entity\": \"Products\", \"dialect\": \"MySQL\", \"source\": \"Catalog\", \"sentence\": \"SELECT p.ProductName AS name, p.ProductID AS LambdaOrmParentId FROM Products p WHERE p.ProductID IN (?) \" } ] }, { \"entity\": \"Customers\", \"dialect\": \"PostgreSQL\", \"source\": \"Crm\", \"sentence\": \"SELECT c.CompanyName AS \\\"name\\\", c.CustomerID AS \\\"LambdaOrmParentId\\\" FROM Customers c WHERE c.CustomerID IN ($1) \" } ] } Read Query Plan on CQRS Stage: When you run a query on the cqrs stage, you will get data from a single data source according to the stage configuration. But if the query is for insert, update or delete, it will be executed in the corresponding data source. curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\", \"options\":\"{\\\"stage\\\": \\\"cqrs\\\"}\"}' Result: { \"entity\": \"Orders\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT o.OrderID AS \\\"id\\\", o.CustomerID AS \\\"customerId\\\", o.OrderDate AS \\\"orderDate\\\", o.OrderID AS \\\"__id\\\", o.CustomerID AS \\\"__customerId\\\" FROM Orders o WHERE o.CustomerID = $1 ORDER BY o.OrderDate asc OFFSET 0 LIMIT 1 \", \"children\": [ { \"entity\": \"Orders.details\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT (o1.Quantity * o1.UnitPrice) AS \\\"subTotal\\\", o1.ProductID AS \\\"__productId\\\", o1.OrderID AS \\\"LambdaOrmParentId\\\" FROM \\\"Order Details\\\" o1 WHERE o1.OrderID IN ($1) \", \"children\": [ { \"entity\": \"Products\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT p.ProductName AS \\\"name\\\", p.ProductID AS \\\"LambdaOrmParentId\\\" FROM Products p WHERE p.ProductID IN ($1) \" } ] }, { \"entity\": \"Customers\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT c.CompanyName AS \\\"name\\\", c.CustomerID AS \\\"LambdaOrmParentId\\\" FROM Customers c WHERE c.CustomerID IN ($1) \" } ] } view complete laboratory CQRS (Command Query Responsibility Segregation) with Kafka If we use the ORM from the REST service, we can use Kafka to publish the insert, update and delete data events in the default and cqrs scenario. And configure Kafka consumers to update the data in the insights scenario. Schema: ... infrastructure: ... queue: config: $QUEUE_CONFIG consumers: - name: syncInsights config: groupId: group1 subscribe: topic: insights-sync fromBeginning: true execute: orm.execute(message.query,message.data, {stage:\"insights\"}) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: queue.send(\"insights-sync\",[{query,data}]) view complete laboratory Node Client Schema: In the case of using a rest service client, the schema only defines the domain and the paths in the infrastructure. Since the infrastructure definition is done in the rest service configuration. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: paths: src: src domain: northwind/domain Query: In this case we will use a Node client that will connect to the REST service to execute the query. And in this case we will write the query in string format. import { orm } from 'lambdaorm-client-node' import fs from 'fs' import path from'path' ( async () => { try { await orm.init('http://localhost:9291') // test connection console.log(await orm.general.ping()) // Gets the content of the data.json file to insert the data const content = fs.readFileSync(path.join(__dirname,'../data.json'), 'utf-8') const data = JSON.parse(content) // Import data await orm.stage.import('default',data) // query as string const query = `Orders.filter(p =>p.customerId==customerId) .include(p=>[p.customer.map(p=>p.name),p.details .include(p=>p.product .include(p=>p.category.map(p=>p.name)) .map(p=>p.name)) .map(p=>[p.quantity,p.unitPrice])])` // get plan const plan = await orm.plan(query, { stage: 'default'}) console.log(JSON.stringify(plan,null,2)) // execute query const result = await orm.execute(query, {customerId: 'CENTC' },{ stage: 'default'}) console.log(JSON.stringify(result,null,2)) } catch (error: any) { console.error(error) } finally { await orm.end() } })() Considerations view complete laboratory Keep in mind that whether we use the \"lambdaorm\" or \"lambdaorm-client-node\" library we can write the queries in lambda or string format. We could start a development by proposing a simple infrastructure and then make modifications to it and this would not affect our code, since the queries are written based on the domain model and are independent of the infrastructure. You could also have development, test and production environments with different infrastructure configurations without having to alter the code. In addition to the examples presented previously, there are many other use cases that can be solved with \u03bbORM by configuring the schema and queries language. Therefore, we invite you to explore the different laboratories and read the documentation .","title":"Usage"},{"location":"Usage/#unique-source","text":"Schema: In the following schema we define 4 entities in the domain: Categories, Customers, Products and Orders, with Orders being an entity composed of Orders and Order Details. In infrastructure we define a single scenario that is associated with a single data source called Ordering, which is a MySQL database, which uses the default mapping. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default sources: - name: Ordering mapping: default dialect: MySQL connection: ${CNN_MYSQL} stages: - name: default sources: - name: Ordering Query: We will write the query to obtain an Order with its details belonging to a client. We will write the query using lambda expression. import { orm } from 'lambdaorm' import { Orders } from './northwind/domain/model' ( async () => { try { // Initialize the ORM by passing the schema file await orm.init('./lambdaORM.yaml') // Query const query = (customerId:string)=> Orders.filter(p =>p.customerId==customerId) .include(p=>[p.customer.map(p=>p.name),p.details .include(p=>p.product .include(p=>p.category.map(p=>p.name)) .map(p=>p.name)) .map(p=>[p.quantity,p.unitPrice])]) .page(1,1) // Execute the query const result = await orm.execute(query, {customerId: 'CENTC' }) // Print the result console.log(JSON.stringify(result,null,2)) } catch (error: any) { console.error(error) } })() Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000Z\", \"customer\": { \"name\": \"Centro comercial Moctezuma\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 8, \"product\": { \"name\": \"Sir Rodney's Scones\", \"category\": { \"name\": \"Confections\" } } }, { \"quantity\": 1, \"unitPrice\": 20.8, \"product\": { \"name\": \"Gravad lax\", \"category\": { \"name\": \"Seafood\" } } } ] } ]","title":"Unique Source"},{"location":"Usage/#multiple-sources","text":"Schema: In this case we will define a scenario where the domain entities are persisted in different data sources: The Categories, Products entities are persisted in the source Catalog, which is a MySQL database that uses the default mapping. The Customers entity is persisted in the Crm source, which is a PostgreSQL database that uses the default mapping. The Orders entity is persisted in the Ordering source, which is a MongoDB database that uses the mongoDb mapping. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default - name: mongoDb extends: default sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) Query: This time we will execute the query from the command line interface (CLI) and we will obtain the same result as in the previous case. lambdaorm execute -e \".env\" -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000Z\", \"customer\": { \"name\": \"Centro comercial Moctezuma\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 8, \"product\": { \"name\": \"Sir Rodney's Scones\", \"category\": { \"name\": \"Confections\" } } }, { \"quantity\": 1, \"unitPrice\": 20.8, \"product\": { \"name\": \"Gravad lax\", \"category\": { \"name\": \"Seafood\" } } } ] } ] view complete laboratory","title":"Multiple Sources"},{"location":"Usage/#cqrs-command-query-responsibility-segregation","text":"Schema: In this case we will define 3 scenarios for the same domain. default: where data is read and written to the Catalog, Crm and Ordering sources. insights: where the data from the Insights source is read and written. cqrs: where data is read from the Insights source but persisted in the Catalog, Crm and Ordering sources. In order to synchronize the data between the Catalog, Crm and Ordering sources with Insights, we will define a listener that will be executed after each insertion, update or deletion of data in the default and cqrs scenario and will apply the same operation in the insights scenario. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: mappings: - name: default - name: mongoDb extends: default sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights - name: cqrs sources: - name: Insights condition: action == \"select\" - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) Query: In this case we will execute the query from the REST service. curl -X POST \"http://localhost:9291/execute?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\",\"data\":\"{\\\"customerId\\\": \\\"CENTC\\\"}\", \"options\":\"{\\\"stage\\\": \\\"default\\\"}\"}' Result: [ { \"id\": 12, \"customerId\": \"CENTC\", \"orderDate\": \"1996-07-18T00:00:00.000+02:00\", \"details\": [ { \"subTotal\": 80, \"product\": { \"name\": \"Sir Rodney's Scones\" } }, { \"subTotal\": 20.8, \"product\": { \"name\": \"Gravad lax\" } } ], \"customer\": { \"name\": \"Centro comercial Moctezuma\" } } ] Read Query Plan on Default Stage: When a query is executed in the default stage, data will be obtained from different data sources according to the stage configuration. curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\", \"options\":\"{\\\"default\\\": \\\"cqrs\\\"}\"}' Result: { \"entity\": \"Orders\", \"dialect\": \"MongoDB\", \"source\": \"Ordering\", \"sentence\": \"[{ \\\"$match\\\" : { \\\"CustomerID\\\":{{customerId}} } }, { \\\"$project\\\" :{ \\\"_id\\\": 0 , \\\"id\\\":\\\"$_id\\\", \\\"customerId\\\":\\\"$CustomerID\\\", \\\"orderDate\\\":\\\"$OrderDate\\\", \\\"__id\\\":\\\"$_id\\\", \\\"__customerId\\\":\\\"$CustomerID\\\" ,\\\"details\\\": { \\\"$map\\\":{ \\\"input\\\": \\\"$\\\\\\\"Order Details\\\\\\\"\\\", \\\"in\\\": { \\\"subTotal\\\":{ \\\"$multiply\\\" :[\\\"$$this.Quantity\\\",\\\"$$this.UnitPrice\\\"] }, \\\"__productId\\\":\\\"$$this.ProductID\\\", \\\"LambdaOrmParentId\\\":\\\"$$this.OrderID\\\" } }} }} , { \\\"$sort\\\" :{ \\\"OrderDate\\\":1 } } , { \\\"$skip\\\" : 0 }, { \\\"$limit\\\" : 1 } , { \\\"$project\\\": { \\\"_id\\\": 0 } }]\", \"children\": [ { \"entity\": \"Orders.details\", \"dialect\": \"MongoDB\", \"source\": \"Ordering\", \"children\": [ { \"entity\": \"Products\", \"dialect\": \"MySQL\", \"source\": \"Catalog\", \"sentence\": \"SELECT p.ProductName AS name, p.ProductID AS LambdaOrmParentId FROM Products p WHERE p.ProductID IN (?) \" } ] }, { \"entity\": \"Customers\", \"dialect\": \"PostgreSQL\", \"source\": \"Crm\", \"sentence\": \"SELECT c.CompanyName AS \\\"name\\\", c.CustomerID AS \\\"LambdaOrmParentId\\\" FROM Customers c WHERE c.CustomerID IN ($1) \" } ] } Read Query Plan on CQRS Stage: When you run a query on the cqrs stage, you will get data from a single data source according to the stage configuration. But if the query is for insert, update or delete, it will be executed in the corresponding data source. curl -X POST \"http://localhost:9291/plan?format=beautiful\" -H \"Content-Type: application/json\" -d '{\"query\": \"Orders.filter(p=>p.customerId==customerId).include(p=>[p.details.include(p=>p.product.map(p=>p.name)).map(p=>{subTotal:p.quantity*p.unitPrice}),p.customer.map(p=>p.name)]).order(p=>p.orderDate).page(1,1)\", \"options\":\"{\\\"stage\\\": \\\"cqrs\\\"}\"}' Result: { \"entity\": \"Orders\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT o.OrderID AS \\\"id\\\", o.CustomerID AS \\\"customerId\\\", o.OrderDate AS \\\"orderDate\\\", o.OrderID AS \\\"__id\\\", o.CustomerID AS \\\"__customerId\\\" FROM Orders o WHERE o.CustomerID = $1 ORDER BY o.OrderDate asc OFFSET 0 LIMIT 1 \", \"children\": [ { \"entity\": \"Orders.details\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT (o1.Quantity * o1.UnitPrice) AS \\\"subTotal\\\", o1.ProductID AS \\\"__productId\\\", o1.OrderID AS \\\"LambdaOrmParentId\\\" FROM \\\"Order Details\\\" o1 WHERE o1.OrderID IN ($1) \", \"children\": [ { \"entity\": \"Products\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT p.ProductName AS \\\"name\\\", p.ProductID AS \\\"LambdaOrmParentId\\\" FROM Products p WHERE p.ProductID IN ($1) \" } ] }, { \"entity\": \"Customers\", \"dialect\": \"PostgreSQL\", \"source\": \"Insights\", \"sentence\": \"SELECT c.CompanyName AS \\\"name\\\", c.CustomerID AS \\\"LambdaOrmParentId\\\" FROM Customers c WHERE c.CustomerID IN ($1) \" } ] } view complete laboratory","title":"CQRS (Command Query Responsibility Segregation)"},{"location":"Usage/#cqrs-command-query-responsibility-segregation-with-kafka","text":"If we use the ORM from the REST service, we can use Kafka to publish the insert, update and delete data events in the default and cqrs scenario. And configure Kafka consumers to update the data in the insights scenario. Schema: ... infrastructure: ... queue: config: $QUEUE_CONFIG consumers: - name: syncInsights config: groupId: group1 subscribe: topic: insights-sync fromBeginning: true execute: orm.execute(message.query,message.data, {stage:\"insights\"}) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: queue.send(\"insights-sync\",[{query,data}]) view complete laboratory","title":"CQRS (Command Query Responsibility Segregation) with Kafka"},{"location":"Usage/#node-client","text":"Schema: In the case of using a rest service client, the schema only defines the domain and the paths in the infrastructure. Since the infrastructure definition is done in the rest service configuration. domain: entities: - name: Categories - name: Customers - name: Products - name: Orders - name: Orders.details infrastructure: paths: src: src domain: northwind/domain Query: In this case we will use a Node client that will connect to the REST service to execute the query. And in this case we will write the query in string format. import { orm } from 'lambdaorm-client-node' import fs from 'fs' import path from'path' ( async () => { try { await orm.init('http://localhost:9291') // test connection console.log(await orm.general.ping()) // Gets the content of the data.json file to insert the data const content = fs.readFileSync(path.join(__dirname,'../data.json'), 'utf-8') const data = JSON.parse(content) // Import data await orm.stage.import('default',data) // query as string const query = `Orders.filter(p =>p.customerId==customerId) .include(p=>[p.customer.map(p=>p.name),p.details .include(p=>p.product .include(p=>p.category.map(p=>p.name)) .map(p=>p.name)) .map(p=>[p.quantity,p.unitPrice])])` // get plan const plan = await orm.plan(query, { stage: 'default'}) console.log(JSON.stringify(plan,null,2)) // execute query const result = await orm.execute(query, {customerId: 'CENTC' },{ stage: 'default'}) console.log(JSON.stringify(result,null,2)) } catch (error: any) { console.error(error) } finally { await orm.end() } })()","title":"Node Client"},{"location":"Usage/#considerations","text":"view complete laboratory Keep in mind that whether we use the \"lambdaorm\" or \"lambdaorm-client-node\" library we can write the queries in lambda or string format. We could start a development by proposing a simple infrastructure and then make modifications to it and this would not affect our code, since the queries are written based on the domain model and are independent of the infrastructure. You could also have development, test and production environments with different infrastructure configurations without having to alter the code. In addition to the examples presented previously, there are many other use cases that can be solved with \u03bbORM by configuring the schema and queries language. Therefore, we invite you to explore the different laboratories and read the documentation .","title":"Considerations"},{"location":"_Sidebar/","text":"[[Home]] [[Usage]] [[Features]] Labs [[Queries|Query-Language]] [[Expression]] DQL [[Select]] [[Join]] [[Grouping]] [[Include]] DML [[Insert]] [[BulkInsert]] [[Update]] [[Delete]] Operators & Functions [[Bitwise]] [[Comparison]] [[Datetime]] [[Group]] [[Logical]] [[Nullable]] [[Numeric]] [[Sort]] [[String]] [[Repository]] [[Transaction]] [[Metadata]] [[Schema]] [[Definition|SchemaDefinition]] [[Expressions|SchemaDefinition-Expressions]] [[Environment Variables|SchemaDefinition-EnvironmentVariables]] [[Composite|SchemaDefinition-Composite]] [[Listeners|SchemaExample-Listener]] [[Basic|SchemaExample-Basic]] [[Extend Entity|SchemaExample-Extend]] [[Multiples Stages|SchemaExample-MultiplesStages]] [[Stage with Multiples Sources|SchemaExample-StageMultiplesSources]] [[Entity Composite|SchemaExample-Composite]] [[Synchronization|SchemaSynchronization]] [[Push|SchemaSynchronization-Push]] [[Pull|SchemaSynchronization-Pull]] [[Fetch|SchemaSynchronization-Fetch]] [[Introspect|SchemaSynchronization-Introspect]] [[Incorporate|SchemaSynchronization-Incorporate]] [[Use|Schema-Use]] Related Projects 3xpr Lambda ORM CLI Lambda ORM Service Client Node Client Kotlin Source Code Documentation Change log","title":" Sidebar"},{"location":"function_functions/","text":"Function Description sleep Sleeps for the specified number of milliseconds console Prints to console between Between includes Includes in In like String contains pattern isNull Check if value is null isNotNull Check if value is not null isEmpty Check if value is empty isNotEmpty Check if value is not empty isBoolean Check if value is boolean isNumber Check if value is number isInteger Check if value is integer isDecimal Check if value is decimal isString Check if value is string isDate Check if value is date isDateTime Check if value is date time isTime Check if value is time isObject Check if value is object isArray Check if value is array isBooleanFormat Check if value is boolean format isNumberFormat Check if value is number format isIntegerFormat Check if value is integer format isDecimalFormat Check if value is decimal format isDateFormat Check if value is date format isDateTimeFormat Check if value is date time format isTimeFormat Check if value is time format nvl Null value nvl2 Null value abs Absolute value acos Arc cosine asin Arc sine atan Arc tangent atan2 Arc tangent of two variables ceil Ceiling cos Cosine cosh Hyperbolic cosine exp Exponential floor Floor ln Natural logarithm log10 Base 10 logarithm log Natural logarithm remainder Remainder round Round sign Sign sin Sine sinh Hyperbolic sine tan Tangent tanh Hyperbolic tangent trunc Truncate chr Character capitalize Capitalize endsWith Ends with strCount Count lower Lower case lpad Left pad ltrim Left trim indexOf Index of join Join replace Replace rpad Right pad rtrim Right trim substring Substring trim Trim upper Upper case concat Concatenate test Test title Title case match Match mask Mask sensitive data split Split string startWith Starts with map Map foreach Foreach filter Filter reverse Reverse sort Sort remove Remove push Push bulkInsert Bulk Insert pop Pop length Length slice Slice page Paging distinct Distinct first First last Last count Count max Max min Min avg Average sum Sum curTime Current time today Current date now Current date time time Get time date Get date dateTime Get date time year Get year month Get month day Get day weekday Get day of week hour Get hours minute Get minutes second Get seconds millisecond Get milliseconds addYear Add years addMonth Add months addDay Add days addHour Add hours addMinute Add minutes addSecond Add seconds addMillisecond Add milliseconds addTime Add time subtractTime Subtract time yearDiff Year difference dayDiff Day difference hourDiff Hour difference secondDiff Second difference millisecondDiff Millisecond difference dayToDate Convert days to date time hourToDate Convert hours to date time secondToDate Convert seconds to date time millisecondToDate Convert milliseconds to date time toString Convert to string toNumber Convert to number dateToString Convert date to string stringify Convert to JSON string parse Parse JSON string keys Object keys values Object values entries Object entries fromEntries Object from entries union Union intersection Intersection difference Difference symmetricDifference Symmetric Difference toBase64 Convert a string to base64 getBase64 Get a string from base64 encrypt Encrypt a string decrypt Decrypt a string update Update a list updateAll Update all items in a list deleteAll Delete all items in a list merge Merge a list bulkMerge Bulk merge a list having Having a list include Include a list desc Descending asc Ascending orm.execute Execute query orm.plan Plan of query orm.metadata Get metadata from query orm.model Get model from query orm.parameters Get parameters from query orm.constraints Get constraints from query contains Includes substr Substring concatenate Concatenate startsWith Starts with select Map each Foreach where Filter order Sort delete Remove insert Push len Length Definition sleep description: Sleeps for the specified number of milliseconds deterministic: true return: void params: ms?: number console description: Prints to console deterministic: true return: void params: value: any between description: Between deterministic: true return: boolean params: value: T from: T to: T includes description: Includes deterministic: true return: boolean params: source: string|T[] value: string|T in description: In deterministic: true return: boolean params: source: T values: T like description: String contains pattern deterministic: true return: boolean params: value: string pattern: string isNull description: Check if value is null deterministic: true return: boolean params: value: any isNotNull description: Check if value is not null deterministic: true return: boolean params: value: any isEmpty description: Check if value is empty deterministic: true return: boolean params: value: string isNotEmpty description: Check if value is not empty deterministic: true return: boolean params: value: string isBoolean description: Check if value is boolean deterministic: true return: boolean params: value: any isNumber description: Check if value is number deterministic: true return: boolean params: value: any isInteger description: Check if value is integer deterministic: true return: boolean params: value: any isDecimal description: Check if value is decimal deterministic: true return: boolean params: value: any isString description: Check if value is string deterministic: true return: boolean params: value: any isDate description: Check if value is date deterministic: true return: boolean params: value: any isDateTime description: Check if value is date time deterministic: true return: boolean params: value: any isTime description: Check if value is time deterministic: true return: boolean params: value: any isObject description: Check if value is object deterministic: true return: boolean params: value: any isArray description: Check if value is array deterministic: true return: boolean params: value: any isBooleanFormat description: Check if value is boolean format deterministic: true return: boolean params: value: string isNumberFormat description: Check if value is number format deterministic: true return: boolean params: value: string isIntegerFormat description: Check if value is integer format deterministic: true return: boolean params: value: string isDecimalFormat description: Check if value is decimal format deterministic: true return: boolean params: value: string isDateFormat description: Check if value is date format deterministic: true return: boolean params: value: string isDateTimeFormat description: Check if value is date time format deterministic: true return: boolean params: value: string isTimeFormat description: Check if value is time format deterministic: true return: boolean params: value: string nvl description: Null value deterministic: true return: T params: value: T default: T nvl2 description: Null value deterministic: true return: T params: value: any a: T b: T abs description: Absolute value deterministic: true return: number params: x: number acos description: Arc cosine deterministic: true return: number params: x: number asin description: Arc sine deterministic: true return: number params: x: number atan description: Arc tangent deterministic: true return: number params: x: number atan2 description: Arc tangent of two variables deterministic: true return: number params: x: number ceil description: Ceiling deterministic: true return: number params: x: number cos description: Cosine deterministic: true return: number params: x: number cosh description: Hyperbolic cosine deterministic: true return: number params: x: number exp description: Exponential deterministic: true return: number params: x: number floor description: Floor deterministic: true return: number params: x: number ln description: Natural logarithm deterministic: true return: number params: x: number log10 description: Base 10 logarithm deterministic: true return: number params: x: number log description: Natural logarithm deterministic: true return: number params: x: number remainder description: Remainder deterministic: true return: number params: n1: number n2: number round description: Round deterministic: true return: number params: num: number decimals: 0 sign description: Sign deterministic: true return: number params: x: number sin description: Sine deterministic: true return: number params: x: number sinh description: Hyperbolic sine deterministic: true return: number params: x: number tan description: Tangent deterministic: true return: number params: x: number tanh description: Hyperbolic tangent deterministic: true return: number params: x: number trunc description: Truncate deterministic: true return: number params: x: number chr description: Character deterministic: true return: string params: ascii: number capitalize description: Capitalize deterministic: true return: string params: value: string endsWith description: Ends with deterministic: true return: boolean params: value: string sub: string start: number strCount description: Count deterministic: true return: number params: source: string value: string lower description: Lower case deterministic: true return: string params: value: string lpad description: Left pad deterministic: true return: string params: value: string len: number pad: string ltrim description: Left trim deterministic: true return: string params: value: string indexOf description: Index of deterministic: true return: number params: value: string sub: string start: number join description: Join deterministic: true return: string params: values: string[] separator: string : \" replace description: Replace deterministic: true return: string params: value: string source: string target: string rpad description: Right pad deterministic: true return: string params: value: string len: number pad: string rtrim description: Right trim deterministic: true return: string params: value: string substring description: Substring deterministic: true return: string params: value: string from: number count: number trim description: Trim deterministic: true return: string params: value: string upper description: Upper case deterministic: true return: string params: value: string concat description: Concatenate deterministic: true return: string params: values: any test description: Test deterministic: true return: boolean params: value: string regexp: string title description: Title case deterministic: true return: string params: value: string match description: Match deterministic: true return: any params: value: string regexp: string mask description: Mask sensitive data deterministic: true return: string params: value: string split description: Split string deterministic: true return: string[] params: value: string separator: string : \" startWith description: Starts with deterministic: true return: boolean params: value: string sub: string start: number map description: Map deterministic: true return: T[] params: list: any[] predicate: T foreach description: Foreach deterministic: true return: void params: list: any[] predicate: any filter description: Filter deterministic: true return: T[] params: list: T[] predicate: boolean reverse description: Reverse deterministic: true return: T[] params: list: T[] predicate: any sort description: Sort deterministic: true return: T[] params: list: T[] predicate: any remove description: Remove deterministic: true return: T[] params: list: T[] predicate: boolean push description: Push deterministic: true return: T[] params: list: T[] value: T bulkInsert description: Bulk Insert deterministic: true return: T[] params: list: T[] value: T[] pop description: Pop deterministic: true return: T params: list: T[] length description: Length deterministic: true return: number params: source: any[]|string slice description: Slice deterministic: true return: T[] params: list: T[] from: integer to: integer page description: Paging deterministic: true return: T[] params: list: T[] page: integer records: integer distinct description: Distinct deterministic: true return: any[] params: list: any[] predicate: any first description: First deterministic: true return: T params: list: T[] predicate: boolean last description: Last deterministic: true return: T params: list: T[] predicate: boolean count description: Count deterministic: true return: integer params: list: T[] predicate: boolean max description: Max deterministic: true return: T params: list: T[] predicate: boolean min description: Min deterministic: true return: T params: list: T[] predicate: boolean avg description: Average deterministic: true return: number params: list: T[] value: number sum description: Sum deterministic: true return: number params: list: T[] value: number curTime description: Current time deterministic: true return: time params: : any today description: Current date deterministic: true return: date params: : any now description: Current date time deterministic: true return: dateTime params: : any time description: Get time deterministic: true return: time params: value: string date description: Get date deterministic: true return: date params: value: string dateTime description: Get date time deterministic: true return: dateTime params: value: string year description: Get year deterministic: true return: integer params: value: dateTime month description: Get month deterministic: true return: integer params: value: dateTime day description: Get day deterministic: true return: integer params: value: dateTime weekday description: Get day of week deterministic: true return: integer params: value: dateTime hour description: Get hours deterministic: true return: integer params: value: dateTime minute description: Get minutes deterministic: true return: integer params: value: dateTime second description: Get seconds deterministic: true return: integer params: value: dateTime millisecond description: Get milliseconds deterministic: true return: integer params: value: dateTime addYear description: Add years deterministic: true return: dateTime params: date: dateTime value: number addMonth description: Add months deterministic: true return: dateTime params: date: dateTime value: number addDay description: Add days deterministic: true return: dateTime params: date: dateTime value: number addHour description: Add hours deterministic: true return: dateTime params: date: dateTime value: number addMinute description: Add minutes deterministic: true return: dateTime params: date: dateTime value: number addSecond description: Add seconds deterministic: true return: dateTime params: date: dateTime value: number addMillisecond description: Add milliseconds deterministic: true return: dateTime params: date: dateTime value: number addTime description: Add time deterministic: true return: dateTime params: date: dateTime time: time subtractTime description: Subtract time deterministic: true return: dateTime params: date: dateTime time: time yearDiff description: Year difference deterministic: true return: integer params: date1: dateTime date2: dateTime dayDiff description: Day difference deterministic: true return: integer params: date1: dateTime date2: dateTime hourDiff description: Hour difference deterministic: true return: integer params: date1: dateTime date2: dateTime secondDiff description: Second difference deterministic: true return: integer params: date1: dateTime date2: dateTime millisecondDiff description: Millisecond difference deterministic: true return: integer params: date1: dateTime date2: dateTime dayToDate description: Convert days to date time deterministic: true return: dateTime params: value: number hourToDate description: Convert hours to date time deterministic: true return: dateTime params: value: number secondToDate description: Convert seconds to date time deterministic: true return: dateTime params: value: number millisecondToDate description: Convert milliseconds to date time deterministic: true return: dateTime params: value: number toString description: Convert to string deterministic: true return: string params: value: any toNumber description: Convert to number deterministic: true return: number params: value: any dateToString description: Convert date to string deterministic: true return: string params: date: date stringify description: Convert to JSON string deterministic: true return: string params: value: any parse description: Parse JSON string deterministic: true return: any params: value: string keys description: Object keys deterministic: true return: string[] params: obj: any values description: Object values deterministic: true return: any[] params: obj: any entries description: Object entries deterministic: true return: [string,any][] params: obj: any fromEntries description: Object from entries deterministic: true return: any params: entries: [string : any][] union description: Union deterministic: true return: T[] params: a: T[] b: T[] intersection description: Intersection deterministic: true return: T[] params: a: T[] b: T[] difference description: Difference deterministic: true return: T[] params: a: T[] b: T[] symmetricDifference description: Symmetric Difference deterministic: true return: T[] params: a: T[] b: T[] toBase64 description: Convert a string to base64 deterministic: true return: string params: value: string getBase64 description: Get a string from base64 deterministic: true return: string params: value: string encrypt description: Encrypt a string deterministic: true return: string params: value: string decrypt description: Decrypt a string deterministic: true return: string params: value: string update description: Update a list deterministic: true return: any params: list: any[] predicate: any updateAll description: Update all items in a list deterministic: true return: any params: list: any[] predicate: any deleteAll description: Delete all items in a list deterministic: true return: any params: list: any[] merge description: Merge a list deterministic: true return: any params: list: any[] predicate: any bulkMerge description: Bulk merge a list deterministic: true return: any params: list: any[] predicate: any having description: Having a list deterministic: true return: T[] params: list: T[] predicate: boolean include description: Include a list deterministic: true return: any params: list: any[] predicate: any desc description: Descending deterministic: true return: void params: value: any asc description: Ascending deterministic: true return: void params: value: any orm.execute description: Execute query deterministic: true return: any params: query: string data: any options: any orm.plan description: Plan of query deterministic: true return: any params: query: string options: any orm.metadata description: Get metadata from query deterministic: true return: any params: query: string orm.model description: Get model from query deterministic: true return: any params: query: string orm.parameters description: Get parameters from query deterministic: true return: any params: query: string orm.constraints description: Get constraints from query deterministic: true return: any params: query: string contains description: Includes deterministic: true return: boolean params: source: string|T[] value: string|T substr description: Substring deterministic: true return: string params: value: string from: number count: number concatenate description: Concatenate deterministic: true return: string params: values: any startsWith description: Starts with deterministic: true return: boolean params: value: string sub: string start: number select description: Map deterministic: true return: T[] params: list: any[] predicate: T each description: Foreach deterministic: true return: void params: list: any[] predicate: any where description: Filter deterministic: true return: T[] params: list: T[] predicate: boolean order description: Sort deterministic: true return: T[] params: list: T[] predicate: any delete description: Remove deterministic: true return: T[] params: list: T[] predicate: boolean insert description: Push deterministic: true return: T[] params: list: T[] value: T len description: Length deterministic: true return: number params: source: any[]|string","title":"Function functions"},{"location":"function_functions/#definition","text":"","title":"Definition"},{"location":"function_functions/#sleep","text":"description: Sleeps for the specified number of milliseconds deterministic: true return: void params: ms?: number","title":"sleep"},{"location":"function_functions/#console","text":"description: Prints to console deterministic: true return: void params: value: any","title":"console"},{"location":"function_functions/#between","text":"description: Between deterministic: true return: boolean params: value: T from: T to: T","title":"between"},{"location":"function_functions/#includes","text":"description: Includes deterministic: true return: boolean params: source: string|T[] value: string|T","title":"includes"},{"location":"function_functions/#in","text":"description: In deterministic: true return: boolean params: source: T values: T","title":"in"},{"location":"function_functions/#like","text":"description: String contains pattern deterministic: true return: boolean params: value: string pattern: string","title":"like"},{"location":"function_functions/#isnull","text":"description: Check if value is null deterministic: true return: boolean params: value: any","title":"isNull"},{"location":"function_functions/#isnotnull","text":"description: Check if value is not null deterministic: true return: boolean params: value: any","title":"isNotNull"},{"location":"function_functions/#isempty","text":"description: Check if value is empty deterministic: true return: boolean params: value: string","title":"isEmpty"},{"location":"function_functions/#isnotempty","text":"description: Check if value is not empty deterministic: true return: boolean params: value: string","title":"isNotEmpty"},{"location":"function_functions/#isboolean","text":"description: Check if value is boolean deterministic: true return: boolean params: value: any","title":"isBoolean"},{"location":"function_functions/#isnumber","text":"description: Check if value is number deterministic: true return: boolean params: value: any","title":"isNumber"},{"location":"function_functions/#isinteger","text":"description: Check if value is integer deterministic: true return: boolean params: value: any","title":"isInteger"},{"location":"function_functions/#isdecimal","text":"description: Check if value is decimal deterministic: true return: boolean params: value: any","title":"isDecimal"},{"location":"function_functions/#isstring","text":"description: Check if value is string deterministic: true return: boolean params: value: any","title":"isString"},{"location":"function_functions/#isdate","text":"description: Check if value is date deterministic: true return: boolean params: value: any","title":"isDate"},{"location":"function_functions/#isdatetime","text":"description: Check if value is date time deterministic: true return: boolean params: value: any","title":"isDateTime"},{"location":"function_functions/#istime","text":"description: Check if value is time deterministic: true return: boolean params: value: any","title":"isTime"},{"location":"function_functions/#isobject","text":"description: Check if value is object deterministic: true return: boolean params: value: any","title":"isObject"},{"location":"function_functions/#isarray","text":"description: Check if value is array deterministic: true return: boolean params: value: any","title":"isArray"},{"location":"function_functions/#isbooleanformat","text":"description: Check if value is boolean format deterministic: true return: boolean params: value: string","title":"isBooleanFormat"},{"location":"function_functions/#isnumberformat","text":"description: Check if value is number format deterministic: true return: boolean params: value: string","title":"isNumberFormat"},{"location":"function_functions/#isintegerformat","text":"description: Check if value is integer format deterministic: true return: boolean params: value: string","title":"isIntegerFormat"},{"location":"function_functions/#isdecimalformat","text":"description: Check if value is decimal format deterministic: true return: boolean params: value: string","title":"isDecimalFormat"},{"location":"function_functions/#isdateformat","text":"description: Check if value is date format deterministic: true return: boolean params: value: string","title":"isDateFormat"},{"location":"function_functions/#isdatetimeformat","text":"description: Check if value is date time format deterministic: true return: boolean params: value: string","title":"isDateTimeFormat"},{"location":"function_functions/#istimeformat","text":"description: Check if value is time format deterministic: true return: boolean params: value: string","title":"isTimeFormat"},{"location":"function_functions/#nvl","text":"description: Null value deterministic: true return: T params: value: T default: T","title":"nvl"},{"location":"function_functions/#nvl2","text":"description: Null value deterministic: true return: T params: value: any a: T b: T","title":"nvl2"},{"location":"function_functions/#abs","text":"description: Absolute value deterministic: true return: number params: x: number","title":"abs"},{"location":"function_functions/#acos","text":"description: Arc cosine deterministic: true return: number params: x: number","title":"acos"},{"location":"function_functions/#asin","text":"description: Arc sine deterministic: true return: number params: x: number","title":"asin"},{"location":"function_functions/#atan","text":"description: Arc tangent deterministic: true return: number params: x: number","title":"atan"},{"location":"function_functions/#atan2","text":"description: Arc tangent of two variables deterministic: true return: number params: x: number","title":"atan2"},{"location":"function_functions/#ceil","text":"description: Ceiling deterministic: true return: number params: x: number","title":"ceil"},{"location":"function_functions/#cos","text":"description: Cosine deterministic: true return: number params: x: number","title":"cos"},{"location":"function_functions/#cosh","text":"description: Hyperbolic cosine deterministic: true return: number params: x: number","title":"cosh"},{"location":"function_functions/#exp","text":"description: Exponential deterministic: true return: number params: x: number","title":"exp"},{"location":"function_functions/#floor","text":"description: Floor deterministic: true return: number params: x: number","title":"floor"},{"location":"function_functions/#ln","text":"description: Natural logarithm deterministic: true return: number params: x: number","title":"ln"},{"location":"function_functions/#log10","text":"description: Base 10 logarithm deterministic: true return: number params: x: number","title":"log10"},{"location":"function_functions/#log","text":"description: Natural logarithm deterministic: true return: number params: x: number","title":"log"},{"location":"function_functions/#remainder","text":"description: Remainder deterministic: true return: number params: n1: number n2: number","title":"remainder"},{"location":"function_functions/#round","text":"description: Round deterministic: true return: number params: num: number decimals: 0","title":"round"},{"location":"function_functions/#sign","text":"description: Sign deterministic: true return: number params: x: number","title":"sign"},{"location":"function_functions/#sin","text":"description: Sine deterministic: true return: number params: x: number","title":"sin"},{"location":"function_functions/#sinh","text":"description: Hyperbolic sine deterministic: true return: number params: x: number","title":"sinh"},{"location":"function_functions/#tan","text":"description: Tangent deterministic: true return: number params: x: number","title":"tan"},{"location":"function_functions/#tanh","text":"description: Hyperbolic tangent deterministic: true return: number params: x: number","title":"tanh"},{"location":"function_functions/#trunc","text":"description: Truncate deterministic: true return: number params: x: number","title":"trunc"},{"location":"function_functions/#chr","text":"description: Character deterministic: true return: string params: ascii: number","title":"chr"},{"location":"function_functions/#capitalize","text":"description: Capitalize deterministic: true return: string params: value: string","title":"capitalize"},{"location":"function_functions/#endswith","text":"description: Ends with deterministic: true return: boolean params: value: string sub: string start: number","title":"endsWith"},{"location":"function_functions/#strcount","text":"description: Count deterministic: true return: number params: source: string value: string","title":"strCount"},{"location":"function_functions/#lower","text":"description: Lower case deterministic: true return: string params: value: string","title":"lower"},{"location":"function_functions/#lpad","text":"description: Left pad deterministic: true return: string params: value: string len: number pad: string","title":"lpad"},{"location":"function_functions/#ltrim","text":"description: Left trim deterministic: true return: string params: value: string","title":"ltrim"},{"location":"function_functions/#indexof","text":"description: Index of deterministic: true return: number params: value: string sub: string start: number","title":"indexOf"},{"location":"function_functions/#join","text":"description: Join deterministic: true return: string params: values: string[] separator: string : \"","title":"join"},{"location":"function_functions/#replace","text":"description: Replace deterministic: true return: string params: value: string source: string target: string","title":"replace"},{"location":"function_functions/#rpad","text":"description: Right pad deterministic: true return: string params: value: string len: number pad: string","title":"rpad"},{"location":"function_functions/#rtrim","text":"description: Right trim deterministic: true return: string params: value: string","title":"rtrim"},{"location":"function_functions/#substring","text":"description: Substring deterministic: true return: string params: value: string from: number count: number","title":"substring"},{"location":"function_functions/#trim","text":"description: Trim deterministic: true return: string params: value: string","title":"trim"},{"location":"function_functions/#upper","text":"description: Upper case deterministic: true return: string params: value: string","title":"upper"},{"location":"function_functions/#concat","text":"description: Concatenate deterministic: true return: string params: values: any","title":"concat"},{"location":"function_functions/#test","text":"description: Test deterministic: true return: boolean params: value: string regexp: string","title":"test"},{"location":"function_functions/#title","text":"description: Title case deterministic: true return: string params: value: string","title":"title"},{"location":"function_functions/#match","text":"description: Match deterministic: true return: any params: value: string regexp: string","title":"match"},{"location":"function_functions/#mask","text":"description: Mask sensitive data deterministic: true return: string params: value: string","title":"mask"},{"location":"function_functions/#split","text":"description: Split string deterministic: true return: string[] params: value: string separator: string : \"","title":"split"},{"location":"function_functions/#startwith","text":"description: Starts with deterministic: true return: boolean params: value: string sub: string start: number","title":"startWith"},{"location":"function_functions/#map","text":"description: Map deterministic: true return: T[] params: list: any[] predicate: T","title":"map"},{"location":"function_functions/#foreach","text":"description: Foreach deterministic: true return: void params: list: any[] predicate: any","title":"foreach"},{"location":"function_functions/#filter","text":"description: Filter deterministic: true return: T[] params: list: T[] predicate: boolean","title":"filter"},{"location":"function_functions/#reverse","text":"description: Reverse deterministic: true return: T[] params: list: T[] predicate: any","title":"reverse"},{"location":"function_functions/#sort","text":"description: Sort deterministic: true return: T[] params: list: T[] predicate: any","title":"sort"},{"location":"function_functions/#remove","text":"description: Remove deterministic: true return: T[] params: list: T[] predicate: boolean","title":"remove"},{"location":"function_functions/#push","text":"description: Push deterministic: true return: T[] params: list: T[] value: T","title":"push"},{"location":"function_functions/#bulkinsert","text":"description: Bulk Insert deterministic: true return: T[] params: list: T[] value: T[]","title":"bulkInsert"},{"location":"function_functions/#pop","text":"description: Pop deterministic: true return: T params: list: T[]","title":"pop"},{"location":"function_functions/#length","text":"description: Length deterministic: true return: number params: source: any[]|string","title":"length"},{"location":"function_functions/#slice","text":"description: Slice deterministic: true return: T[] params: list: T[] from: integer to: integer","title":"slice"},{"location":"function_functions/#page","text":"description: Paging deterministic: true return: T[] params: list: T[] page: integer records: integer","title":"page"},{"location":"function_functions/#distinct","text":"description: Distinct deterministic: true return: any[] params: list: any[] predicate: any","title":"distinct"},{"location":"function_functions/#first","text":"description: First deterministic: true return: T params: list: T[] predicate: boolean","title":"first"},{"location":"function_functions/#last","text":"description: Last deterministic: true return: T params: list: T[] predicate: boolean","title":"last"},{"location":"function_functions/#count","text":"description: Count deterministic: true return: integer params: list: T[] predicate: boolean","title":"count"},{"location":"function_functions/#max","text":"description: Max deterministic: true return: T params: list: T[] predicate: boolean","title":"max"},{"location":"function_functions/#min","text":"description: Min deterministic: true return: T params: list: T[] predicate: boolean","title":"min"},{"location":"function_functions/#avg","text":"description: Average deterministic: true return: number params: list: T[] value: number","title":"avg"},{"location":"function_functions/#sum","text":"description: Sum deterministic: true return: number params: list: T[] value: number","title":"sum"},{"location":"function_functions/#curtime","text":"description: Current time deterministic: true return: time params: : any","title":"curTime"},{"location":"function_functions/#today","text":"description: Current date deterministic: true return: date params: : any","title":"today"},{"location":"function_functions/#now","text":"description: Current date time deterministic: true return: dateTime params: : any","title":"now"},{"location":"function_functions/#time","text":"description: Get time deterministic: true return: time params: value: string","title":"time"},{"location":"function_functions/#date","text":"description: Get date deterministic: true return: date params: value: string","title":"date"},{"location":"function_functions/#datetime","text":"description: Get date time deterministic: true return: dateTime params: value: string","title":"dateTime"},{"location":"function_functions/#year","text":"description: Get year deterministic: true return: integer params: value: dateTime","title":"year"},{"location":"function_functions/#month","text":"description: Get month deterministic: true return: integer params: value: dateTime","title":"month"},{"location":"function_functions/#day","text":"description: Get day deterministic: true return: integer params: value: dateTime","title":"day"},{"location":"function_functions/#weekday","text":"description: Get day of week deterministic: true return: integer params: value: dateTime","title":"weekday"},{"location":"function_functions/#hour","text":"description: Get hours deterministic: true return: integer params: value: dateTime","title":"hour"},{"location":"function_functions/#minute","text":"description: Get minutes deterministic: true return: integer params: value: dateTime","title":"minute"},{"location":"function_functions/#second","text":"description: Get seconds deterministic: true return: integer params: value: dateTime","title":"second"},{"location":"function_functions/#millisecond","text":"description: Get milliseconds deterministic: true return: integer params: value: dateTime","title":"millisecond"},{"location":"function_functions/#addyear","text":"description: Add years deterministic: true return: dateTime params: date: dateTime value: number","title":"addYear"},{"location":"function_functions/#addmonth","text":"description: Add months deterministic: true return: dateTime params: date: dateTime value: number","title":"addMonth"},{"location":"function_functions/#addday","text":"description: Add days deterministic: true return: dateTime params: date: dateTime value: number","title":"addDay"},{"location":"function_functions/#addhour","text":"description: Add hours deterministic: true return: dateTime params: date: dateTime value: number","title":"addHour"},{"location":"function_functions/#addminute","text":"description: Add minutes deterministic: true return: dateTime params: date: dateTime value: number","title":"addMinute"},{"location":"function_functions/#addsecond","text":"description: Add seconds deterministic: true return: dateTime params: date: dateTime value: number","title":"addSecond"},{"location":"function_functions/#addmillisecond","text":"description: Add milliseconds deterministic: true return: dateTime params: date: dateTime value: number","title":"addMillisecond"},{"location":"function_functions/#addtime","text":"description: Add time deterministic: true return: dateTime params: date: dateTime time: time","title":"addTime"},{"location":"function_functions/#subtracttime","text":"description: Subtract time deterministic: true return: dateTime params: date: dateTime time: time","title":"subtractTime"},{"location":"function_functions/#yeardiff","text":"description: Year difference deterministic: true return: integer params: date1: dateTime date2: dateTime","title":"yearDiff"},{"location":"function_functions/#daydiff","text":"description: Day difference deterministic: true return: integer params: date1: dateTime date2: dateTime","title":"dayDiff"},{"location":"function_functions/#hourdiff","text":"description: Hour difference deterministic: true return: integer params: date1: dateTime date2: dateTime","title":"hourDiff"},{"location":"function_functions/#seconddiff","text":"description: Second difference deterministic: true return: integer params: date1: dateTime date2: dateTime","title":"secondDiff"},{"location":"function_functions/#milliseconddiff","text":"description: Millisecond difference deterministic: true return: integer params: date1: dateTime date2: dateTime","title":"millisecondDiff"},{"location":"function_functions/#daytodate","text":"description: Convert days to date time deterministic: true return: dateTime params: value: number","title":"dayToDate"},{"location":"function_functions/#hourtodate","text":"description: Convert hours to date time deterministic: true return: dateTime params: value: number","title":"hourToDate"},{"location":"function_functions/#secondtodate","text":"description: Convert seconds to date time deterministic: true return: dateTime params: value: number","title":"secondToDate"},{"location":"function_functions/#millisecondtodate","text":"description: Convert milliseconds to date time deterministic: true return: dateTime params: value: number","title":"millisecondToDate"},{"location":"function_functions/#tostring","text":"description: Convert to string deterministic: true return: string params: value: any","title":"toString"},{"location":"function_functions/#tonumber","text":"description: Convert to number deterministic: true return: number params: value: any","title":"toNumber"},{"location":"function_functions/#datetostring","text":"description: Convert date to string deterministic: true return: string params: date: date","title":"dateToString"},{"location":"function_functions/#stringify","text":"description: Convert to JSON string deterministic: true return: string params: value: any","title":"stringify"},{"location":"function_functions/#parse","text":"description: Parse JSON string deterministic: true return: any params: value: string","title":"parse"},{"location":"function_functions/#keys","text":"description: Object keys deterministic: true return: string[] params: obj: any","title":"keys"},{"location":"function_functions/#values","text":"description: Object values deterministic: true return: any[] params: obj: any","title":"values"},{"location":"function_functions/#entries","text":"description: Object entries deterministic: true return: [string,any][] params: obj: any","title":"entries"},{"location":"function_functions/#fromentries","text":"description: Object from entries deterministic: true return: any params: entries: [string : any][]","title":"fromEntries"},{"location":"function_functions/#union","text":"description: Union deterministic: true return: T[] params: a: T[] b: T[]","title":"union"},{"location":"function_functions/#intersection","text":"description: Intersection deterministic: true return: T[] params: a: T[] b: T[]","title":"intersection"},{"location":"function_functions/#difference","text":"description: Difference deterministic: true return: T[] params: a: T[] b: T[]","title":"difference"},{"location":"function_functions/#symmetricdifference","text":"description: Symmetric Difference deterministic: true return: T[] params: a: T[] b: T[]","title":"symmetricDifference"},{"location":"function_functions/#tobase64","text":"description: Convert a string to base64 deterministic: true return: string params: value: string","title":"toBase64"},{"location":"function_functions/#getbase64","text":"description: Get a string from base64 deterministic: true return: string params: value: string","title":"getBase64"},{"location":"function_functions/#encrypt","text":"description: Encrypt a string deterministic: true return: string params: value: string","title":"encrypt"},{"location":"function_functions/#decrypt","text":"description: Decrypt a string deterministic: true return: string params: value: string","title":"decrypt"},{"location":"function_functions/#update","text":"description: Update a list deterministic: true return: any params: list: any[] predicate: any","title":"update"},{"location":"function_functions/#updateall","text":"description: Update all items in a list deterministic: true return: any params: list: any[] predicate: any","title":"updateAll"},{"location":"function_functions/#deleteall","text":"description: Delete all items in a list deterministic: true return: any params: list: any[]","title":"deleteAll"},{"location":"function_functions/#merge","text":"description: Merge a list deterministic: true return: any params: list: any[] predicate: any","title":"merge"},{"location":"function_functions/#bulkmerge","text":"description: Bulk merge a list deterministic: true return: any params: list: any[] predicate: any","title":"bulkMerge"},{"location":"function_functions/#having","text":"description: Having a list deterministic: true return: T[] params: list: T[] predicate: boolean","title":"having"},{"location":"function_functions/#include","text":"description: Include a list deterministic: true return: any params: list: any[] predicate: any","title":"include"},{"location":"function_functions/#desc","text":"description: Descending deterministic: true return: void params: value: any","title":"desc"},{"location":"function_functions/#asc","text":"description: Ascending deterministic: true return: void params: value: any","title":"asc"},{"location":"function_functions/#ormexecute","text":"description: Execute query deterministic: true return: any params: query: string data: any options: any","title":"orm.execute"},{"location":"function_functions/#ormplan","text":"description: Plan of query deterministic: true return: any params: query: string options: any","title":"orm.plan"},{"location":"function_functions/#ormmetadata","text":"description: Get metadata from query deterministic: true return: any params: query: string","title":"orm.metadata"},{"location":"function_functions/#ormmodel","text":"description: Get model from query deterministic: true return: any params: query: string","title":"orm.model"},{"location":"function_functions/#ormparameters","text":"description: Get parameters from query deterministic: true return: any params: query: string","title":"orm.parameters"},{"location":"function_functions/#ormconstraints","text":"description: Get constraints from query deterministic: true return: any params: query: string","title":"orm.constraints"},{"location":"function_functions/#contains","text":"description: Includes deterministic: true return: boolean params: source: string|T[] value: string|T","title":"contains"},{"location":"function_functions/#substr","text":"description: Substring deterministic: true return: string params: value: string from: number count: number","title":"substr"},{"location":"function_functions/#concatenate","text":"description: Concatenate deterministic: true return: string params: values: any","title":"concatenate"},{"location":"function_functions/#startswith","text":"description: Starts with deterministic: true return: boolean params: value: string sub: string start: number","title":"startsWith"},{"location":"function_functions/#select","text":"description: Map deterministic: true return: T[] params: list: any[] predicate: T","title":"select"},{"location":"function_functions/#each","text":"description: Foreach deterministic: true return: void params: list: any[] predicate: any","title":"each"},{"location":"function_functions/#where","text":"description: Filter deterministic: true return: T[] params: list: T[] predicate: boolean","title":"where"},{"location":"function_functions/#order","text":"description: Sort deterministic: true return: T[] params: list: T[] predicate: any","title":"order"},{"location":"function_functions/#delete","text":"description: Remove deterministic: true return: T[] params: list: T[] predicate: boolean","title":"delete"},{"location":"function_functions/#insert","text":"description: Push deterministic: true return: T[] params: list: T[] value: T","title":"insert"},{"location":"function_functions/#len","text":"description: Length deterministic: true return: number params: source: any[]|string","title":"len"},{"location":"operator_operators/","text":"Operator Description + Addition - Negation - Subtraction * Multiplication / Division ** Exponentiation // Root % Modulus & Bitwise AND ^ Bitwise XOR ~ Bitwise NOT << Bitwise Left Shift >> Bitwise Right Shift == Equality != Inequality > Greater than < Less than >= Greater than or equal <= Less than or equal && Logical AND ! Logical NOT [] Index $ Environment Variable = Assignment += Assignment Addition -= Assignment Subtraction *= Assignment Multiplication /= Assignment Division **= Assignment Exponentiation //= Assignment Floor Division %= Assignment Modulus &= Assignment Bitwise AND = ^= Assignment Bitwise XOR <<= Assignment Bitwise Left Shift >>= Assignment Bitwise Right Shift === Equality !== Inequality <> Inequality Definition Operator + description: Addition return: T params: a: T b: T Operator - description: Negation return: number params: a: number Operator - description: Subtraction return: number params: a: number b: number Operator * description: Multiplication return: number params: a: number b: number Operator / description: Division return: number params: a: number b: number Operator ** description: Exponentiation return: number params: a: number b: number Operator // description: Root return: number params: a: number b: number Operator % description: Modulus return: number params: a: number b: number Operator & description: Bitwise AND return: number params: a: number b: number Operator | description: Bitwise OR return: number params: a: number b: number Operator ^ description: Bitwise XOR return: number params: a: number b: number Operator ~ description: Bitwise NOT return: number params: a: number Operator << description: Bitwise Left Shift return: number params: a: number b: number Operator >> description: Bitwise Right Shift return: number params: a: number b: number Operator == description: Equality return: boolean params: a: T b: T Operator != description: Inequality return: boolean params: a: T b: T Operator > description: Greater than return: boolean params: a: T b: T Operator < description: Less than return: boolean params: a: T b: T Operator >= description: Greater than or equal return: boolean params: a: T b: T Operator <= description: Less than or equal return: boolean params: a: T b: T Operator && description: Logical AND return: boolean params: a: boolean b: boolean Operator || description: Logical OR return: boolean params: a: boolean b: boolean Operator ! description: Logical NOT return: boolean params: a: boolean Operator [] description: Index return: T params: list: T[] index: any Operator $ description: Environment Variable return: string params: name: string Operator = description: Assignment return: T params: a: T b: T Operator += description: Assignment Addition return: number params: a: number b: number Operator -= description: Assignment Subtraction return: number params: a: number b: number Operator *= description: Assignment Multiplication return: number params: a: number b: number Operator /= description: Assignment Division return: number params: a: number b: number Operator **= description: Assignment Exponentiation return: number params: a: number b: number Operator //= description: Assignment Floor Division return: number params: a: number b: number Operator %= description: Assignment Modulus return: number params: a: number b: number Operator &= description: Assignment Bitwise AND return: number params: a: number b: number Operator |= description: Assignment Bitwise OR return: number params: a: number b: number Operator ^= description: Assignment Bitwise XOR return: number params: a: number b: number Operator <<= description: Assignment Bitwise Left Shift return: number params: a: number b: number Operator >>= description: Assignment Bitwise Right Shift return: number params: a: number b: number Operator === description: Equality return: boolean params: a: T b: T Operator !== description: Inequality return: boolean params: a: T b: T Operator <> description: Inequality return: boolean params: a: T b: T","title":"Operator operators"},{"location":"operator_operators/#definition","text":"","title":"Definition"},{"location":"operator_operators/#operator","text":"description: Addition return: T params: a: T b: T","title":"Operator +"},{"location":"operator_operators/#operator-","text":"description: Negation return: number params: a: number","title":"Operator -"},{"location":"operator_operators/#operator-_1","text":"description: Subtraction return: number params: a: number b: number","title":"Operator -"},{"location":"operator_operators/#operator_1","text":"description: Multiplication return: number params: a: number b: number","title":"Operator *"},{"location":"operator_operators/#operator_2","text":"description: Division return: number params: a: number b: number","title":"Operator /"},{"location":"operator_operators/#operator_3","text":"description: Exponentiation return: number params: a: number b: number","title":"Operator **"},{"location":"operator_operators/#operator_4","text":"description: Root return: number params: a: number b: number","title":"Operator //"},{"location":"operator_operators/#operator_5","text":"description: Modulus return: number params: a: number b: number","title":"Operator %"},{"location":"operator_operators/#operator_6","text":"description: Bitwise AND return: number params: a: number b: number","title":"Operator &amp;"},{"location":"operator_operators/#operator_7","text":"description: Bitwise OR return: number params: a: number b: number","title":"Operator |"},{"location":"operator_operators/#operator_8","text":"description: Bitwise XOR return: number params: a: number b: number","title":"Operator ^"},{"location":"operator_operators/#operator_9","text":"description: Bitwise NOT return: number params: a: number","title":"Operator ~"},{"location":"operator_operators/#operator_10","text":"description: Bitwise Left Shift return: number params: a: number b: number","title":"Operator &lt;&lt;"},{"location":"operator_operators/#operator_11","text":"description: Bitwise Right Shift return: number params: a: number b: number","title":"Operator &gt;&gt;"},{"location":"operator_operators/#operator_12","text":"description: Equality return: boolean params: a: T b: T","title":"Operator =="},{"location":"operator_operators/#operator_13","text":"description: Inequality return: boolean params: a: T b: T","title":"Operator !="},{"location":"operator_operators/#operator_14","text":"description: Greater than return: boolean params: a: T b: T","title":"Operator &gt;"},{"location":"operator_operators/#operator_15","text":"description: Less than return: boolean params: a: T b: T","title":"Operator &lt;"},{"location":"operator_operators/#operator_16","text":"description: Greater than or equal return: boolean params: a: T b: T","title":"Operator &gt;="},{"location":"operator_operators/#operator_17","text":"description: Less than or equal return: boolean params: a: T b: T","title":"Operator &lt;="},{"location":"operator_operators/#operator_18","text":"description: Logical AND return: boolean params: a: boolean b: boolean","title":"Operator &amp;&amp;"},{"location":"operator_operators/#operator_19","text":"description: Logical OR return: boolean params: a: boolean b: boolean","title":"Operator ||"},{"location":"operator_operators/#operator_20","text":"description: Logical NOT return: boolean params: a: boolean","title":"Operator !"},{"location":"operator_operators/#operator_21","text":"description: Index return: T params: list: T[] index: any","title":"Operator []"},{"location":"operator_operators/#operator_22","text":"description: Environment Variable return: string params: name: string","title":"Operator $"},{"location":"operator_operators/#operator_23","text":"description: Assignment return: T params: a: T b: T","title":"Operator ="},{"location":"operator_operators/#operator_24","text":"description: Assignment Addition return: number params: a: number b: number","title":"Operator +="},{"location":"operator_operators/#operator-_2","text":"description: Assignment Subtraction return: number params: a: number b: number","title":"Operator -="},{"location":"operator_operators/#operator_25","text":"description: Assignment Multiplication return: number params: a: number b: number","title":"Operator *="},{"location":"operator_operators/#operator_26","text":"description: Assignment Division return: number params: a: number b: number","title":"Operator /="},{"location":"operator_operators/#operator_27","text":"description: Assignment Exponentiation return: number params: a: number b: number","title":"Operator **="},{"location":"operator_operators/#operator_28","text":"description: Assignment Floor Division return: number params: a: number b: number","title":"Operator //="},{"location":"operator_operators/#operator_29","text":"description: Assignment Modulus return: number params: a: number b: number","title":"Operator %="},{"location":"operator_operators/#operator_30","text":"description: Assignment Bitwise AND return: number params: a: number b: number","title":"Operator &amp;="},{"location":"operator_operators/#operator_31","text":"description: Assignment Bitwise OR return: number params: a: number b: number","title":"Operator |="},{"location":"operator_operators/#operator_32","text":"description: Assignment Bitwise XOR return: number params: a: number b: number","title":"Operator ^="},{"location":"operator_operators/#operator_33","text":"description: Assignment Bitwise Left Shift return: number params: a: number b: number","title":"Operator &lt;&lt;="},{"location":"operator_operators/#operator_34","text":"description: Assignment Bitwise Right Shift return: number params: a: number b: number","title":"Operator &gt;&gt;="},{"location":"operator_operators/#operator_35","text":"description: Equality return: boolean params: a: T b: T","title":"Operator ==="},{"location":"operator_operators/#operator_36","text":"description: Inequality return: boolean params: a: T b: T","title":"Operator !=="},{"location":"operator_operators/#operator_37","text":"description: Inequality return: boolean params: a: T b: T","title":"Operator &lt;&gt;"},{"location":"queries/operatorsAndFunctions/Bitwise/","text":"Operator Description ~ bitNot & bitAnd | bitOr ^ bitXor << leftShift >> rightShift Examples Example Result Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude & 1 }) [{\"result\":1}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude 1 }) Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: ~ p.longitude }) [{\"result\":54}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude << 1 }) [{\"result\":18446744073709552000}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude ^ 1 }) [{\"result\":18446744073709552000}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude >> 1 }) [{\"result\":9223372036854776000}] Sentences Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise AND operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude & 1 }) SQL Result: SELECT c.longitude & 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise OR operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude | 1 }) SQL Result: SELECT c.longitude | 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise NOT operation of the longitude. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: ~ p.longitude }) SQL Result: SELECT ~ c.longitude AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise left shift operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude << 1 }) SQL Result: SELECT c.longitude << 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise XOR operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude ^ 1 }) SQL Result: SELECT c.longitude ^ 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise right shift operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude >> 1 }) SQL Result: SELECT c.longitude >> 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Definition Operator ~ description: bitNot return: boolean params: value: boolean Operator & description: bitAnd return: number params: a: number b: number Operator | description: bitOr return: number params: a: number b: number Operator ^ description: bitXor return: number params: a: number b: number Operator << description: leftShift return: number params: a: number b: number Operator >> description: rightShift return: number params: a: number b: number","title":"Bitwise"},{"location":"queries/operatorsAndFunctions/Bitwise/#examples","text":"Example Result Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude & 1 }) [{\"result\":1}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude 1 }) Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: ~ p.longitude }) [{\"result\":54}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude << 1 }) [{\"result\":18446744073709552000}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude ^ 1 }) [{\"result\":18446744073709552000}] Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude >> 1 }) [{\"result\":9223372036854776000}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Bitwise/#sentences","text":"Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise AND operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude & 1 }) SQL Result: SELECT c.longitude & 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise OR operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude | 1 }) SQL Result: SELECT c.longitude | 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise NOT operation of the longitude. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: ~ p.longitude }) SQL Result: SELECT ~ c.longitude AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise left shift operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude << 1 }) SQL Result: SELECT c.longitude << 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise XOR operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude ^ 1 }) SQL Result: SELECT c.longitude ^ 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1 Lambda: Query to select the first record from the Countries entity where the iso3 is equal to \"BRA\" and the result is the bitwise right shift operation between the longitude and 1. Countries.filter(p=> p.iso3==\"BRA\").first(p=> {result: p.longitude >> 1 }) SQL Result: SELECT c.longitude >> 1 AS result FROM Countries c WHERE c.iso3 = 'BRA' ORDER BY result asc LIMIT 0,1","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Bitwise/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator","text":"description: bitNot return: boolean params: value: boolean","title":"Operator ~"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator_1","text":"description: bitAnd return: number params: a: number b: number","title":"Operator &amp;"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator_2","text":"description: bitOr return: number params: a: number b: number","title":"Operator |"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator_3","text":"description: bitXor return: number params: a: number b: number","title":"Operator ^"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator_4","text":"description: leftShift return: number params: a: number b: number","title":"Operator &lt;&lt;"},{"location":"queries/operatorsAndFunctions/Bitwise/#operator_5","text":"description: rightShift return: number params: a: number b: number","title":"Operator &gt;&gt;"},{"location":"queries/operatorsAndFunctions/Comparison/","text":"Operator Description == === equal != !== <> notEqual > greaterThan < lessThan >= greaterThanOrEqual <= lessThanOrEqual Function Description between Specifies how to retrieve values from an expression within a specific range in/includes Is used to reduce the use of multiple OR conditions Examples Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> p.iso3 === \"BRA\").map(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> p.latitude < -9 && p.latitude > -11 && p.longitude == -55 ).first(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> between(p.latitude,-11,-9) && p.longitude == -55 ).first(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> in(p.iso3,[\"BRA\",\"ARG\"])).map(p=> p.name) [{\"name\":\"Argentina\"},{\"name\":\"Brazil\"}] Sentences Lambda: Query to select the name from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the name from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 === \"BRA\").map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the name from the Countries entity where the latitude is less than -9 and greater than -11 and the longitude is equal to -55. Countries.filter(p=> p.latitude < -9 && p.latitude > -11 && p.longitude == -55 ).first(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE (c.latitude < -9 AND (c.latitude > -11 AND c.longitude = -55)) ORDER BY c.name asc LIMIT 0,1 Lambda: Query to select the name from the Countries entity where the latitude is between -11 and -9 and the longitude is equal to -55. Countries.filter(p=> between(p.latitude,-11,-9) && p.longitude == -55 ).first(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE (c.latitude BETWEEN -11 AND -9 AND c.longitude = -55) ORDER BY c.name asc LIMIT 0,1 ```s **Lambda:** Query to select the name from the Countries entity where the iso3 is equal to \"BRA\" or \"ARG\". ```js Countries.filter(p=> in(p.iso3,[\"BRA\",\"ARG\"])).map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 IN ('BRA', 'ARG') Definition Operator == description: equal return: boolean params: a: T b: T Operator === description: equal return: boolean params: a: T b: T Operator != description: notEqual return: boolean params: a: T b: T Operator !== description: notEqual return: boolean params: a: T b: T Operator <> description: notEqual return: boolean params: a: T b: T Operator > description: greaterThan return: boolean params: a: T b: T Operator < description: lessThan return: boolean params: a: T b: T Operator >= description: greaterThanOrEqual return: boolean params: a: T b: T Operator <= description: lessThanOrEqual return: boolean params: a: T b: T between description: Specifies how to retrieve values from an expression within a specific range. deterministic: true return: boolean params: value: T from: T to: T includes description: Determines if an array includes a certain element deterministic: true return: boolean params: value: T list: T[] in description: Determines if an array includes a certain element deterministic: true return: boolean params: value: T list: T[]","title":"Comparison"},{"location":"queries/operatorsAndFunctions/Comparison/#examples","text":"Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> p.iso3 === \"BRA\").map(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> p.latitude < -9 && p.latitude > -11 && p.longitude == -55 ).first(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> between(p.latitude,-11,-9) && p.longitude == -55 ).first(p=> p.name) [{\"name\":\"Brazil\"}] Countries.filter(p=> in(p.iso3,[\"BRA\",\"ARG\"])).map(p=> p.name) [{\"name\":\"Argentina\"},{\"name\":\"Brazil\"}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Comparison/#sentences","text":"Lambda: Query to select the name from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the name from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 === \"BRA\").map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the name from the Countries entity where the latitude is less than -9 and greater than -11 and the longitude is equal to -55. Countries.filter(p=> p.latitude < -9 && p.latitude > -11 && p.longitude == -55 ).first(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE (c.latitude < -9 AND (c.latitude > -11 AND c.longitude = -55)) ORDER BY c.name asc LIMIT 0,1 Lambda: Query to select the name from the Countries entity where the latitude is between -11 and -9 and the longitude is equal to -55. Countries.filter(p=> between(p.latitude,-11,-9) && p.longitude == -55 ).first(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE (c.latitude BETWEEN -11 AND -9 AND c.longitude = -55) ORDER BY c.name asc LIMIT 0,1 ```s **Lambda:** Query to select the name from the Countries entity where the iso3 is equal to \"BRA\" or \"ARG\". ```js Countries.filter(p=> in(p.iso3,[\"BRA\",\"ARG\"])).map(p=> p.name) SQL Result: SELECT c.name AS name FROM Countries c WHERE c.iso3 IN ('BRA', 'ARG')","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Comparison/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Comparison/#operator","text":"description: equal return: boolean params: a: T b: T","title":"Operator =="},{"location":"queries/operatorsAndFunctions/Comparison/#operator_1","text":"description: equal return: boolean params: a: T b: T","title":"Operator ==="},{"location":"queries/operatorsAndFunctions/Comparison/#operator_2","text":"description: notEqual return: boolean params: a: T b: T","title":"Operator !="},{"location":"queries/operatorsAndFunctions/Comparison/#operator_3","text":"description: notEqual return: boolean params: a: T b: T","title":"Operator !=="},{"location":"queries/operatorsAndFunctions/Comparison/#operator_4","text":"description: notEqual return: boolean params: a: T b: T","title":"Operator &lt;&gt;"},{"location":"queries/operatorsAndFunctions/Comparison/#operator_5","text":"description: greaterThan return: boolean params: a: T b: T","title":"Operator &gt;"},{"location":"queries/operatorsAndFunctions/Comparison/#operator_6","text":"description: lessThan return: boolean params: a: T b: T","title":"Operator &lt;"},{"location":"queries/operatorsAndFunctions/Comparison/#operator_7","text":"description: greaterThanOrEqual return: boolean params: a: T b: T","title":"Operator &gt;="},{"location":"queries/operatorsAndFunctions/Comparison/#operator_8","text":"description: lessThanOrEqual return: boolean params: a: T b: T","title":"Operator &lt;="},{"location":"queries/operatorsAndFunctions/Comparison/#between","text":"description: Specifies how to retrieve values from an expression within a specific range. deterministic: true return: boolean params: value: T from: T to: T","title":"between"},{"location":"queries/operatorsAndFunctions/Comparison/#includes","text":"description: Determines if an array includes a certain element deterministic: true return: boolean params: value: T list: T[]","title":"includes"},{"location":"queries/operatorsAndFunctions/Comparison/#in","text":"description: Determines if an array includes a certain element deterministic: true return: boolean params: value: T list: T[]","title":"in"},{"location":"queries/operatorsAndFunctions/Datetime/","text":"Function Description curTime Get the current time today Get the current date now Get the current dateTime dateToString Convert date to string with ISO 8601 format time Convert string to time date Convert string to date dateTime Convert string to dateTime year Get year from date month Get month from date day Get day of month from date weekday Get date of week from date hour Get hour from date minute Get minute from date second Get second from date millisecond Get millisecond from date addYear Add years to a date addMonth Add months to a date addDay Add days to a date addHour Add hours to a date addMinute Add minutes to a date addSecond Add seconds to a date addMillisecond Add milliseconds to a date addTime Add time to a date subtractTime subtract time to a date dayDiff difference between two dates in days hourDiff difference between two dates in hours secondDiff difference between two dates in seconds millisecondDiff difference between two dates in milliseconds dayToDate days to Date hourToDate hours to Date secondToDate seconds to Date millisecondToDate milliseconds to Date Examples Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:today()}) [{\"result\":\"2022-08-14T22:00:00.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:now()}) [{\"result\":\"2022-08-15T09:54:22.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:curTime()}) [{\"result\":\"11:54:22\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:time(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"00:20:21\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:date(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"2021-09-05T22:00:00.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateTime(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"2021-09-06T12:39:11.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateToString(dateTime(\"2021-09-06T14:39:11.444Z\"))}) [{\"result\":\"2021-09-06T14:39:11Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:year(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":2021}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:month(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":9}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:day(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":6}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:weekday(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":2}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hour(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":0}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:minute(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":20}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:second(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":21}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecond(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":0}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addYear(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2023-09-06 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMonth(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-11-06 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addDay(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-08 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addHour(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 16:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMinute(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:41:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addSecond(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:39:13.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMillisecond(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:39:11.446000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) [{\"result\":\"08:42:33\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:subtractTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) [{\"result\":\"-08:01:51\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":4}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":353341}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":353341000}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayToDate(2000)}) [{\"result\":\"1975-06-24T00:00:00Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourToDate(2000)}) [{\"result\":\"1970-03-25T08:00:00Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondToDate(2000)}) [{\"result\":\"1970-01-01T00:33:20Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondToDate(2000)}) [{\"result\":\"1970-01-01T00:00:02Z\"}] Sentences Lambda: Query to select the current date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:today()}) SQL Result: SELECT CURDATE() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the current dateTime from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:now()}) SQL Result: SELECT NOW() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the current time from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:curTime()}) SQL Result: SELECT CURTIME() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the time from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:time(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', TIME) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:date(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', DATE) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the dateTime from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateTime(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', DATETIME) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date as string from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateToString(dateTime(\"2021-09-06T14:39:11.444Z\"))}) SQL Result: SELECT DATE_FORMAT(CONVERT('2021-09-06T14:39:11.444Z', DATETIME), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the year from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:year(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(YEAR FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the month from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:month(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(MONTH FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the day from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:day(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT DAYOFMONTH('2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date of week from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:weekday(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT DAYOFWEEK('2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the hour from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hour(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(HOUR FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the minute from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:minute(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(MINUTE FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the second from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:second(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(SECOND FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the millisecond from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecond(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT ROUND(EXTRACT(MICROSECOND FROM '2021-09-06T14:39:11.444Z')/1000,0) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add years to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addYear(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 YEAR) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add months to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMonth(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 MONTH) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add days to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addDay(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 DAY) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add hours to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addHour(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' HOUR AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add minutes to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMinute(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' MINUTE AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add seconds to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addSecond(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' SECOND AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add milliseconds to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMillisecond(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL (2 * 1000) MICROSECOND) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add time to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) SQL Result: SELECT ADDTIME('2021-09-06T14:39:11.444Z','08:22:12') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to subtract time to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:subtractTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) SQL Result: SELECT SUBTIME('2021-09-06T14:39:11.444Z','08:22:12') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in days from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT DATEDIFF('2021-09-06T14:39:11','2021-09-02T12:30:10') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in hours from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT TIMESTAMPDIFF(HOUR, '2021-09-02T12:30:10','2021-09-06T14:39:11') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in seconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT TIMESTAMPDIFF(SECOND, '2021-09-02T12:30:10','2021-09-06T14:39:11') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT ROUND(TIMESTAMPDIFF(MICROSECOND, '2021-09-02T12:30:10','2021-09-06T14:39:11')/1000,0) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from days from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000*24*3600), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from hours from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000*3600), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from seconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from milliseconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000/1000), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Definition curTime description: Get the current time deterministic: true return: Date today description: Get the current date deterministic: true return: Date now description: Get the current dateTime deterministic: true return: Date dateToString description: Convert date to string with ISO 8601 format deterministic: true return: string params: value: Date time description: Convert string to time deterministic: true return: Date params: value: string date description: Convert string to date deterministic: true return: Date params: value: string dateTime description: Convert string to dateTime deterministic: true return: Date params: value: string year description: Get year from date deterministic: true return: number params: value: Date month description: Get month from date deterministic: true return: number params: value: Date day description: Get day of month from date deterministic: true return: number params: value: Date weekday description: get date of week from date deterministic: true return: number params: value: Date hour description: get hour from date deterministic: true return: number params: value: Date minute description: Get minute from date deterministic: true return: number params: value: Date second description: Get second from date deterministic: true return: number params: value: Date millisecond description: Get millisecond from date deterministic: true return: number params: value: Date addYear description: Add years to a date deterministic: true return: Date params: date: Date value: number addMonth description: Add months to a date deterministic: true return: Date params: date: Date value: number addDay description: Add days to a date deterministic: true return: Date params: date: Date value: number addHour description: Add hours to a date deterministic: true return: Date params: date: Date value: number addMinute description: Add minutes to a date deterministic: true return: Date params: date: Date value: number addSecond description: Add seconds to a date deterministic: true return: Date params: date: Date value: number addMillisecond description: Add milliseconds to a date deterministic: true return: Date params: date: Date value: number addTime description: Add time to a date deterministic: true return: Date params: date: Date time: Date subtractTime description: subtract time to a date deterministic: true return: Date params: date: Date time: Date dayDiff description: difference between two dates in days deterministic: true return: Date params: date: Date date2: Date hourDiff description: difference between two dates in hours deterministic: true return: Date params: time: Date time2: Date secondDiff description: difference between two dates in seconds deterministic: true return: Date params: time: Date time2: Date millisecondDiff description: difference between two dates in milliseconds deterministic: true return: Date params: time: Date time2: Date dayToDate description: days to Date deterministic: true return: Date params: value: number hourToDate description: hours to Date deterministic: true return: Date params: value: number secondToDate description: seconds to Date deterministic: true return: Date params: value: number millisecondToDate description: milliseconds to Date deterministic: true return: Date params: value: number","title":"Datetime"},{"location":"queries/operatorsAndFunctions/Datetime/#examples","text":"Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:today()}) [{\"result\":\"2022-08-14T22:00:00.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:now()}) [{\"result\":\"2022-08-15T09:54:22.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:curTime()}) [{\"result\":\"11:54:22\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:time(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"00:20:21\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:date(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"2021-09-05T22:00:00.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateTime(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":\"2021-09-06T12:39:11.000Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateToString(dateTime(\"2021-09-06T14:39:11.444Z\"))}) [{\"result\":\"2021-09-06T14:39:11Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:year(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":2021}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:month(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":9}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:day(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":6}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:weekday(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":2}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hour(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":0}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:minute(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":20}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:second(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":21}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecond(\"2021-09-06T14:39:11.444Z\")}) [{\"result\":0}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addYear(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2023-09-06 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMonth(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-11-06 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addDay(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-08 14:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addHour(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 16:39:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMinute(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:41:11.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addSecond(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:39:13.444000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMillisecond(\"2021-09-06T14:39:11.444Z\",2)}) [{\"result\":\"2021-09-06 14:39:11.446000\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) [{\"result\":\"08:42:33\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:subtractTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) [{\"result\":\"-08:01:51\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":4}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":353341}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) [{\"result\":353341000}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayToDate(2000)}) [{\"result\":\"1975-06-24T00:00:00Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourToDate(2000)}) [{\"result\":\"1970-03-25T08:00:00Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondToDate(2000)}) [{\"result\":\"1970-01-01T00:33:20Z\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondToDate(2000)}) [{\"result\":\"1970-01-01T00:00:02Z\"}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Datetime/#sentences","text":"Lambda: Query to select the current date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:today()}) SQL Result: SELECT CURDATE() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the current dateTime from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:now()}) SQL Result: SELECT NOW() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the current time from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:curTime()}) SQL Result: SELECT CURTIME() AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the time from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:time(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', TIME) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:date(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', DATE) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the dateTime from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateTime(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT CONVERT('2021-09-06T14:39:11.444Z', DATETIME) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date as string from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dateToString(dateTime(\"2021-09-06T14:39:11.444Z\"))}) SQL Result: SELECT DATE_FORMAT(CONVERT('2021-09-06T14:39:11.444Z', DATETIME), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the year from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:year(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(YEAR FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the month from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:month(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(MONTH FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the day from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:day(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT DAYOFMONTH('2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the date of week from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:weekday(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT DAYOFWEEK('2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the hour from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hour(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(HOUR FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the minute from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:minute(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(MINUTE FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the second from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:second(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT EXTRACT(SECOND FROM '2021-09-06T14:39:11.444Z') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to select the millisecond from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecond(\"2021-09-06T14:39:11.444Z\")}) SQL Result: SELECT ROUND(EXTRACT(MICROSECOND FROM '2021-09-06T14:39:11.444Z')/1000,0) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add years to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addYear(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 YEAR) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add months to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMonth(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 MONTH) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add days to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addDay(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL 2 DAY) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add hours to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addHour(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' HOUR AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add minutes to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMinute(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' MINUTE AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add seconds to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addSecond(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT '2021-09-06T14:39:11.444Z' + interval '2' SECOND AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add milliseconds to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addMillisecond(\"2021-09-06T14:39:11.444Z\",2)}) SQL Result: SELECT DATE_ADD('2021-09-06T14:39:11.444Z', INTERVAL (2 * 1000) MICROSECOND) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to add time to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:addTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) SQL Result: SELECT ADDTIME('2021-09-06T14:39:11.444Z','08:22:12') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to subtract time to a date from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:subtractTime(\"2021-09-06T14:39:11.444Z\",\"08:22:12\")}) SQL Result: SELECT SUBTIME('2021-09-06T14:39:11.444Z','08:22:12') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in days from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT DATEDIFF('2021-09-06T14:39:11','2021-09-02T12:30:10') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in hours from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT TIMESTAMPDIFF(HOUR, '2021-09-02T12:30:10','2021-09-06T14:39:11') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the difference between two dates in seconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT TIMESTAMPDIFF(SECOND, '2021-09-02T12:30:10','2021-09-06T14:39:11') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondDiff(\"2021-09-06T14:39:11\",\"2021-09-02T12:30:10\")}) SQL Result: SELECT ROUND(TIMESTAMPDIFF(MICROSECOND, '2021-09-02T12:30:10','2021-09-06T14:39:11')/1000,0) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from days from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:dayToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000*24*3600), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from hours from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:hourToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000*3600), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from seconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:secondToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the date from milliseconds from the Countries entity where the iso3 is equal to \"BRA\". Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result:millisecondToDate(2000)}) SQL Result: SELECT DATE_FORMAT(FROM_UNIXTIME(2000/1000), '%Y-%m-%dT%TZ') AS result FROM Countries c WHERE c.iso3 = 'BRA'","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Datetime/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Datetime/#curtime","text":"description: Get the current time deterministic: true return: Date","title":"curTime"},{"location":"queries/operatorsAndFunctions/Datetime/#today","text":"description: Get the current date deterministic: true return: Date","title":"today"},{"location":"queries/operatorsAndFunctions/Datetime/#now","text":"description: Get the current dateTime deterministic: true return: Date","title":"now"},{"location":"queries/operatorsAndFunctions/Datetime/#datetostring","text":"description: Convert date to string with ISO 8601 format deterministic: true return: string params: value: Date","title":"dateToString"},{"location":"queries/operatorsAndFunctions/Datetime/#time","text":"description: Convert string to time deterministic: true return: Date params: value: string","title":"time"},{"location":"queries/operatorsAndFunctions/Datetime/#date","text":"description: Convert string to date deterministic: true return: Date params: value: string","title":"date"},{"location":"queries/operatorsAndFunctions/Datetime/#datetime","text":"description: Convert string to dateTime deterministic: true return: Date params: value: string","title":"dateTime"},{"location":"queries/operatorsAndFunctions/Datetime/#year","text":"description: Get year from date deterministic: true return: number params: value: Date","title":"year"},{"location":"queries/operatorsAndFunctions/Datetime/#month","text":"description: Get month from date deterministic: true return: number params: value: Date","title":"month"},{"location":"queries/operatorsAndFunctions/Datetime/#day","text":"description: Get day of month from date deterministic: true return: number params: value: Date","title":"day"},{"location":"queries/operatorsAndFunctions/Datetime/#weekday","text":"description: get date of week from date deterministic: true return: number params: value: Date","title":"weekday"},{"location":"queries/operatorsAndFunctions/Datetime/#hour","text":"description: get hour from date deterministic: true return: number params: value: Date","title":"hour"},{"location":"queries/operatorsAndFunctions/Datetime/#minute","text":"description: Get minute from date deterministic: true return: number params: value: Date","title":"minute"},{"location":"queries/operatorsAndFunctions/Datetime/#second","text":"description: Get second from date deterministic: true return: number params: value: Date","title":"second"},{"location":"queries/operatorsAndFunctions/Datetime/#millisecond","text":"description: Get millisecond from date deterministic: true return: number params: value: Date","title":"millisecond"},{"location":"queries/operatorsAndFunctions/Datetime/#addyear","text":"description: Add years to a date deterministic: true return: Date params: date: Date value: number","title":"addYear"},{"location":"queries/operatorsAndFunctions/Datetime/#addmonth","text":"description: Add months to a date deterministic: true return: Date params: date: Date value: number","title":"addMonth"},{"location":"queries/operatorsAndFunctions/Datetime/#addday","text":"description: Add days to a date deterministic: true return: Date params: date: Date value: number","title":"addDay"},{"location":"queries/operatorsAndFunctions/Datetime/#addhour","text":"description: Add hours to a date deterministic: true return: Date params: date: Date value: number","title":"addHour"},{"location":"queries/operatorsAndFunctions/Datetime/#addminute","text":"description: Add minutes to a date deterministic: true return: Date params: date: Date value: number","title":"addMinute"},{"location":"queries/operatorsAndFunctions/Datetime/#addsecond","text":"description: Add seconds to a date deterministic: true return: Date params: date: Date value: number","title":"addSecond"},{"location":"queries/operatorsAndFunctions/Datetime/#addmillisecond","text":"description: Add milliseconds to a date deterministic: true return: Date params: date: Date value: number","title":"addMillisecond"},{"location":"queries/operatorsAndFunctions/Datetime/#addtime","text":"description: Add time to a date deterministic: true return: Date params: date: Date time: Date","title":"addTime"},{"location":"queries/operatorsAndFunctions/Datetime/#subtracttime","text":"description: subtract time to a date deterministic: true return: Date params: date: Date time: Date","title":"subtractTime"},{"location":"queries/operatorsAndFunctions/Datetime/#daydiff","text":"description: difference between two dates in days deterministic: true return: Date params: date: Date date2: Date","title":"dayDiff"},{"location":"queries/operatorsAndFunctions/Datetime/#hourdiff","text":"description: difference between two dates in hours deterministic: true return: Date params: time: Date time2: Date","title":"hourDiff"},{"location":"queries/operatorsAndFunctions/Datetime/#seconddiff","text":"description: difference between two dates in seconds deterministic: true return: Date params: time: Date time2: Date","title":"secondDiff"},{"location":"queries/operatorsAndFunctions/Datetime/#milliseconddiff","text":"description: difference between two dates in milliseconds deterministic: true return: Date params: time: Date time2: Date","title":"millisecondDiff"},{"location":"queries/operatorsAndFunctions/Datetime/#daytodate","text":"description: days to Date deterministic: true return: Date params: value: number","title":"dayToDate"},{"location":"queries/operatorsAndFunctions/Datetime/#hourtodate","text":"description: hours to Date deterministic: true return: Date params: value: number","title":"hourToDate"},{"location":"queries/operatorsAndFunctions/Datetime/#secondtodate","text":"description: seconds to Date deterministic: true return: Date params: value: number","title":"secondToDate"},{"location":"queries/operatorsAndFunctions/Datetime/#millisecondtodate","text":"description: milliseconds to Date deterministic: true return: Date params: value: number","title":"millisecondToDate"},{"location":"queries/operatorsAndFunctions/Group/","text":"Function Description avg Calculates the average of the specified columns in a set of rows count Calculating the number of rows in a set. first Returns the first value of the selected column last Returns the last value of the selected column. max Calculating the maximum. min Calculating the minimum. sum Calculating the sum. Examples Countries.filter(p=> p.region == \"Americas\").map(p=> {result:count(1)}) [{\"result\":57}] Countries.map(p=> {region:p.region,countries:count(1)})| [{\"region\":\"\",\"countries\":2} ,{\"region\":\"Africa\",\"countries\":60} ,{\"region\":\"Americas\",\"countries\":57} ,{\"region\":\"Asia\",\"countries\":50} ,{\"region\":\"Europe\",\"countries\":53} ,{\"region\":\"Oceania\",\"countries\":27} ,{\"region\":\"Polar\",\"countries\":1} ] Countries.map(p=> {region:p.region,max:max(p.latitude)}) [{\"region\":\"\",\"max\":-53.1} ,{\"region\":\"Africa\",\"max\":34} ,{\"region\":\"Americas\",\"max\":72} ,{\"region\":\"Asia\",\"max\":48} ,{\"region\":\"Europe\",\"max\":78} ,{\"region\":\"Oceania\",\"max\":15.2} ,{\"region\":\"Polar\",\"max\":-74.65} ] Countries.map(p=> {region:p.region,min:min(p.latitude)}) [{\"region\":\"\",\"min\":-54.4333} ,{\"region\":\"Africa\",\"min\":-49.25} ,{\"region\":\"Americas\",\"min\":-54.5} ,{\"region\":\"Asia\",\"min\":-8.8333} ,{\"region\":\"Europe\",\"min\":35} ,{\"region\":\"Oceania\",\"min\":-41} ,{\"region\":\"Polar\",\"min\":-74.65} ] Countries.map(p=> {region:p.region,avg:avg(p.latitude)}) [{\"region\":\"\",\"avg\":-53.76665} ,{\"region\":\"Africa\",\"avg\":1.283335} ,{\"region\":\"Americas\",\"avg\":10.42610526} ,{\"region\":\"Asia\",\"avg\":25.822002} ,{\"region\":\"Europe\",\"avg\":49.35021321} ,{\"region\":\"Oceania\",\"avg\":-10.93023704} ,{\"region\":\"Polar\",\"avg\":-74.65} ] Sentences Lambda: Query to get the count of countries in the Americas region Countries.filter(p=> p.region == \"Americas\").map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE c.region = 'Americas' Lambda: Query to get the count of countries in each region Countries.map(p=> {region:p.region,countries:count(1)}) SQL Result: SELECT c.region AS region, COUNT(1) AS countries FROM Countries c GROUP BY c.region Lambda: Query to get the maximum latitude of countries in each region Countries.map(p=> {region:p.region,max:max(p.latitude)}) SQL Result: SELECT c.region AS region, MAX(c.latitude) AS max FROM Countries c GROUP BY c.region Lambda: Query to get the minimum latitude of countries in each region Countries.map(p=> {region:p.region,min:min(p.latitude)}) SQL Result: SELECT c.region AS region, MIN(c.latitude) AS min FROM Countries c GROUP BY c.region Lambda: Query to get the average latitude of countries in each region Countries.map(p=> {region:p.region,avg:avg(p.latitude)}) SQL Result: SELECT c.region AS region, AVG(c.latitude) AS avg FROM Countries c GROUP BY c.region Definition avg description: Calculates the average of the specified columns in a set of rows deterministic: true return: number params: value: number count description: Calculating the number of rows in a set. deterministic: true return: number params: value: any first description: Returns the first value of the selected column deterministic: true return: T params: value: T last description: Returns the last value of the selected column. deterministic: true return: T params: value: T max description: Calculating the maximum. deterministic: true return: T params: value: T min description: Calculating the minimum. deterministic: true return: T params: value: T sum description: Calculating the sum. deterministic: true return: number params: value: number","title":"Group"},{"location":"queries/operatorsAndFunctions/Group/#examples","text":"Countries.filter(p=> p.region == \"Americas\").map(p=> {result:count(1)}) [{\"result\":57}] Countries.map(p=> {region:p.region,countries:count(1)})| [{\"region\":\"\",\"countries\":2} ,{\"region\":\"Africa\",\"countries\":60} ,{\"region\":\"Americas\",\"countries\":57} ,{\"region\":\"Asia\",\"countries\":50} ,{\"region\":\"Europe\",\"countries\":53} ,{\"region\":\"Oceania\",\"countries\":27} ,{\"region\":\"Polar\",\"countries\":1} ] Countries.map(p=> {region:p.region,max:max(p.latitude)}) [{\"region\":\"\",\"max\":-53.1} ,{\"region\":\"Africa\",\"max\":34} ,{\"region\":\"Americas\",\"max\":72} ,{\"region\":\"Asia\",\"max\":48} ,{\"region\":\"Europe\",\"max\":78} ,{\"region\":\"Oceania\",\"max\":15.2} ,{\"region\":\"Polar\",\"max\":-74.65} ] Countries.map(p=> {region:p.region,min:min(p.latitude)}) [{\"region\":\"\",\"min\":-54.4333} ,{\"region\":\"Africa\",\"min\":-49.25} ,{\"region\":\"Americas\",\"min\":-54.5} ,{\"region\":\"Asia\",\"min\":-8.8333} ,{\"region\":\"Europe\",\"min\":35} ,{\"region\":\"Oceania\",\"min\":-41} ,{\"region\":\"Polar\",\"min\":-74.65} ] Countries.map(p=> {region:p.region,avg:avg(p.latitude)}) [{\"region\":\"\",\"avg\":-53.76665} ,{\"region\":\"Africa\",\"avg\":1.283335} ,{\"region\":\"Americas\",\"avg\":10.42610526} ,{\"region\":\"Asia\",\"avg\":25.822002} ,{\"region\":\"Europe\",\"avg\":49.35021321} ,{\"region\":\"Oceania\",\"avg\":-10.93023704} ,{\"region\":\"Polar\",\"avg\":-74.65} ]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Group/#sentences","text":"Lambda: Query to get the count of countries in the Americas region Countries.filter(p=> p.region == \"Americas\").map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE c.region = 'Americas' Lambda: Query to get the count of countries in each region Countries.map(p=> {region:p.region,countries:count(1)}) SQL Result: SELECT c.region AS region, COUNT(1) AS countries FROM Countries c GROUP BY c.region Lambda: Query to get the maximum latitude of countries in each region Countries.map(p=> {region:p.region,max:max(p.latitude)}) SQL Result: SELECT c.region AS region, MAX(c.latitude) AS max FROM Countries c GROUP BY c.region Lambda: Query to get the minimum latitude of countries in each region Countries.map(p=> {region:p.region,min:min(p.latitude)}) SQL Result: SELECT c.region AS region, MIN(c.latitude) AS min FROM Countries c GROUP BY c.region Lambda: Query to get the average latitude of countries in each region Countries.map(p=> {region:p.region,avg:avg(p.latitude)}) SQL Result: SELECT c.region AS region, AVG(c.latitude) AS avg FROM Countries c GROUP BY c.region","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Group/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Group/#avg","text":"description: Calculates the average of the specified columns in a set of rows deterministic: true return: number params: value: number","title":"avg"},{"location":"queries/operatorsAndFunctions/Group/#count","text":"description: Calculating the number of rows in a set. deterministic: true return: number params: value: any","title":"count"},{"location":"queries/operatorsAndFunctions/Group/#first","text":"description: Returns the first value of the selected column deterministic: true return: T params: value: T","title":"first"},{"location":"queries/operatorsAndFunctions/Group/#last","text":"description: Returns the last value of the selected column. deterministic: true return: T params: value: T","title":"last"},{"location":"queries/operatorsAndFunctions/Group/#max","text":"description: Calculating the maximum. deterministic: true return: T params: value: T","title":"max"},{"location":"queries/operatorsAndFunctions/Group/#min","text":"description: Calculating the minimum. deterministic: true return: T params: value: T","title":"min"},{"location":"queries/operatorsAndFunctions/Group/#sum","text":"description: Calculating the sum. deterministic: true return: number params: value: number","title":"sum"},{"location":"queries/operatorsAndFunctions/Logical/","text":"Operator Description ! not && and || or Examples Example Result Countries.filter(p=> p.subregion == \"South America\" && p.longitude < -30 ).map(p=> {result:count(1)}) [{\"result\":15}] Countries.filter(p=> p.subregion == \"South America\" Countries.filter(p=> p.region == \"Americas\" && p.subregion != \"Northern America\" ).map(p=> {result:count(1)}) [{\"result\":51}] Sentences Lambda: Query to get the count of countries in the Americas region Countries.filter(p=> p.subregion == \"South America\" && p.longitude < -30 ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.subregion = 'South America' AND c.longitude < -30) Lambda: Query to get the count of countries in each region Countries.filter(p=> p.subregion == \"South America\" || p.subregion == \"Central America\" ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.subregion = 'South America' OR c.subregion = 'Central America') Lambda: Query to get the maximum latitude of countries in each region Countries.filter(p=> p.region == \"Americas\" && p.subregion != \"Northern America\" ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.region = 'Americas' AND c.subregion <> 'Northern America') Definition Operator ! description: not return: boolean params: value: boolean Operator && description: and return: boolean params: a: boolean b: boolean Operator || description: or return: boolean params: a: boolean b: boolean","title":"Logical"},{"location":"queries/operatorsAndFunctions/Logical/#examples","text":"Example Result Countries.filter(p=> p.subregion == \"South America\" && p.longitude < -30 ).map(p=> {result:count(1)}) [{\"result\":15}] Countries.filter(p=> p.subregion == \"South America\" Countries.filter(p=> p.region == \"Americas\" && p.subregion != \"Northern America\" ).map(p=> {result:count(1)}) [{\"result\":51}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Logical/#sentences","text":"Lambda: Query to get the count of countries in the Americas region Countries.filter(p=> p.subregion == \"South America\" && p.longitude < -30 ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.subregion = 'South America' AND c.longitude < -30) Lambda: Query to get the count of countries in each region Countries.filter(p=> p.subregion == \"South America\" || p.subregion == \"Central America\" ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.subregion = 'South America' OR c.subregion = 'Central America') Lambda: Query to get the maximum latitude of countries in each region Countries.filter(p=> p.region == \"Americas\" && p.subregion != \"Northern America\" ).map(p=> {result:count(1)}) SQL Result: SELECT COUNT(1) AS result FROM Countries c WHERE (c.region = 'Americas' AND c.subregion <> 'Northern America')","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Logical/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Logical/#operator","text":"description: not return: boolean params: value: boolean","title":"Operator !"},{"location":"queries/operatorsAndFunctions/Logical/#operator_1","text":"description: and return: boolean params: a: boolean b: boolean","title":"Operator &amp;&amp;"},{"location":"queries/operatorsAndFunctions/Logical/#operator_2","text":"description: or return: boolean params: a: boolean b: boolean","title":"Operator ||"},{"location":"queries/operatorsAndFunctions/Nullable/","text":"Function Description nvl Allows you to replace null values with a default value. nvl2 It lets you substitutes a value when a null value is encountered as well as when a non-null value is encountered. isNull Evaluate if it is null isNotNull Evaluate if it is not null Examples Example Result States.filter(p=> isNull(p.latitude)).map(p=> count(1)) [{\"count\":68}] States.filter(p=> isNotNull(p.latitude)).map(p=> count(1)) [{\"count\":4813}] States.filter(p=> nvl(p.latitude,-100)== -100).map(p=> count(1)) [{\"count\":68}] Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl(p.native,\"???\")}) [{\"native\":\"???\"}] Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl2(p.native,\"is not null\",\"is null\")}) [{\"native\":\"is null\"}] Sentences Lambda: Query to get the count of countries in the Americas region where the latitude is null States.filter(p=> isNull(p.latitude)).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (s.LATITUDE IS NULL) Lambda: Query to get the count of countries in the Americas region where the latitude is not null States.filter(p=> isNotNull(p.latitude)).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (s.LATITUDE IS NOT NULL) Lambda: Query to get the count of countries in the Americas region where the latitude is null or -100 States.filter(p=> nvl(p.latitude,-100)== -100).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (CASE WHEN s.LATITUDE IS NOT NULL THEN s.LATITUDE ELSE -100 END) = -100 Lambda: Query to get the native name or \"???\" if it is null the country with iso3 code \"CIV\" Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl(p.native,\"???\")}) SQL Result: SELECT IFNULL(c.native,'???') AS native FROM Countries c WHERE c.iso3 = 'CIV' Lambda: Query to get the native name or \"is null\" if it is null the country with iso3 code \"CIV\" Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl2(p.native,\"is not null\",\"is null\")}) SQL Result: SELECT (CASE WHEN c.native IS NOT NULL THEN 'is not null' ELSE 'is null' END) AS native FROM Countries c WHERE c.iso3 = 'CIV' Definition nvl description: Allows you to replace null values with a default value. deterministic: true return: T params: value: T _default: T nvl2 description: Extends the functionality found in the NVL function. It lets you substitutes a value when a null value is encountered as well as when a non-null value is encountered. deterministic: true return: T params: value: T a: T b: T isNull description: Evaluate if it is null deterministic: true return: boolean params: value: any isNotNull description: Evaluate if it is not null deterministic: true return: boolean params: value: any","title":"Nullable"},{"location":"queries/operatorsAndFunctions/Nullable/#examples","text":"Example Result States.filter(p=> isNull(p.latitude)).map(p=> count(1)) [{\"count\":68}] States.filter(p=> isNotNull(p.latitude)).map(p=> count(1)) [{\"count\":4813}] States.filter(p=> nvl(p.latitude,-100)== -100).map(p=> count(1)) [{\"count\":68}] Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl(p.native,\"???\")}) [{\"native\":\"???\"}] Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl2(p.native,\"is not null\",\"is null\")}) [{\"native\":\"is null\"}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Nullable/#sentences","text":"Lambda: Query to get the count of countries in the Americas region where the latitude is null States.filter(p=> isNull(p.latitude)).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (s.LATITUDE IS NULL) Lambda: Query to get the count of countries in the Americas region where the latitude is not null States.filter(p=> isNotNull(p.latitude)).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (s.LATITUDE IS NOT NULL) Lambda: Query to get the count of countries in the Americas region where the latitude is null or -100 States.filter(p=> nvl(p.latitude,-100)== -100).map(p=> count(1)) SQL Result: SELECT COUNT(1) FROM TBL_STATES s WHERE (CASE WHEN s.LATITUDE IS NOT NULL THEN s.LATITUDE ELSE -100 END) = -100 Lambda: Query to get the native name or \"???\" if it is null the country with iso3 code \"CIV\" Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl(p.native,\"???\")}) SQL Result: SELECT IFNULL(c.native,'???') AS native FROM Countries c WHERE c.iso3 = 'CIV' Lambda: Query to get the native name or \"is null\" if it is null the country with iso3 code \"CIV\" Countries.filter(p=> p.iso3 == \"CIV\" ).map(p=> {native: nvl2(p.native,\"is not null\",\"is null\")}) SQL Result: SELECT (CASE WHEN c.native IS NOT NULL THEN 'is not null' ELSE 'is null' END) AS native FROM Countries c WHERE c.iso3 = 'CIV'","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Nullable/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Nullable/#nvl","text":"description: Allows you to replace null values with a default value. deterministic: true return: T params: value: T _default: T","title":"nvl"},{"location":"queries/operatorsAndFunctions/Nullable/#nvl2","text":"description: Extends the functionality found in the NVL function. It lets you substitutes a value when a null value is encountered as well as when a non-null value is encountered. deterministic: true return: T params: value: T a: T b: T","title":"nvl2"},{"location":"queries/operatorsAndFunctions/Nullable/#isnull","text":"description: Evaluate if it is null deterministic: true return: boolean params: value: any","title":"isNull"},{"location":"queries/operatorsAndFunctions/Nullable/#isnotnull","text":"description: Evaluate if it is not null deterministic: true return: boolean params: value: any","title":"isNotNull"},{"location":"queries/operatorsAndFunctions/Numeric/","text":"Operator Description - negative /subtraction + addition * multiplication / division ** exponentiation // floorDivision % mod Function Description abs Get the absolute value acos Get the arc cosine asin Get the arc sine atan Get the arc tangent atan2 Get the arc tangent of x and y ceil Get the smallest following integer cos Get the cosine cosh Get hyperbolic cosine exp Raise e to the nth power floor Get the largest preceding integer ln Get natural logarithm of num log Get logarithm, base num1, of num2 log10 Return the base 10 logarithm of x remainder Get remainder round Get rounded value sign Get sign of exp sin Get sine sinh Get hyperbolic sine tan Get tangent tanh Get hyperbolic tangent trunc Truncate num toNumber convert to number Examples Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3+2-1 }) [{\"result\":4}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3*4-1}) [{\"result\":11}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1-2-5}) [{\"result\":-6}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (2+3)*2}) [{\"result\":10}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 2*(3+2)}) [{\"result\":10}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2 3 4}) [{\"result\":25}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (1+(2* 3) 4)}) [{\"result\":33}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2* (3 4)}) [{\"result\":4097}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: abs(-9)}) [{\"result\":9}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: acos(0.434)}) [{\"result\":1.121868332427735}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: asin(0.434)}) [{\"result\":0.44892799436716174}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan(2)}) [{\"result\":1.1071487177940904}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan2(90, 15)}) [{\"result\":1.4056476493802699}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ceil(2)}) [{\"result\":2}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cos(2)}) [{\"result\":-0.4161468365471424}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cosh(2)}) [{\"result\":3.7621956910836314}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: exp(7)}) [{\"result\":1096.6331584284585}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: floor(7)}) [{\"result\":7}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ln(7)}) [{\"result\":1.9459101490553132}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log(7,10)}) [{\"result\":1.1832946624549385}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log10(7)}) [{\"result\":0.8450980400142568}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: remainder(7,2)}) [{\"result\":-1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: round(7.984938,2)}) [{\"result\":7.98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sign(-7)}) [{\"result\":-1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sin(7)}) [{\"result\":0.6569865987187891}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sinh(7)}) [{\"result\":548.3161232732465}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tan(7)}) [{\"result\":0.8714479827243188}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tanh(7)}) [{\"result\":0.9999983369439447}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: trunc(7.984938,2)}) [{\"result\":7.98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toNumber(\"3.141516\")}) [{\"result\":3}] Sentences Lambda: Query to get the result of 3+2-1 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3+2-1 }) SQL Result: SELECT ((3 + 2) - 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 3*4-1 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3*4-1}) SQL Result: SELECT ((3 * 4) - 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1-2-5 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1-2-5}) SQL Result: SELECT ((1 - 2) - 5) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of (2+3)*2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (2+3)*2}) SQL Result: SELECT ((2 + 3) * 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 2*(3+2) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 2*(3+2)}) SQL Result: SELECT (2 * (3 + 2)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1+2 3 4 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2*3*4}) SQL Result: SELECT (1 + ((2 * 3) * 4)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of (1+(2* 3) 4) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (1+(2**3)*4)}) SQL Result: SELECT (1 + (POWER(2,3) * 4)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1+2* (3 4) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2**(3*4)}) SQL Result: SELECT (1 + POWER(2,(3 * 4))) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the absolute value of -9 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: abs(-9)}) SQL Result: SELECT ABS(-9) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc cosine of 0.434 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: acos(0.434)}) SQL Result: SELECT ACOS(0.434) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc sine of 0.434 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: asin(0.434)}) SQL Result: SELECT ASIN(0.434) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc tangent of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan(2)}) SQL Result: SELECT ATAN(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc tangent of 90 and 15 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan2(90, 15)}) SQL Result: SELECT ATAN(90,15) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the smallest following integer of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ceil(2)}) SQL Result: SELECT CEIL(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the cosine of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cos(2)}) SQL Result: SELECT COS(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic cosine of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cosh(2)}) SQL Result: SELECT ((EXP(2) + EXP(-2)) / 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get e to the nth power of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: exp(7)}) SQL Result: SELECT EXP(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the largest preceding integer of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: floor(7)}) SQL Result: SELECT FLOOR(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the natural logarithm of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ln(7)}) SQL Result: SELECT LN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the logarithm, base 7, of 10 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log(7,10)}) SQL Result: SELECT LOG(7,10) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the base 10 logarithm of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log10(7)}) SQL Result: SELECT LOG10(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the remainder of 7 and 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: remainder(7,2)}) SQL Result: SELECT (7 - 2*ROUND(7/2)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the rounded value of 7.984938 with 2 decimals Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: round(7.984938,2)}) SQL Result: SELECT ROUND(7.984938,2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the sign of -7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sign(-7)}) SQL Result: SELECT SIGN(-7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the sine of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sin(7)}) SQL Result: SELECT SIN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic sine of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sinh(7)}) SQL Result: SELECT ((EXP(7) - EXP(-7)) / 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the tangent of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tan(7)}) SQL Result: SELECT TAN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic tangent of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tanh(7)}) SQL Result: SELECT (EXP(2*7) - 1)/(EXP(2*7) + 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the truncated value of 7.984938 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: trunc(7.984938,2)}) SQL Result: SELECT TRUNCATE(7.984938,2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to convert the string \"3.141516\" to number Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toNumber(\"3.141516\")}) SQL Result: SELECT CONVERT('3.141516', DECIMAL) AS result FROM Countries c WHERE c.iso3 = 'BRA' Definition Operator - Negative: description: negative return: number params: value: number Subtraction: description: subtraction return: number params: a: number b: number Operator + description: addition return: number params: a: number b: number Operator * description: multiplication return: number params: a: number b: number Operator / description: division return: number params: a: number b: number Operator ** description: exponentiation return: number params: a: number b: number Operator // description: floorDivision return: number params: a: number b: number Operator % description: mod return: number params: a: number b: number abs description: Get the absolute value deterministic: true return: number params: value: number acos description: Get the arc cosine deterministic: true return: number params: value: number asin description: Get the arc sine deterministic: true return: number params: value: number atan description: Get the arc tangent deterministic: true return: number params: value: number atan2 description: Get the arc tangent of x and y deterministic: true return: number params: x: number y: number ceil description: Get the smallest following integer deterministic: true return: number params: value: number cos description: Get the cosine deterministic: true return: number params: value: number cosh description: Get hyperbolic cosine deterministic: true return: number params: value: number exp description: Raise e to the nth power deterministic: true return: number params: value: number floor description: Get the largest preceding integer deterministic: true return: number params: value: number ln description: Get natural logarithm of num deterministic: true return: number params: value: number log description: Get logarithm, base num1, of num2 deterministic: true return: number params: n1: number n2: number log10 description: Return the base 10 logarithm of x deterministic: true return: number params: value: number remainder description: Get remainder deterministic: true return: number params: n1: number n2: number round description: Get rounded value deterministic: true return: number params: value: number decimals: number sign description: Get sign of exp deterministic: true return: number params: value: number sin description: Get sine deterministic: true return: number params: value: number sinh description: Get hyperbolic sine deterministic: true return: number params: value: number tan description: Get tangent deterministic: true return: number params: value: number tanh description: Get hyperbolic tangent deterministic: true return: number params: value: number trunc description: Truncate num deterministic: true return: number params: value: number toNumber description: convert to number deterministic: true return: number params: value: string","title":"Numeric"},{"location":"queries/operatorsAndFunctions/Numeric/#examples","text":"Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3+2-1 }) [{\"result\":4}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3*4-1}) [{\"result\":11}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1-2-5}) [{\"result\":-6}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (2+3)*2}) [{\"result\":10}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 2*(3+2)}) [{\"result\":10}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2 3 4}) [{\"result\":25}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (1+(2* 3) 4)}) [{\"result\":33}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2* (3 4)}) [{\"result\":4097}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: abs(-9)}) [{\"result\":9}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: acos(0.434)}) [{\"result\":1.121868332427735}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: asin(0.434)}) [{\"result\":0.44892799436716174}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan(2)}) [{\"result\":1.1071487177940904}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan2(90, 15)}) [{\"result\":1.4056476493802699}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ceil(2)}) [{\"result\":2}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cos(2)}) [{\"result\":-0.4161468365471424}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cosh(2)}) [{\"result\":3.7621956910836314}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: exp(7)}) [{\"result\":1096.6331584284585}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: floor(7)}) [{\"result\":7}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ln(7)}) [{\"result\":1.9459101490553132}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log(7,10)}) [{\"result\":1.1832946624549385}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log10(7)}) [{\"result\":0.8450980400142568}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: remainder(7,2)}) [{\"result\":-1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: round(7.984938,2)}) [{\"result\":7.98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sign(-7)}) [{\"result\":-1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sin(7)}) [{\"result\":0.6569865987187891}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sinh(7)}) [{\"result\":548.3161232732465}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tan(7)}) [{\"result\":0.8714479827243188}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tanh(7)}) [{\"result\":0.9999983369439447}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: trunc(7.984938,2)}) [{\"result\":7.98}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toNumber(\"3.141516\")}) [{\"result\":3}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Numeric/#sentences","text":"Lambda: Query to get the result of 3+2-1 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3+2-1 }) SQL Result: SELECT ((3 + 2) - 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 3*4-1 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 3*4-1}) SQL Result: SELECT ((3 * 4) - 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1-2-5 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1-2-5}) SQL Result: SELECT ((1 - 2) - 5) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of (2+3)*2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (2+3)*2}) SQL Result: SELECT ((2 + 3) * 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 2*(3+2) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 2*(3+2)}) SQL Result: SELECT (2 * (3 + 2)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1+2 3 4 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2*3*4}) SQL Result: SELECT (1 + ((2 * 3) * 4)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of (1+(2* 3) 4) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: (1+(2**3)*4)}) SQL Result: SELECT (1 + (POWER(2,3) * 4)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the result of 1+2* (3 4) Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: 1+2**(3*4)}) SQL Result: SELECT (1 + POWER(2,(3 * 4))) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the absolute value of -9 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: abs(-9)}) SQL Result: SELECT ABS(-9) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc cosine of 0.434 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: acos(0.434)}) SQL Result: SELECT ACOS(0.434) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc sine of 0.434 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: asin(0.434)}) SQL Result: SELECT ASIN(0.434) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc tangent of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan(2)}) SQL Result: SELECT ATAN(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the arc tangent of 90 and 15 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: atan2(90, 15)}) SQL Result: SELECT ATAN(90,15) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the smallest following integer of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ceil(2)}) SQL Result: SELECT CEIL(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the cosine of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cos(2)}) SQL Result: SELECT COS(2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic cosine of 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: cosh(2)}) SQL Result: SELECT ((EXP(2) + EXP(-2)) / 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get e to the nth power of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: exp(7)}) SQL Result: SELECT EXP(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the largest preceding integer of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: floor(7)}) SQL Result: SELECT FLOOR(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the natural logarithm of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ln(7)}) SQL Result: SELECT LN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the logarithm, base 7, of 10 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log(7,10)}) SQL Result: SELECT LOG(7,10) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the base 10 logarithm of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: log10(7)}) SQL Result: SELECT LOG10(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the remainder of 7 and 2 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: remainder(7,2)}) SQL Result: SELECT (7 - 2*ROUND(7/2)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the rounded value of 7.984938 with 2 decimals Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: round(7.984938,2)}) SQL Result: SELECT ROUND(7.984938,2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the sign of -7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sign(-7)}) SQL Result: SELECT SIGN(-7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the sine of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sin(7)}) SQL Result: SELECT SIN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic sine of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: sinh(7)}) SQL Result: SELECT ((EXP(7) - EXP(-7)) / 2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the tangent of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tan(7)}) SQL Result: SELECT TAN(7) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the hyperbolic tangent of 7 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: tanh(7)}) SQL Result: SELECT (EXP(2*7) - 1)/(EXP(2*7) + 1) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the truncated value of 7.984938 Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: trunc(7.984938,2)}) SQL Result: SELECT TRUNCATE(7.984938,2) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to convert the string \"3.141516\" to number Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toNumber(\"3.141516\")}) SQL Result: SELECT CONVERT('3.141516', DECIMAL) AS result FROM Countries c WHERE c.iso3 = 'BRA'","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Numeric/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Numeric/#operator-","text":"Negative: description: negative return: number params: value: number Subtraction: description: subtraction return: number params: a: number b: number","title":"Operator -"},{"location":"queries/operatorsAndFunctions/Numeric/#operator","text":"description: addition return: number params: a: number b: number","title":"Operator +"},{"location":"queries/operatorsAndFunctions/Numeric/#operator_1","text":"description: multiplication return: number params: a: number b: number","title":"Operator *"},{"location":"queries/operatorsAndFunctions/Numeric/#operator_2","text":"description: division return: number params: a: number b: number","title":"Operator /"},{"location":"queries/operatorsAndFunctions/Numeric/#operator_3","text":"description: exponentiation return: number params: a: number b: number","title":"Operator **"},{"location":"queries/operatorsAndFunctions/Numeric/#operator_4","text":"description: floorDivision return: number params: a: number b: number","title":"Operator //"},{"location":"queries/operatorsAndFunctions/Numeric/#operator_5","text":"description: mod return: number params: a: number b: number","title":"Operator %"},{"location":"queries/operatorsAndFunctions/Numeric/#abs","text":"description: Get the absolute value deterministic: true return: number params: value: number","title":"abs"},{"location":"queries/operatorsAndFunctions/Numeric/#acos","text":"description: Get the arc cosine deterministic: true return: number params: value: number","title":"acos"},{"location":"queries/operatorsAndFunctions/Numeric/#asin","text":"description: Get the arc sine deterministic: true return: number params: value: number","title":"asin"},{"location":"queries/operatorsAndFunctions/Numeric/#atan","text":"description: Get the arc tangent deterministic: true return: number params: value: number","title":"atan"},{"location":"queries/operatorsAndFunctions/Numeric/#atan2","text":"description: Get the arc tangent of x and y deterministic: true return: number params: x: number y: number","title":"atan2"},{"location":"queries/operatorsAndFunctions/Numeric/#ceil","text":"description: Get the smallest following integer deterministic: true return: number params: value: number","title":"ceil"},{"location":"queries/operatorsAndFunctions/Numeric/#cos","text":"description: Get the cosine deterministic: true return: number params: value: number","title":"cos"},{"location":"queries/operatorsAndFunctions/Numeric/#cosh","text":"description: Get hyperbolic cosine deterministic: true return: number params: value: number","title":"cosh"},{"location":"queries/operatorsAndFunctions/Numeric/#exp","text":"description: Raise e to the nth power deterministic: true return: number params: value: number","title":"exp"},{"location":"queries/operatorsAndFunctions/Numeric/#floor","text":"description: Get the largest preceding integer deterministic: true return: number params: value: number","title":"floor"},{"location":"queries/operatorsAndFunctions/Numeric/#ln","text":"description: Get natural logarithm of num deterministic: true return: number params: value: number","title":"ln"},{"location":"queries/operatorsAndFunctions/Numeric/#log","text":"description: Get logarithm, base num1, of num2 deterministic: true return: number params: n1: number n2: number","title":"log"},{"location":"queries/operatorsAndFunctions/Numeric/#log10","text":"description: Return the base 10 logarithm of x deterministic: true return: number params: value: number","title":"log10"},{"location":"queries/operatorsAndFunctions/Numeric/#remainder","text":"description: Get remainder deterministic: true return: number params: n1: number n2: number","title":"remainder"},{"location":"queries/operatorsAndFunctions/Numeric/#round","text":"description: Get rounded value deterministic: true return: number params: value: number decimals: number","title":"round"},{"location":"queries/operatorsAndFunctions/Numeric/#sign","text":"description: Get sign of exp deterministic: true return: number params: value: number","title":"sign"},{"location":"queries/operatorsAndFunctions/Numeric/#sin","text":"description: Get sine deterministic: true return: number params: value: number","title":"sin"},{"location":"queries/operatorsAndFunctions/Numeric/#sinh","text":"description: Get hyperbolic sine deterministic: true return: number params: value: number","title":"sinh"},{"location":"queries/operatorsAndFunctions/Numeric/#tan","text":"description: Get tangent deterministic: true return: number params: value: number","title":"tan"},{"location":"queries/operatorsAndFunctions/Numeric/#tanh","text":"description: Get hyperbolic tangent deterministic: true return: number params: value: number","title":"tanh"},{"location":"queries/operatorsAndFunctions/Numeric/#trunc","text":"description: Truncate num deterministic: true return: number params: value: number","title":"trunc"},{"location":"queries/operatorsAndFunctions/Numeric/#tonumber","text":"description: convert to number deterministic: true return: number params: value: string","title":"toNumber"},{"location":"queries/operatorsAndFunctions/Sort/","text":"Function Description desc This statement is used to sort data in descending order asc This statement is used to sort data in ascending order Examples Countries.map(p=> {region:p.region,countries:count(1)}).sort(p=> p.countries) [{\"region\":\"Polar\",\"countries\":1} ,{\"region\":\"\",\"countries\":2} ,{\"region\":\"Oceania\",\"countries\":27} ,{\"region\":\"Asia\",\"countries\":50} ,{\"region\":\"Europe\",\"countries\":53} ,{\"region\":\"Americas\",\"countries\":57} ,{\"region\":\"Africa\",\"countries\":60} ] Countries.filter(p=> p.subregion == \"South America\").map(p=> p.iso3).sort(p=> desc(iso3)) [{\"iso3\":\"ARG\"} ,{\"iso3\":\"BOL\"} ,{\"iso3\":\"BRA\"} ,{\"iso3\":\"CHL\"} ,{\"iso3\":\"COL\"} ,{\"iso3\":\"ECU\"} ,{\"iso3\":\"FLK\"} ,{\"iso3\":\"GUF\"} ,{\"iso3\":\"GUY\"} ,{\"iso3\":\"PER\"} ,{\"iso3\":\"PRY\"} ,{\"iso3\":\"SGS\"} ,{\"iso3\":\"SUR\"} ,{\"iso3\":\"URY\"} ,{\"iso3\":\"VEN\"} ] Countries.map(p=> {region:p.region,max:max(p.latitude)}).sort(p=> asc(p.max)) [{\"region\":\"Polar\",\"max\":-74.65} ,{\"region\":\"\",\"max\":-53.1} ,{\"region\":\"Oceania\",\"max\":15.2} ,{\"region\":\"Africa\",\"max\":34} ,{\"region\":\"Asia\",\"max\":48} ,{\"region\":\"Americas\",\"max\":72} ,{\"region\":\"Europe\",\"max\":78} ] Sentences Lambda: Query to get the count of countries in each region Countries.map(p=> {region:p.region,countries:count(1)}).sort(p=> p.countries) SQL Result: SELECT c.region AS region, COUNT(1) AS countries FROM Countries c GROUP BY c.region ORDER BY countries asc Lambda: Query to get the iso3 codes of countries in the South America subregion in descending order Countries.filter(p=> p.subregion == \"South America\").map(p=> p.iso3).sort(p=> desc(iso3)) SQL Result: SELECT c.iso3 AS iso3 FROM Countries c WHERE c.subregion = 'South America' ORDER BY ? desc Lambda: Query to get the maximum latitude of countries in each region Countries.map(p=> {region:p.region,max:max(p.latitude)}).sort(p=> asc(p.max)) SQL Result: SELECT c.region AS region, MAX(c.latitude) AS max FROM Countries c GROUP BY c.region ORDER BY max asc Definition desc description: This statement is used to sort data in descending order deterministic: true return: void params: value: any asc description: This statement is used to sort data in ascending order. deterministic: true return: void params: value: any","title":"Sort"},{"location":"queries/operatorsAndFunctions/Sort/#examples","text":"Countries.map(p=> {region:p.region,countries:count(1)}).sort(p=> p.countries) [{\"region\":\"Polar\",\"countries\":1} ,{\"region\":\"\",\"countries\":2} ,{\"region\":\"Oceania\",\"countries\":27} ,{\"region\":\"Asia\",\"countries\":50} ,{\"region\":\"Europe\",\"countries\":53} ,{\"region\":\"Americas\",\"countries\":57} ,{\"region\":\"Africa\",\"countries\":60} ] Countries.filter(p=> p.subregion == \"South America\").map(p=> p.iso3).sort(p=> desc(iso3)) [{\"iso3\":\"ARG\"} ,{\"iso3\":\"BOL\"} ,{\"iso3\":\"BRA\"} ,{\"iso3\":\"CHL\"} ,{\"iso3\":\"COL\"} ,{\"iso3\":\"ECU\"} ,{\"iso3\":\"FLK\"} ,{\"iso3\":\"GUF\"} ,{\"iso3\":\"GUY\"} ,{\"iso3\":\"PER\"} ,{\"iso3\":\"PRY\"} ,{\"iso3\":\"SGS\"} ,{\"iso3\":\"SUR\"} ,{\"iso3\":\"URY\"} ,{\"iso3\":\"VEN\"} ] Countries.map(p=> {region:p.region,max:max(p.latitude)}).sort(p=> asc(p.max)) [{\"region\":\"Polar\",\"max\":-74.65} ,{\"region\":\"\",\"max\":-53.1} ,{\"region\":\"Oceania\",\"max\":15.2} ,{\"region\":\"Africa\",\"max\":34} ,{\"region\":\"Asia\",\"max\":48} ,{\"region\":\"Americas\",\"max\":72} ,{\"region\":\"Europe\",\"max\":78} ]","title":"Examples"},{"location":"queries/operatorsAndFunctions/Sort/#sentences","text":"Lambda: Query to get the count of countries in each region Countries.map(p=> {region:p.region,countries:count(1)}).sort(p=> p.countries) SQL Result: SELECT c.region AS region, COUNT(1) AS countries FROM Countries c GROUP BY c.region ORDER BY countries asc Lambda: Query to get the iso3 codes of countries in the South America subregion in descending order Countries.filter(p=> p.subregion == \"South America\").map(p=> p.iso3).sort(p=> desc(iso3)) SQL Result: SELECT c.iso3 AS iso3 FROM Countries c WHERE c.subregion = 'South America' ORDER BY ? desc Lambda: Query to get the maximum latitude of countries in each region Countries.map(p=> {region:p.region,max:max(p.latitude)}).sort(p=> asc(p.max)) SQL Result: SELECT c.region AS region, MAX(c.latitude) AS max FROM Countries c GROUP BY c.region ORDER BY max asc","title":"Sentences"},{"location":"queries/operatorsAndFunctions/Sort/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/Sort/#desc","text":"description: This statement is used to sort data in descending order deterministic: true return: void params: value: any","title":"desc"},{"location":"queries/operatorsAndFunctions/Sort/#asc","text":"description: This statement is used to sort data in ascending order. deterministic: true return: void params: value: any","title":"asc"},{"location":"queries/operatorsAndFunctions/String/","text":"Function Description chr Get character from ASCII code concat String concatenation lower Lowercase string lpad Pad the left-side of string ltrim Remove leading chars replace Searches a string for a specified value and returns a new string where the specified values are replaced match Returns an array containing all matches, including capturing groups, or null if no matches are found mask General-purpose function that mask parts of arbitrary strings based on position within the string rpad Pad the right-side of string rtrim Remove trailing spaces substr substring Get a substring of string trim Remove characters upper Uppercase string strCount Count value in source isEmpty Evaluate if it is empty toString Convert to string Examples Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lower(p.subregion) }) [{\"result\":\"south america\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: upper(p.subregion) }) [{\"result\":\"SOUTH AMERICA\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: concat(p.region,\" \",p.subregion) }) [{\"result\":\"Americas South America\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lpad(p.region,12,\"_\") }) [{\"result\":\"____Americas\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rpad(p.region,12,\"_\") }) [{\"result\":\"Americas____\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: chr(68)}) [{\"result\":\"D\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ltrim(\" a \")}) [{\"result\":\"a \"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rtrim(\" a \")}) [{\"result\":\" a\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: replace(p.region,\"a\",\"*\")}) [{\"result\":\"Americ*s\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: mask(p.subregion)}) [{\"result\":\"Sou***ica\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substr(p.subregion,1,3)}) [{\"result\":\"Sou\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substring(p.subregion,1,3)}) [{\"result\":\"Sou\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: strCount(p.subregion,\"a\")}) [{\"result\":1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toString(p.latitude)}) [{\"result\":\"-10.0000\"}] Sentences Lambda: Query to get the subregion in lowercase for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lower(p.subregion) }) SQL Result: SELECT LOWER(c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion in uppercase for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: upper(p.subregion) }) SQL Result: SELECT UPPER(c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region and subregion concatenated for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: concat(p.region,\" \",p.subregion) }) SQL Result: SELECT CONCAT(CONCAT(c.region,' '),c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region left-padded with \"_\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lpad(p.region,12,\"_\") }) SQL Result: SELECT LPAD(c.region,12,'_') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region right-padded with \"_\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rpad(p.region,12,\"_\") }) SQL Result: SELECT RPAD(c.region,12,'_') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the character \"D\" from ASCII code 68 for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: chr(68)}) SQL Result: SELECT CHAR(68 USING ASCII) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion with leading spaces removed for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ltrim(\" a \")}) SQL Result: SELECT LTRIM(' a ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion with trailing spaces removed for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rtrim(\" a \")}) SQL Result: SELECT RTRIM(' a ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region with \"a\" replaced by \"*\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: replace(p.region,\"a\",\"*\")}) SQL Result: SELECT REPLACE(c.region,'a','*') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion masked for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: mask(p.subregion)}) SQL Result: SELECT Concat(LEFT(c.subregion,3),'***',RIGHT(c.subregion,3)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the first 3 characters of the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substr(p.subregion,1,3)}) SQL Result: SELECT SUBSTR(c.subregion,1,3) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the first 3 characters of the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substring(p.subregion,1,3)}) SQL Result: SELECT SUBSTR(c.subregion,1,3) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the count of \"a\" in the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: strCount(p.subregion,\"a\")}) SQL Result: SELECT (LENGTH(c.subregion)-LENGTH(REPLACE(c.subregion,'a',''))) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the latitude as string for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toString(p.latitude)}) SQL Result: SELECT CONVERT(c.latitude, CHAR) AS result FROM Countries c WHERE c.iso3 = 'BRA' Definition chr description: Get character from ASCII code deterministic: true return: string params: ascii: number strCount description: Count value in source deterministic: true return: number params: source: string value: string lower description: Lowercase string deterministic: true return: string params: value: string lpad description: Pad the left-side of string deterministic: true return: string params: value: string len: number pad: string ltrim description: Remove leading chars deterministic: true return: string params: value: string replace description: The replace() method searches a string for a specified value and returns a new string where the specified values are replaced. deterministic: true return: string params: value: string source: string target: string rpad description: Pad the right-side of string deterministic: true return: string params: value: string len: number pad: string rtrim description: Remove trailing spaces deterministic: true return: string params: value: string substr description: Get a substring of string deterministic: true return: string params: value: string from: number count: number substring description: Get a substring of string deterministic: true return: string params: value: string from: number count: number trim description: Remove characters deterministic: true return: string params: value: string upper description: Uppercase string deterministic: true return: string params: value: string concat description: String concatenation deterministic: true return: string params: values: string mask description: General-purpose function that mask parts of arbitrary strings based on position within the string deterministic: true return: string params: value: string isEmpty description: Evaluate if it is empty deterministic: true return: boolean params: value: any toString description: convert to string deterministic: true return: string params: value: any","title":"String"},{"location":"queries/operatorsAndFunctions/String/#examples","text":"Example Result Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lower(p.subregion) }) [{\"result\":\"south america\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: upper(p.subregion) }) [{\"result\":\"SOUTH AMERICA\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: concat(p.region,\" \",p.subregion) }) [{\"result\":\"Americas South America\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lpad(p.region,12,\"_\") }) [{\"result\":\"____Americas\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rpad(p.region,12,\"_\") }) [{\"result\":\"Americas____\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: chr(68)}) [{\"result\":\"D\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ltrim(\" a \")}) [{\"result\":\"a \"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rtrim(\" a \")}) [{\"result\":\" a\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: replace(p.region,\"a\",\"*\")}) [{\"result\":\"Americ*s\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: mask(p.subregion)}) [{\"result\":\"Sou***ica\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substr(p.subregion,1,3)}) [{\"result\":\"Sou\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substring(p.subregion,1,3)}) [{\"result\":\"Sou\"}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: strCount(p.subregion,\"a\")}) [{\"result\":1}] Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toString(p.latitude)}) [{\"result\":\"-10.0000\"}]","title":"Examples"},{"location":"queries/operatorsAndFunctions/String/#sentences","text":"Lambda: Query to get the subregion in lowercase for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lower(p.subregion) }) SQL Result: SELECT LOWER(c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion in uppercase for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: upper(p.subregion) }) SQL Result: SELECT UPPER(c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region and subregion concatenated for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: concat(p.region,\" \",p.subregion) }) SQL Result: SELECT CONCAT(CONCAT(c.region,' '),c.subregion) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region left-padded with \"_\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: lpad(p.region,12,\"_\") }) SQL Result: SELECT LPAD(c.region,12,'_') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region right-padded with \"_\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rpad(p.region,12,\"_\") }) SQL Result: SELECT RPAD(c.region,12,'_') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the character \"D\" from ASCII code 68 for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: chr(68)}) SQL Result: SELECT CHAR(68 USING ASCII) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion with leading spaces removed for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: ltrim(\" a \")}) SQL Result: SELECT LTRIM(' a ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion with trailing spaces removed for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: rtrim(\" a \")}) SQL Result: SELECT RTRIM(' a ') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the region with \"a\" replaced by \"*\" for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: replace(p.region,\"a\",\"*\")}) SQL Result: SELECT REPLACE(c.region,'a','*') AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the subregion masked for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: mask(p.subregion)}) SQL Result: SELECT Concat(LEFT(c.subregion,3),'***',RIGHT(c.subregion,3)) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the first 3 characters of the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substr(p.subregion,1,3)}) SQL Result: SELECT SUBSTR(c.subregion,1,3) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the first 3 characters of the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: substring(p.subregion,1,3)}) SQL Result: SELECT SUBSTR(c.subregion,1,3) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the count of \"a\" in the subregion for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: strCount(p.subregion,\"a\")}) SQL Result: SELECT (LENGTH(c.subregion)-LENGTH(REPLACE(c.subregion,'a',''))) AS result FROM Countries c WHERE c.iso3 = 'BRA' Lambda: Query to get the latitude as string for the country with the iso3 code \"BRA\" Countries.filter(p=> p.iso3 == \"BRA\").map(p=> {result: toString(p.latitude)}) SQL Result: SELECT CONVERT(c.latitude, CHAR) AS result FROM Countries c WHERE c.iso3 = 'BRA'","title":"Sentences"},{"location":"queries/operatorsAndFunctions/String/#definition","text":"","title":"Definition"},{"location":"queries/operatorsAndFunctions/String/#chr","text":"description: Get character from ASCII code deterministic: true return: string params: ascii: number","title":"chr"},{"location":"queries/operatorsAndFunctions/String/#strcount","text":"description: Count value in source deterministic: true return: number params: source: string value: string","title":"strCount"},{"location":"queries/operatorsAndFunctions/String/#lower","text":"description: Lowercase string deterministic: true return: string params: value: string","title":"lower"},{"location":"queries/operatorsAndFunctions/String/#lpad","text":"description: Pad the left-side of string deterministic: true return: string params: value: string len: number pad: string","title":"lpad"},{"location":"queries/operatorsAndFunctions/String/#ltrim","text":"description: Remove leading chars deterministic: true return: string params: value: string","title":"ltrim"},{"location":"queries/operatorsAndFunctions/String/#replace","text":"description: The replace() method searches a string for a specified value and returns a new string where the specified values are replaced. deterministic: true return: string params: value: string source: string target: string","title":"replace"},{"location":"queries/operatorsAndFunctions/String/#rpad","text":"description: Pad the right-side of string deterministic: true return: string params: value: string len: number pad: string","title":"rpad"},{"location":"queries/operatorsAndFunctions/String/#rtrim","text":"description: Remove trailing spaces deterministic: true return: string params: value: string","title":"rtrim"},{"location":"queries/operatorsAndFunctions/String/#substr","text":"description: Get a substring of string deterministic: true return: string params: value: string from: number count: number","title":"substr"},{"location":"queries/operatorsAndFunctions/String/#substring","text":"description: Get a substring of string deterministic: true return: string params: value: string from: number count: number","title":"substring"},{"location":"queries/operatorsAndFunctions/String/#trim","text":"description: Remove characters deterministic: true return: string params: value: string","title":"trim"},{"location":"queries/operatorsAndFunctions/String/#upper","text":"description: Uppercase string deterministic: true return: string params: value: string","title":"upper"},{"location":"queries/operatorsAndFunctions/String/#concat","text":"description: String concatenation deterministic: true return: string params: values: string","title":"concat"},{"location":"queries/operatorsAndFunctions/String/#mask","text":"description: General-purpose function that mask parts of arbitrary strings based on position within the string deterministic: true return: string params: value: string","title":"mask"},{"location":"queries/operatorsAndFunctions/String/#isempty","text":"description: Evaluate if it is empty deterministic: true return: boolean params: value: any","title":"isEmpty"},{"location":"queries/operatorsAndFunctions/String/#tostring","text":"description: convert to string deterministic: true return: string params: value: any","title":"toString"},{"location":"schema/Schema-Use/","text":"Schema Use Simple configuration example Configuration using yaml: domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true infrastructure: mappings: - name: mapping1 entities: - name: Countries mapping: TBL_COUNTRIES properties: - name: iso3 mapping: ISO3 - name: name mapping: NAME sources: - name: source1 dialect: MySQL mapping: mapping2 connection: ${CNN_MYSQL} Configuration using json: { \"domain\": { \"entities\": [ { \"name\": \"Countries\", \"primaryKey\": [ \"iso3\" ], \"uniqueKey\": [ \"name\" ], \"properties\": [ { \"name\": \"iso3\", \"required\": true, \"type\": \"string\", \"length\": 3 }, { \"name\": \"name\", \"required\": true, \"type\": \"string\" } ] } ], }, \"infrastructure\": { \"mappings\":[ { \"name\":\"mapping1\", \"entities\":[ { \"name\": \"Countries\", \"mapping\": \"TBL_COUNTRIES\", \"properties\": [ { \"name\": \"iso3\", \"mapping\": \"ISO_3\" }, { \"name\": \"name\",\"mapping\": \"NAME\" }, ] } ] } ], \"sources\": [ { \"name\": \"source1\", \"mapping\": \"mapping1\", \"dialect\": \"MySQL\", \"connection\": \"${CNN_MYSQL}\" } ] } } Build source code Once the schema is configured or modified, the model can be created or modified by executing the \"build\" command of CLI lambdaorm build -l node This command generates the model file with all the entities as a repository file for each entity model.ts: export class Country { iso3?: string name?: string } export interface QryCountry { iso3: string name: number } export let Countries : Queryable<QryCountry> repositoryCountry.ts: import { Repository, IOrm } from 'lambdaorm' import { Country, QryCountry } from './model' export class CountryRepository extends Repository<Country, QryCountry> { constructor (stage?: string, Orm?:IOrm) { super('Countries', stage, Orm) } // Add your code here } Set schema When the orm.init() method is invoked it will execute the ORM initialization according to the schema. The following options are available to define the settings. Invoke the orm.init() method without the first argument and write this configuration to a file called lambdaorm.json or lambdaorm.yaml in the root of the project. according to the lambdaorm extension you will know how to read it. Invoke the orm.init() method passing as an argument the path where the configuration file is located. This route must include the .yaml or .json extension since that way we will know how to read it. Invoke the orm.init() method passing the configuration as a json object as argument Example passing the configuration file path: import { orm } from 'lambdaorm' (async () => { await orm.init('/home/my/app1/lambaORM.yaml') try { const countries = await orm.execute(`Countries.map(p=>{name:p.name,code:p.alpha3}) .sort(p=> desc(p.name)) .page(1,10)`) console.log(countries) } catch (error) { console.log(error) } finally { await orm.end() } })()","title":"Schema Use"},{"location":"schema/Schema-Use/#schema-use","text":"","title":"Schema Use"},{"location":"schema/Schema-Use/#simple-configuration-example","text":"Configuration using yaml: domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true infrastructure: mappings: - name: mapping1 entities: - name: Countries mapping: TBL_COUNTRIES properties: - name: iso3 mapping: ISO3 - name: name mapping: NAME sources: - name: source1 dialect: MySQL mapping: mapping2 connection: ${CNN_MYSQL} Configuration using json: { \"domain\": { \"entities\": [ { \"name\": \"Countries\", \"primaryKey\": [ \"iso3\" ], \"uniqueKey\": [ \"name\" ], \"properties\": [ { \"name\": \"iso3\", \"required\": true, \"type\": \"string\", \"length\": 3 }, { \"name\": \"name\", \"required\": true, \"type\": \"string\" } ] } ], }, \"infrastructure\": { \"mappings\":[ { \"name\":\"mapping1\", \"entities\":[ { \"name\": \"Countries\", \"mapping\": \"TBL_COUNTRIES\", \"properties\": [ { \"name\": \"iso3\", \"mapping\": \"ISO_3\" }, { \"name\": \"name\",\"mapping\": \"NAME\" }, ] } ] } ], \"sources\": [ { \"name\": \"source1\", \"mapping\": \"mapping1\", \"dialect\": \"MySQL\", \"connection\": \"${CNN_MYSQL}\" } ] } }","title":"Simple configuration example"},{"location":"schema/Schema-Use/#build-source-code","text":"Once the schema is configured or modified, the model can be created or modified by executing the \"build\" command of CLI lambdaorm build -l node This command generates the model file with all the entities as a repository file for each entity model.ts: export class Country { iso3?: string name?: string } export interface QryCountry { iso3: string name: number } export let Countries : Queryable<QryCountry> repositoryCountry.ts: import { Repository, IOrm } from 'lambdaorm' import { Country, QryCountry } from './model' export class CountryRepository extends Repository<Country, QryCountry> { constructor (stage?: string, Orm?:IOrm) { super('Countries', stage, Orm) } // Add your code here }","title":"Build source code"},{"location":"schema/Schema-Use/#set-schema","text":"When the orm.init() method is invoked it will execute the ORM initialization according to the schema. The following options are available to define the settings. Invoke the orm.init() method without the first argument and write this configuration to a file called lambdaorm.json or lambdaorm.yaml in the root of the project. according to the lambdaorm extension you will know how to read it. Invoke the orm.init() method passing as an argument the path where the configuration file is located. This route must include the .yaml or .json extension since that way we will know how to read it. Invoke the orm.init() method passing the configuration as a json object as argument Example passing the configuration file path: import { orm } from 'lambdaorm' (async () => { await orm.init('/home/my/app1/lambaORM.yaml') try { const countries = await orm.execute(`Countries.map(p=>{name:p.name,code:p.alpha3}) .sort(p=> desc(p.name)) .page(1,10)`) console.log(countries) } catch (error) { console.log(error) } finally { await orm.end() } })()","title":"Set schema"},{"location":"schema/Schema/","text":"Schema The schema includes all the configuration that the ORM needs. The schema separates the definition of the business model (Domain) from the persistence of the data (Infrastructure). In the domain, the entities and enumerators that represent the business model are completely clean, without any attributes that couple them to persistence. All queries are made according to the business model, so all queries are decoupled from the physical model of the data. In the infrastructure, all the necessary configuration is defined to be able to persist and obtain the data from the different sources. The schema configuration can be done in a yaml, json file or passed as a parameter when initializing the ORM. All the expressions that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr Example: This example poses a stage where two sources are accessed. Data source 1 is MySQL and contains the Countries table and source 2 is PostgreSQL contains the States table. In the case of the Countries entity, both the name of the table and the fields coincide with the name of the entity and the name of the properties, so the mapping is transparent. But in the case of the States entity, the name of the table and its fields differ, so the mapping defines the mapping.","title":"Schema"},{"location":"schema/Schema/#schema","text":"The schema includes all the configuration that the ORM needs. The schema separates the definition of the business model (Domain) from the persistence of the data (Infrastructure). In the domain, the entities and enumerators that represent the business model are completely clean, without any attributes that couple them to persistence. All queries are made according to the business model, so all queries are decoupled from the physical model of the data. In the infrastructure, all the necessary configuration is defined to be able to persist and obtain the data from the different sources. The schema configuration can be done in a yaml, json file or passed as a parameter when initializing the ORM. All the expressions that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr","title":"Schema"},{"location":"schema/Schema/#example","text":"This example poses a stage where two sources are accessed. Data source 1 is MySQL and contains the Countries table and source 2 is PostgreSQL contains the States table. In the case of the Countries entity, both the name of the table and the fields coincide with the name of the entity and the name of the properties, so the mapping is transparent. But in the case of the States entity, the name of the table and its fields differ, so the mapping defines the mapping.","title":"Example:"},{"location":"schema/Definition/SchemaDefinition-Composite/","text":"Composite Entity When a relationship is set to composite it will be treated as part of a document. \\ In the case of Non-Relational databases, the records of the relationship will be stored in the same collection. \\ In the case of relational databases, although the data is stored in different tables, when executing import and export it will be treated as an object that contains the records of the relationship. \\ The way to define that an entity is composite is by creating the name of the entity by putting the name of the parent in front. \\ Example: Devices.Components ... domain: entities: ... - name: Devices primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 required: true default: 'concat(type,\"-\",switch(type){case\"phone\":imei;default:mac;})' - name: type length: 16 required: true enum: DeviceType - name: name length: 32 required: true ... - name: Devices.Components extends: Products primaryKey: [\"id\"] uniqueKey: [\"deviceId\", \"name\"] properties: - name: id length: 50 required: true default: concat(deviceId,\"-\",lower(substring(replace(name,\" \",\"-\"),0,16))) - name: deviceId length: 32 required: true - name: name length: 16 required: true ... relations: - name: device from: deviceId entity: Devices to: id target: components ...","title":"Composite Entity"},{"location":"schema/Definition/SchemaDefinition-Composite/#composite-entity","text":"When a relationship is set to composite it will be treated as part of a document. \\ In the case of Non-Relational databases, the records of the relationship will be stored in the same collection. \\ In the case of relational databases, although the data is stored in different tables, when executing import and export it will be treated as an object that contains the records of the relationship. \\ The way to define that an entity is composite is by creating the name of the entity by putting the name of the parent in front. \\ Example: Devices.Components ... domain: entities: ... - name: Devices primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 required: true default: 'concat(type,\"-\",switch(type){case\"phone\":imei;default:mac;})' - name: type length: 16 required: true enum: DeviceType - name: name length: 32 required: true ... - name: Devices.Components extends: Products primaryKey: [\"id\"] uniqueKey: [\"deviceId\", \"name\"] properties: - name: id length: 50 required: true default: concat(deviceId,\"-\",lower(substring(replace(name,\" \",\"-\"),0,16))) - name: deviceId length: 32 required: true - name: name length: 16 required: true ... relations: - name: device from: deviceId entity: Devices to: id target: components ...","title":"Composite Entity"},{"location":"schema/Definition/SchemaDefinition-EnvironmentVariables/","text":"Environment Variables on Schema En toda las propiedades de un esquema se puede utilizar variables de entorno. \\ Para ellos se debe utilizar la notaci\u00f3n $ or ${} . Ejemplos de uso Use environment variables to set the connection to the database: ... sources: - name: source1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: source2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES ... Use environment variables to obtain the KEY for encryption functions: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ...","title":"Environment Variables on Schema"},{"location":"schema/Definition/SchemaDefinition-EnvironmentVariables/#environment-variables-on-schema","text":"En toda las propiedades de un esquema se puede utilizar variables de entorno. \\ Para ellos se debe utilizar la notaci\u00f3n $ or ${} .","title":"Environment Variables on Schema"},{"location":"schema/Definition/SchemaDefinition-EnvironmentVariables/#ejemplos-de-uso","text":"Use environment variables to set the connection to the database: ... sources: - name: source1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: source2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES ... Use environment variables to obtain the KEY for encryption functions: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ...","title":"Ejemplos de uso"},{"location":"schema/Definition/SchemaDefinition-Expressions/","text":"Expressions on Schema All the queries that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr In addition to the operations and functions defined in 3xpr lambdaorm extends the expression model with the following functions. General functions Function Description toBase64(value:string):string Encode a string to base64 getBase64(value:string):string Decode a base64 string encrypt(value:string,key:string):string Encrypt a string with a key decrypt(value:string,key:string):string Decrypt a string with a key Example of use: In this example, encrypt is used to save the encrypted email in the database and decrypt is used to obtain the decrypted email when returning the results. domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ... Orm class methods Functions Description orm.execute(query:string,data:any,options:any):any Execute an query and return the result orm.plan(query:string,options:any):any Return the execution plan of the query orm.metadata(query:string):any Return the metadata of the query orm.model(query:string):any Return the model of the query orm.parameters(query:string):any Return the parameters of the query orm.constraints(query:string):any Return the constraints of the query Example of use: In this example orm.execute is used to execute the same query that was executed in the default and cqrs stages but in the insights stage. This is used to implement the CQRS pattern. ... application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) View in CLI - northwind CQRS lab","title":"Expressions on Schema"},{"location":"schema/Definition/SchemaDefinition-Expressions/#expressions-on-schema","text":"All the queries that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr In addition to the operations and functions defined in 3xpr lambdaorm extends the expression model with the following functions.","title":"Expressions on Schema"},{"location":"schema/Definition/SchemaDefinition-Expressions/#general-functions","text":"Function Description toBase64(value:string):string Encode a string to base64 getBase64(value:string):string Decode a base64 string encrypt(value:string,key:string):string Encrypt a string with a key decrypt(value:string,key:string):string Decrypt a string with a key Example of use: In this example, encrypt is used to save the encrypted email in the database and decrypt is used to obtain the decrypted email when returning the results. domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ...","title":"General functions"},{"location":"schema/Definition/SchemaDefinition-Expressions/#orm-class-methods","text":"Functions Description orm.execute(query:string,data:any,options:any):any Execute an query and return the result orm.plan(query:string,options:any):any Return the execution plan of the query orm.metadata(query:string):any Return the metadata of the query orm.model(query:string):any Return the model of the query orm.parameters(query:string):any Return the parameters of the query orm.constraints(query:string):any Return the constraints of the query Example of use: In this example orm.execute is used to execute the same query that was executed in the default and cqrs stages but in the insights stage. This is used to implement the CQRS pattern. ... application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) View in CLI - northwind CQRS lab","title":"Orm class methods"},{"location":"schema/Definition/SchemaDefinition/","text":"Definition The schema includes all the configuration that the ORM needs. The schema separates the definition of the business model (Domain) from the persistence of the data (Infrastructure). In the domain, the entities and enumerators that represent the business model are completely clean, without any attributes that couple them to persistence. All queries are made according to the business model, so all queries are decoupled from the physical model of the data. In the infrastructure, all the necessary configuration is defined to be able to persist and obtain the data from the different sources. The schema configuration can be done in a yaml, json file or passed as a parameter when initializing the ORM. All the queries that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr Structure domain: enums: - name: string values: - name: string value: any entities: - name: string abstract: boolean extends: string[] view: boolean mapping: string primaryKey: string[] uniqueKey: string[] properties: - name: string mapping: string type: string | integer | decimal | boolean | dateTime | date | time length: number required: boolean autoIncrement: boolean view: boolean key: string default: expression readExp: expression readValue: expression writeValue: expression indexes: - name: string fields: string[] relations: - name: string type: oneToMany | manyToOne | oneToOne from: string entity: string to: string composite: boolean constraints: - message: string condition: expression application: start: - name: string condition: expression expression: expression end: - name: string condition: expression expression: expression errors: - name: string condition: expression expression: expression listeners: - name: string on: [select|insert|bulkInsert|update|delete] condition: expression before: expression after: expression error: expression infrastructure: mappings: - name: string entities: - name: string mapping: string abstract: boolean filter: expression properties: - name: string mapping: string readMappingExp: expression sources: - name: string dialect: [MySQL|MariaDB|PostgreSQL|Oracle|SqlServer|MongoDB|SQLjs] mapping: string connection: object | EnvironmentVariable stages: - name: string sources: - name: string condition: expression views: - name: string entities: - name: string exclude: boolean properties: - name: string exclude: boolean readExp: expression paths: src: string state: string domain: string Main Definition Property Description domain definition of the business model application implementation of events and listeners infrastructure concrete implementation of the data model Domain Property Description enums definitions of enum of model entities definitions of entity of model In the enums section, enumerations are defined that can then be used as the data type of a property. In the entities section, the entities are defined with their properties, relationships and constraints Enum They define an enumeration which can then be used as the data type of a property. Property Description required name name of enum yes values values of enum yes Enum Example In this example, the DeviceType enum is defined, which is used in the type property of the Devices entity. Example: domain: enums: - name: DeviceType values: - name: phone value: phone - name: computer value: computer - name: robot value: robot entities: ... - name: Devices extends: Products primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 required: true default: 'concat(type,\"-\",switch(type){case\"phone\":imei;default:mac;})' - name: type length: 16 required: true enum: DeviceType - name: name length: 32 required: true ... Entity The entity is defined with its properties, relationships and constraints Property Description required default name name of entity yes abstract if the entity is abstract extends extension view if the entity is a view primaryKey primary key uniqueKey unique key properties entity properties yes indexes indexes relations relations constraints constraints Abstract and extends in Entity In this example the abstract entity positions is defined which extends the entity Countries Example: domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true Set Entity as view This example defines the Users entity as a view. \\ Since this entity is managed by an external system and only select queries are allowed. Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname ... Property Property Description required default name name of property yes type type of property yes string length length of property type 80 required if the field is required false autoIncrement if the field is self-incrementing false view if the field is a view default expression default resolved on server readExp read expression resolved in source readValue read expression resolved on server writeValue write expression resolved in server key key to filter or insert Set Property as view and readExp A property set to view is a property that will be returned in read queries. \\ The value of this property is defined in readExp using the expression language. Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) ... ReadExp can be used as a view, in this case the read expression will be applied at the time of reading. \\ But no modification will be applied at the time of writing. Default value in Property When a record is inserted, the expression defined in default will be evaluated on the server. \\ This expression will be executed by the expression engine 3xpr Example: domain: entities: - name: Groups extends: Basics primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 default: lower(substring(replace(name,\" \",\"-\"),0,32)) required: true - name: name length: 32 required: true Read and write value in Property Both readValue and writeValue are executed on the server. When reading, readValue will be applied and in the writing actions, writeValue will be executed. These expressions will be executed by the expression engine 3xpr Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ... Key value in Property The key defined in keyValue will be used as a filter in the read and update queries. \\ When a record is inserted this key is assigned to the field. \\ This behavior is useful when we want to define different entities on the same table or collection. \\ Let's imagine we have a Locations table where Countries, States and Cities are stored. \\ but we want to work with the entities separately. Example: domain: entities: - name: Locations abstract: true primaryKey: [\"type\",\"code\"] uniqueKey: [\"type\",\"name\"] properties: - name: code required: true length: 16 - name: type required: true length: 16 - name: name required: true - name: Country extends: Locations properties: - name: type key: 'country' - name: States extends: Locations properties: - name: type key: 'state' - name: Cities extends: Locations properties: - name: type key: 'city' infrastructure: mappings: - name: default entities: - name: Locations abstract: true mapping: TBL_LOCATIONS properties: - name: code mapping: CODE - name: type mapping: TYPE - name: name mapping: NAME - name: Country extends: Locations - name: States extends: Locations - name: Cities extends: Locations Relation Property Description required default name name of property yes type type of relationship oneToMany from relationship field entity entity with which it relates to field of the entity to which it relates composite if the relationship is composite false target Name of the relation in the related entity Target relation When defining target the corresponding relationship will be created in the target entity. For example, if in the entity DeviceStatuses a relationship with Devices is created and in this relationship target = \"statuses\" is set. \\ A relationship called statuses will be created in the entity Devices which will be manyToOne. \\ Types of target relation according to the source relation: source target oneToMany manyToOne manyToOne oneToMany oneToOne oneToOne Example: domain: entities: - name: DeviceStatuses extends: Basics primaryKey: [\"id\"] indexes: - name: time fields: [\"time\"] properties: - name: id type: integer required: true autoIncrement: true - name: deviceId length: 32 required: true - name: time type: dateTime relations: - name: device from: deviceId entity: Devices to: id target: statuses Constraint Property Description required message message to display yes condition boolean expression to evaluate yes Constraints are validated on the server using expressions. These expressions will be executed by the expression engine 3xpr All constraints are validated when inserting or updating a record. \\ The ORM will create various constraints based on other definitions, for example: When you define a property as required, a constraint will be created that will validate that this property is not null. When defining that a property is of an Enum type, a constraint is created that validates that the value is within this enum. It is also possible to add a constraint for which the message and the condition must be defined. \\ The defined message will be sent if the condition is not met. Example: domain: entities: - name: Users properties: ... - name: email required: true length: 255 readExp: mask(email) writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") constraints: - message: invalid email condition: test(email,\"^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$\") - name: Files properties: - name: id length: 255 required: true - name: type length: 16 required: true enum: FileType - name: deviceId length: 32 required: true - name: startDate type: dateTime required: true - name: endDate type: dateTime required: true constraints: - message: endDate cannot be less than startDate condition: startDate<=endDate Application Property Description start commands to execute when starting the application end commands to execute when the application is terminated errors commands to execute when an error occurs listeners definition of the listeners and the action to be executed Infrastructure Property Description mappings definitions of mappings sources definitions of source stages definitions of stages views definitions of views paths In the mappings section, the mapping between the entities in the tables or collections in the databases is defined. In the sources section the databases are defined In the stages section different scenarios are defined in which the rules that associate an entity with a source are determined In the views section, different views are defined that can restrict or modify the results of the queries. In the paths section, the configuration of the routes where configuration files or execution results will be generated is established. Mapping The mapping between entities in tables or collections in databases is defined. Property Description required default name name of mapping yes entities list of entity mapping yes Entity Mapping Property Description required default name name of entity yes abstract if the entity is abstract extends extension mapping table name in the database yes equal name filter filter expression properties list of property mapping Abstract and extends in Entity Mapping Abstract mapping entities are useful for use in extensions. \\ This example defines the abstract mapping entity Locations which extends concrete entities. ... infrastructure: mappings: - name: default entities: - name: Locations abstract: true mapping: TBL_LOCATIONS properties: - name: code mapping: CODE - name: type mapping: TYPE - name: name mapping: NAME - name: Country extends: Locations - name: States extends: Locations - name: Cities extends: Locations ... Filter in Entity Mapping The filter defined in a Mapping entity is used to filter the records. This example filters records from the user_entity table where users are from a certain realmId . ... infrastructure: mappings: - name: default - name: keycloak entities: - name: Users mapping: user_entity filter: realmId == \"${REALM_ID}\" properties: - name: username mapping: username - name: firstname mapping: first_name - name: lastname mapping: last_name - name: email mapping: email - name: created mapping: created_timestamp readMappingExp: millisecondToDate(created/1000) - name: realmId length: 255 mapping: realm_id ... Property Mapping Property Description required default name name of property yes mapping table name in the database yes equal name readMappingExp read expression resolved in source Read expression in Property Mapping The result of the expression defined in readMappingExp using the expression language, will be returned in the read queries. infrastructure: mappings: - name: default - name: keycloak entities: - name: Users mapping: user_entity filter: realmId == \"${REALM_ID}\" properties: ... - name: created mapping: created_timestamp readMappingExp: millisecondToDate(created/1000) - name: realmId length: 255 mapping: realm_id ... Source Databases are defined with their connection Property Description required default name name of source yes mapping name of reference to mapping first dialect dialect of data source yes connection string connection yes Set connection in Source Although it is possible to define the connection both using environment variables and directly in the configuration. \\ This second option is not recommended due to security and different configurations that may exist by environment. \\ The ability to define the connection by configuration should only be used for a temporary local test. Using environment variable: ... infrastructure: sources: - name: test dialect: MySQL mapping: test connection: ${CNN_MYSQL} ... In configuration: ... infrastructure: sources: - name: test dialect: MySQL mapping: test connection: host: localhost port: 3306 user: test password: test database: test ... Stage The stage is defined in which the rules that relate an entity to a source are determined Property Description required default name name of stage yes sources list of sources rules yes Source Rule Property Description required default name name of source yes condition boolean expression to evaluate true Condition on Source Rule En condition se define la regla para determinar en que source se aplicaran las consultas. Las variables de contexto son las siguientes: Variable Description value entity query entity name of entity action query action select, insert, bulkInsert, update, delete, ddl read it is a read action boolean write it is a write action boolean dml it is a dml action boolean ddl it is a ddl action boolean The conditions are validated on the server using expressions. \\ These expressions will be executed by the expression engine 3xpr \\ In the event that more than one condition is met, the source will be determined according to the order in which it was defined. In the following example, all entities except Users will use the source main . \\ And in the case of the entity Users it will use the source keycloak . Example: ... infrastructure: stages: - name: default sources: - name: main condition: entity != \"Users\" - name: keycloak condition: entity == \"Users\" View The view that can restrict or modify the results of the queries is defined. Property Description required name name that identifies a view yes entities entity view list Entities not included in the view will not be subject to any restrictions. In the following example, the admin view can access all entities. Example: infrastructure: views: - name: default entities: - name: Devices properties: - name: apiKey readExp: '\"***\"' - name: Users properties: - name: created readExp: date(created) - name: email exclude: true - name: collector entities: - name: Users exclude: true - name: Groups exclude: true - name: GroupUsers exclude: true - name: admin entities: [] Entity View Property Description required name entity name yes exclude determines whether the entity is excluded properties property view list Exclude in Entity View Entities set to exclude will not be accessible when using this view. infrastructure: views: ... - name: collector entities: - name: Users exclude: true - name: Groups exclude: true - name: GroupUsers exclude: true ... Property View Property Description required name property name yes exclude determines whether the property is excluded readExp read expression resolved in source Exclude in Property View Properties set to exclude will not be accessible when using this view. infrastructure: views: - name: default entities: ... - name: Users properties: - name: created readExp: date(created) - name: email exclude: true ... Read expression in Property View The result of the expression defined in readExp using the expression language, will be returned in the read queries. Example: infrastructure: views: - name: default entities: ... - name: Users properties: - name: created readExp: date(created) - name: email exclude: true ... Paths In this app section, the configuration of the routes where the configuration files or execution results will be generated is established. Property Description required default src set path of source code src state define path of orm state orm_state model define path of model to generate model Example: app: src: src state: orm_state domain: domain","title":"Definition"},{"location":"schema/Definition/SchemaDefinition/#definition","text":"The schema includes all the configuration that the ORM needs. The schema separates the definition of the business model (Domain) from the persistence of the data (Infrastructure). In the domain, the entities and enumerators that represent the business model are completely clean, without any attributes that couple them to persistence. All queries are made according to the business model, so all queries are decoupled from the physical model of the data. In the infrastructure, all the necessary configuration is defined to be able to persist and obtain the data from the different sources. The schema configuration can be done in a yaml, json file or passed as a parameter when initializing the ORM. All the queries that are used for the definition of conditions and for the execution of actions are based on the expression engine 3xpr","title":"Definition"},{"location":"schema/Definition/SchemaDefinition/#structure","text":"domain: enums: - name: string values: - name: string value: any entities: - name: string abstract: boolean extends: string[] view: boolean mapping: string primaryKey: string[] uniqueKey: string[] properties: - name: string mapping: string type: string | integer | decimal | boolean | dateTime | date | time length: number required: boolean autoIncrement: boolean view: boolean key: string default: expression readExp: expression readValue: expression writeValue: expression indexes: - name: string fields: string[] relations: - name: string type: oneToMany | manyToOne | oneToOne from: string entity: string to: string composite: boolean constraints: - message: string condition: expression application: start: - name: string condition: expression expression: expression end: - name: string condition: expression expression: expression errors: - name: string condition: expression expression: expression listeners: - name: string on: [select|insert|bulkInsert|update|delete] condition: expression before: expression after: expression error: expression infrastructure: mappings: - name: string entities: - name: string mapping: string abstract: boolean filter: expression properties: - name: string mapping: string readMappingExp: expression sources: - name: string dialect: [MySQL|MariaDB|PostgreSQL|Oracle|SqlServer|MongoDB|SQLjs] mapping: string connection: object | EnvironmentVariable stages: - name: string sources: - name: string condition: expression views: - name: string entities: - name: string exclude: boolean properties: - name: string exclude: boolean readExp: expression paths: src: string state: string domain: string","title":"Structure"},{"location":"schema/Definition/SchemaDefinition/#main-definition","text":"Property Description domain definition of the business model application implementation of events and listeners infrastructure concrete implementation of the data model","title":"Main Definition"},{"location":"schema/Definition/SchemaDefinition/#domain","text":"Property Description enums definitions of enum of model entities definitions of entity of model In the enums section, enumerations are defined that can then be used as the data type of a property. In the entities section, the entities are defined with their properties, relationships and constraints","title":"Domain"},{"location":"schema/Definition/SchemaDefinition/#enum","text":"They define an enumeration which can then be used as the data type of a property. Property Description required name name of enum yes values values of enum yes","title":"Enum"},{"location":"schema/Definition/SchemaDefinition/#enum-example","text":"In this example, the DeviceType enum is defined, which is used in the type property of the Devices entity. Example: domain: enums: - name: DeviceType values: - name: phone value: phone - name: computer value: computer - name: robot value: robot entities: ... - name: Devices extends: Products primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 required: true default: 'concat(type,\"-\",switch(type){case\"phone\":imei;default:mac;})' - name: type length: 16 required: true enum: DeviceType - name: name length: 32 required: true ...","title":"Enum Example"},{"location":"schema/Definition/SchemaDefinition/#entity","text":"The entity is defined with its properties, relationships and constraints Property Description required default name name of entity yes abstract if the entity is abstract extends extension view if the entity is a view primaryKey primary key uniqueKey unique key properties entity properties yes indexes indexes relations relations constraints constraints","title":"Entity"},{"location":"schema/Definition/SchemaDefinition/#abstract-and-extends-in-entity","text":"In this example the abstract entity positions is defined which extends the entity Countries Example: domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true","title":"Abstract and extends in Entity"},{"location":"schema/Definition/SchemaDefinition/#set-entity-as-view","text":"This example defines the Users entity as a view. \\ Since this entity is managed by an external system and only select queries are allowed. Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname ...","title":"Set Entity as view"},{"location":"schema/Definition/SchemaDefinition/#property","text":"Property Description required default name name of property yes type type of property yes string length length of property type 80 required if the field is required false autoIncrement if the field is self-incrementing false view if the field is a view default expression default resolved on server readExp read expression resolved in source readValue read expression resolved on server writeValue write expression resolved in server key key to filter or insert","title":"Property"},{"location":"schema/Definition/SchemaDefinition/#set-property-as-view-and-readexp","text":"A property set to view is a property that will be returned in read queries. \\ The value of this property is defined in readExp using the expression language. Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) ... ReadExp can be used as a view, in this case the read expression will be applied at the time of reading. \\ But no modification will be applied at the time of writing.","title":"Set Property as view and readExp"},{"location":"schema/Definition/SchemaDefinition/#default-value-in-property","text":"When a record is inserted, the expression defined in default will be evaluated on the server. \\ This expression will be executed by the expression engine 3xpr Example: domain: entities: - name: Groups extends: Basics primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id length: 32 default: lower(substring(replace(name,\" \",\"-\"),0,32)) required: true - name: name length: 32 required: true","title":"Default value in Property"},{"location":"schema/Definition/SchemaDefinition/#read-and-write-value-in-property","text":"Both readValue and writeValue are executed on the server. When reading, readValue will be applied and in the writing actions, writeValue will be executed. These expressions will be executed by the expression engine 3xpr Example: domain: entities: ... - name: Users view: true extends: Basics primaryKey: [\"username\"] uniqueKey: [\"email\"] properties: - name: username length: 32 required: true - name: firstname required: true - name: lastname required: true - name: fullmane view: true readExp: concat(lastname,\", \",firstname) - name: email required: true length: 255 writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") ...","title":"Read and write value in Property"},{"location":"schema/Definition/SchemaDefinition/#key-value-in-property","text":"The key defined in keyValue will be used as a filter in the read and update queries. \\ When a record is inserted this key is assigned to the field. \\ This behavior is useful when we want to define different entities on the same table or collection. \\ Let's imagine we have a Locations table where Countries, States and Cities are stored. \\ but we want to work with the entities separately. Example: domain: entities: - name: Locations abstract: true primaryKey: [\"type\",\"code\"] uniqueKey: [\"type\",\"name\"] properties: - name: code required: true length: 16 - name: type required: true length: 16 - name: name required: true - name: Country extends: Locations properties: - name: type key: 'country' - name: States extends: Locations properties: - name: type key: 'state' - name: Cities extends: Locations properties: - name: type key: 'city' infrastructure: mappings: - name: default entities: - name: Locations abstract: true mapping: TBL_LOCATIONS properties: - name: code mapping: CODE - name: type mapping: TYPE - name: name mapping: NAME - name: Country extends: Locations - name: States extends: Locations - name: Cities extends: Locations","title":"Key value in Property"},{"location":"schema/Definition/SchemaDefinition/#relation","text":"Property Description required default name name of property yes type type of relationship oneToMany from relationship field entity entity with which it relates to field of the entity to which it relates composite if the relationship is composite false target Name of the relation in the related entity","title":"Relation"},{"location":"schema/Definition/SchemaDefinition/#target-relation","text":"When defining target the corresponding relationship will be created in the target entity. For example, if in the entity DeviceStatuses a relationship with Devices is created and in this relationship target = \"statuses\" is set. \\ A relationship called statuses will be created in the entity Devices which will be manyToOne. \\ Types of target relation according to the source relation: source target oneToMany manyToOne manyToOne oneToMany oneToOne oneToOne Example: domain: entities: - name: DeviceStatuses extends: Basics primaryKey: [\"id\"] indexes: - name: time fields: [\"time\"] properties: - name: id type: integer required: true autoIncrement: true - name: deviceId length: 32 required: true - name: time type: dateTime relations: - name: device from: deviceId entity: Devices to: id target: statuses","title":"Target relation"},{"location":"schema/Definition/SchemaDefinition/#constraint","text":"Property Description required message message to display yes condition boolean expression to evaluate yes Constraints are validated on the server using expressions. These expressions will be executed by the expression engine 3xpr All constraints are validated when inserting or updating a record. \\ The ORM will create various constraints based on other definitions, for example: When you define a property as required, a constraint will be created that will validate that this property is not null. When defining that a property is of an Enum type, a constraint is created that validates that the value is within this enum. It is also possible to add a constraint for which the message and the condition must be defined. \\ The defined message will be sent if the condition is not met. Example: domain: entities: - name: Users properties: ... - name: email required: true length: 255 readExp: mask(email) writeValue: encrypt(lower(email),\"${USERS_SECRET_KEY}\") readValue: decrypt(email,\"${USERS_SECRET_KEY}\") constraints: - message: invalid email condition: test(email,\"^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$\") - name: Files properties: - name: id length: 255 required: true - name: type length: 16 required: true enum: FileType - name: deviceId length: 32 required: true - name: startDate type: dateTime required: true - name: endDate type: dateTime required: true constraints: - message: endDate cannot be less than startDate condition: startDate<=endDate","title":"Constraint"},{"location":"schema/Definition/SchemaDefinition/#application","text":"Property Description start commands to execute when starting the application end commands to execute when the application is terminated errors commands to execute when an error occurs listeners definition of the listeners and the action to be executed","title":"Application"},{"location":"schema/Definition/SchemaDefinition/#infrastructure","text":"Property Description mappings definitions of mappings sources definitions of source stages definitions of stages views definitions of views paths In the mappings section, the mapping between the entities in the tables or collections in the databases is defined. In the sources section the databases are defined In the stages section different scenarios are defined in which the rules that associate an entity with a source are determined In the views section, different views are defined that can restrict or modify the results of the queries. In the paths section, the configuration of the routes where configuration files or execution results will be generated is established.","title":"Infrastructure"},{"location":"schema/Definition/SchemaDefinition/#mapping","text":"The mapping between entities in tables or collections in databases is defined. Property Description required default name name of mapping yes entities list of entity mapping yes","title":"Mapping"},{"location":"schema/Definition/SchemaDefinition/#entity-mapping","text":"Property Description required default name name of entity yes abstract if the entity is abstract extends extension mapping table name in the database yes equal name filter filter expression properties list of property mapping","title":"Entity Mapping"},{"location":"schema/Definition/SchemaDefinition/#abstract-and-extends-in-entity-mapping","text":"Abstract mapping entities are useful for use in extensions. \\ This example defines the abstract mapping entity Locations which extends concrete entities. ... infrastructure: mappings: - name: default entities: - name: Locations abstract: true mapping: TBL_LOCATIONS properties: - name: code mapping: CODE - name: type mapping: TYPE - name: name mapping: NAME - name: Country extends: Locations - name: States extends: Locations - name: Cities extends: Locations ...","title":"Abstract and extends in Entity Mapping"},{"location":"schema/Definition/SchemaDefinition/#filter-in-entity-mapping","text":"The filter defined in a Mapping entity is used to filter the records. This example filters records from the user_entity table where users are from a certain realmId . ... infrastructure: mappings: - name: default - name: keycloak entities: - name: Users mapping: user_entity filter: realmId == \"${REALM_ID}\" properties: - name: username mapping: username - name: firstname mapping: first_name - name: lastname mapping: last_name - name: email mapping: email - name: created mapping: created_timestamp readMappingExp: millisecondToDate(created/1000) - name: realmId length: 255 mapping: realm_id ...","title":"Filter in Entity Mapping"},{"location":"schema/Definition/SchemaDefinition/#property-mapping","text":"Property Description required default name name of property yes mapping table name in the database yes equal name readMappingExp read expression resolved in source","title":"Property Mapping"},{"location":"schema/Definition/SchemaDefinition/#read-expression-in-property-mapping","text":"The result of the expression defined in readMappingExp using the expression language, will be returned in the read queries. infrastructure: mappings: - name: default - name: keycloak entities: - name: Users mapping: user_entity filter: realmId == \"${REALM_ID}\" properties: ... - name: created mapping: created_timestamp readMappingExp: millisecondToDate(created/1000) - name: realmId length: 255 mapping: realm_id ...","title":"Read expression in Property Mapping"},{"location":"schema/Definition/SchemaDefinition/#source","text":"Databases are defined with their connection Property Description required default name name of source yes mapping name of reference to mapping first dialect dialect of data source yes connection string connection yes","title":"Source"},{"location":"schema/Definition/SchemaDefinition/#set-connection-in-source","text":"Although it is possible to define the connection both using environment variables and directly in the configuration. \\ This second option is not recommended due to security and different configurations that may exist by environment. \\ The ability to define the connection by configuration should only be used for a temporary local test. Using environment variable: ... infrastructure: sources: - name: test dialect: MySQL mapping: test connection: ${CNN_MYSQL} ... In configuration: ... infrastructure: sources: - name: test dialect: MySQL mapping: test connection: host: localhost port: 3306 user: test password: test database: test ...","title":"Set connection in Source"},{"location":"schema/Definition/SchemaDefinition/#stage","text":"The stage is defined in which the rules that relate an entity to a source are determined Property Description required default name name of stage yes sources list of sources rules yes","title":"Stage"},{"location":"schema/Definition/SchemaDefinition/#source-rule","text":"Property Description required default name name of source yes condition boolean expression to evaluate true","title":"Source Rule"},{"location":"schema/Definition/SchemaDefinition/#condition-on-source-rule","text":"En condition se define la regla para determinar en que source se aplicaran las consultas. Las variables de contexto son las siguientes: Variable Description value entity query entity name of entity action query action select, insert, bulkInsert, update, delete, ddl read it is a read action boolean write it is a write action boolean dml it is a dml action boolean ddl it is a ddl action boolean The conditions are validated on the server using expressions. \\ These expressions will be executed by the expression engine 3xpr \\ In the event that more than one condition is met, the source will be determined according to the order in which it was defined. In the following example, all entities except Users will use the source main . \\ And in the case of the entity Users it will use the source keycloak . Example: ... infrastructure: stages: - name: default sources: - name: main condition: entity != \"Users\" - name: keycloak condition: entity == \"Users\"","title":"Condition on Source Rule"},{"location":"schema/Definition/SchemaDefinition/#view","text":"The view that can restrict or modify the results of the queries is defined. Property Description required name name that identifies a view yes entities entity view list Entities not included in the view will not be subject to any restrictions. In the following example, the admin view can access all entities. Example: infrastructure: views: - name: default entities: - name: Devices properties: - name: apiKey readExp: '\"***\"' - name: Users properties: - name: created readExp: date(created) - name: email exclude: true - name: collector entities: - name: Users exclude: true - name: Groups exclude: true - name: GroupUsers exclude: true - name: admin entities: []","title":"View"},{"location":"schema/Definition/SchemaDefinition/#entity-view","text":"Property Description required name entity name yes exclude determines whether the entity is excluded properties property view list","title":"Entity View"},{"location":"schema/Definition/SchemaDefinition/#exclude-in-entity-view","text":"Entities set to exclude will not be accessible when using this view. infrastructure: views: ... - name: collector entities: - name: Users exclude: true - name: Groups exclude: true - name: GroupUsers exclude: true ...","title":"Exclude in Entity View"},{"location":"schema/Definition/SchemaDefinition/#property-view","text":"Property Description required name property name yes exclude determines whether the property is excluded readExp read expression resolved in source","title":"Property View"},{"location":"schema/Definition/SchemaDefinition/#exclude-in-property-view","text":"Properties set to exclude will not be accessible when using this view. infrastructure: views: - name: default entities: ... - name: Users properties: - name: created readExp: date(created) - name: email exclude: true ...","title":"Exclude in Property View"},{"location":"schema/Definition/SchemaDefinition/#read-expression-in-property-view","text":"The result of the expression defined in readExp using the expression language, will be returned in the read queries. Example: infrastructure: views: - name: default entities: ... - name: Users properties: - name: created readExp: date(created) - name: email exclude: true ...","title":"Read expression in Property View"},{"location":"schema/Definition/SchemaDefinition/#paths","text":"In this app section, the configuration of the routes where the configuration files or execution results will be generated is established. Property Description required default src set path of source code src state define path of orm state orm_state model define path of model to generate model Example: app: src: src state: orm_state domain: domain","title":"Paths"},{"location":"schema/Examples/SchemaExample-Basic/","text":"Basic Schema Example In the basic configuration of a schema, the entities, mapping and data sources are defined. Properties, relationships and keys are defined in entities. In the mapping, the mappings of the entities with the database tables are defined. In the data sources, the dialect of the data source and the connections are defined. Many properties can be omitted since they have a default value. For example: If the type of a property is not defined in an entity, it is assumed to be a string. If it is not specified that the property is required, it is assumed that it is not. If the length of a property is not defined, it is assumed to be 80. If the mapping information is not defined, it is assumed that the entities are called the same in the source data and that the properties are called the same as the field in the table or collection. Schema Example The schema defines how the entities of the model are mapped with the database tables. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: test sources: - name: test dialect: MySQL mapping: test connection: host: localhost port: 3306 user: test password: test database: test stages: - name: default sources: - name: test Laboratories CLI - simple","title":"Basic Schema Example"},{"location":"schema/Examples/SchemaExample-Basic/#basic-schema-example","text":"In the basic configuration of a schema, the entities, mapping and data sources are defined. Properties, relationships and keys are defined in entities. In the mapping, the mappings of the entities with the database tables are defined. In the data sources, the dialect of the data source and the connections are defined. Many properties can be omitted since they have a default value. For example: If the type of a property is not defined in an entity, it is assumed to be a string. If it is not specified that the property is required, it is assumed that it is not. If the length of a property is not defined, it is assumed to be 80. If the mapping information is not defined, it is assumed that the entities are called the same in the source data and that the properties are called the same as the field in the table or collection.","title":"Basic Schema Example"},{"location":"schema/Examples/SchemaExample-Basic/#schema-example","text":"The schema defines how the entities of the model are mapped with the database tables. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: test sources: - name: test dialect: MySQL mapping: test connection: host: localhost port: 3306 user: test password: test database: test stages: - name: default sources: - name: test","title":"Schema Example"},{"location":"schema/Examples/SchemaExample-Basic/#laboratories","text":"CLI - simple","title":"Laboratories"},{"location":"schema/Examples/SchemaExample-Composite/","text":"Composite Entity Using the period in the name of an entity we can define a composite entity. \\ For example, if we have an entity Orders and another Orders.details \\ The Orders.details entity is a composite entity of the Orders entity. \\ If the datasource is NoSQL, the data will be stored in a single collection but if the datasource is Relational, the data will be stored in separate tables. \\ But on the domain side it will be treated the same regardless of the type of datasource. \\ abstracting from persistence technology. Composite Example In this example we can see that we have an entity Orders and another Orders.details \\ The Orders.details entity is a composite entity of the Orders entity. \\ Part of the schema where the composite entity is defined: domain: entities: ... - name: Orders primaryKey: [id] indexes: - name: orderDate fields: [orderDate] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime - name: Orders.details primaryKey: [orderId, productId] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details ... Schema Complete: domain: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"localhost\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_MONGODB={\"url\":\"mongodb://test:test@localhost:27017\",\"database\":\"test\"} Laboratory: CLI - northwind multiples datasources Composite example in different datasources En este ejemple podemos ver como se trata una entidad compuesta en diferentes datasources. \\ En el stage default se utiliza Mongo para almacenar las Orders y Orders.details \\ En el stage insights se utiliza Postgres para almacenar las Orders y Orders.details Part of the schema where the stages are configured: ... stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights ... Schema Complete: domain: enums: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights Orders Composite in MongoDb Orders collection: Orders Composite in Postgres Orders table: Orders details table: Queries But if we execute the same query in the different stages we can see that the result is the same Query on default stage lambdaorm execute -e \".env\" -s default -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).order(p=> p.id).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 3, \"customerId\": \"HANAR\", \"employeeId\": 4, \"orderDate\": \"1996-07-08T00:00:00.000+02:00\", \"requiredDate\": \"1996-08-05\", \"shippedDate\": \"1996-07-12\", \"shipViaId\": 2, \"freight\": 65.83, \"name\": \"Hanari Carnes\", \"address\": \"Rua do Pao, 67\", \"city\": \"Rio de Janeiro\", \"region\": \"RJ\", \"postalCode\": \"05454-876\", \"country\": \"Brazil\", \"details\": [ { \"quantity\": 10, \"unitPrice\": 7.7, \"product\": { \"name\": \"Jack's New England Clam Chowder\", \"category\": { \"name\": \"Seafood\" } } }, { \"quantity\": 35, \"unitPrice\": 42.4, \"product\": { \"name\": \"Manjimup Dried Apples\", \"category\": { \"name\": \"Produce\" } } }, { \"quantity\": 15, \"unitPrice\": 16.8, \"product\": { \"name\": \"Louisiana Fiery Hot Pepper Sauce\", \"category\": { \"name\": \"Condiments\" } } } ], \"customer\": { \"name\": \"Hanari Carnes\" } } ] Same query on insights stage lambdaorm execute -e \".env\" -s insights -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).order(p=> p.id).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 3, \"customerId\": \"HANAR\", \"employeeId\": 4, \"orderDate\": \"1996-07-07T22:00:00.000Z\", \"requiredDate\": \"1996-08-04T22:00:00.000Z\", \"shippedDate\": \"1996-07-11T22:00:00.000Z\", \"shipViaId\": 2, \"freight\": 65.83, \"name\": \"Hanari Carnes\", \"address\": \"Rua do Pao, 67\", \"city\": \"Rio de Janeiro\", \"region\": \"RJ\", \"postalCode\": \"05454-876\", \"country\": \"Brazil\", \"customer\": { \"name\": \"Hanari Carnes\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 7.7, \"product\": { \"name\": \"Jack's New England Clam Chowder\", \"category\": { \"name\": \"Seafood\" } } }, { \"quantity\": 35, \"unitPrice\": 42.4, \"product\": { \"name\": \"Manjimup Dried Apples\", \"category\": { \"name\": \"Produce\" } } }, { \"quantity\": 15, \"unitPrice\": 16.8, \"product\": { \"name\": \"Louisiana Fiery Hot Pepper Sauce\", \"category\": { \"name\": \"Condiments\" } } } ] } ] Laboratories CLI - northwind CLI - northwind multiples datasources CLI - northwind multiples stages","title":"Composite Entity"},{"location":"schema/Examples/SchemaExample-Composite/#composite-entity","text":"Using the period in the name of an entity we can define a composite entity. \\ For example, if we have an entity Orders and another Orders.details \\ The Orders.details entity is a composite entity of the Orders entity. \\ If the datasource is NoSQL, the data will be stored in a single collection but if the datasource is Relational, the data will be stored in separate tables. \\ But on the domain side it will be treated the same regardless of the type of datasource. \\ abstracting from persistence technology.","title":"Composite Entity"},{"location":"schema/Examples/SchemaExample-Composite/#composite-example","text":"In this example we can see that we have an entity Orders and another Orders.details \\ The Orders.details entity is a composite entity of the Orders entity. \\ Part of the schema where the composite entity is defined: domain: entities: ... - name: Orders primaryKey: [id] indexes: - name: orderDate fields: [orderDate] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime - name: Orders.details primaryKey: [orderId, productId] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details ... Schema Complete: domain: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"localhost\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_MONGODB={\"url\":\"mongodb://test:test@localhost:27017\",\"database\":\"test\"} Laboratory: CLI - northwind multiples datasources","title":"Composite Example"},{"location":"schema/Examples/SchemaExample-Composite/#composite-example-in-different-datasources","text":"En este ejemple podemos ver como se trata una entidad compuesta en diferentes datasources. \\ En el stage default se utiliza Mongo para almacenar las Orders y Orders.details \\ En el stage insights se utiliza Postgres para almacenar las Orders y Orders.details Part of the schema where the stages are configured: ... stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights ... Schema Complete: domain: enums: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights","title":"Composite example in different datasources"},{"location":"schema/Examples/SchemaExample-Composite/#orders-composite-in-mongodb","text":"Orders collection:","title":"Orders Composite in MongoDb"},{"location":"schema/Examples/SchemaExample-Composite/#orders-composite-in-postgres","text":"Orders table: Orders details table:","title":"Orders Composite in Postgres"},{"location":"schema/Examples/SchemaExample-Composite/#queries","text":"But if we execute the same query in the different stages we can see that the result is the same","title":"Queries"},{"location":"schema/Examples/SchemaExample-Composite/#query-on-default-stage","text":"lambdaorm execute -e \".env\" -s default -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).order(p=> p.id).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 3, \"customerId\": \"HANAR\", \"employeeId\": 4, \"orderDate\": \"1996-07-08T00:00:00.000+02:00\", \"requiredDate\": \"1996-08-05\", \"shippedDate\": \"1996-07-12\", \"shipViaId\": 2, \"freight\": 65.83, \"name\": \"Hanari Carnes\", \"address\": \"Rua do Pao, 67\", \"city\": \"Rio de Janeiro\", \"region\": \"RJ\", \"postalCode\": \"05454-876\", \"country\": \"Brazil\", \"details\": [ { \"quantity\": 10, \"unitPrice\": 7.7, \"product\": { \"name\": \"Jack's New England Clam Chowder\", \"category\": { \"name\": \"Seafood\" } } }, { \"quantity\": 35, \"unitPrice\": 42.4, \"product\": { \"name\": \"Manjimup Dried Apples\", \"category\": { \"name\": \"Produce\" } } }, { \"quantity\": 15, \"unitPrice\": 16.8, \"product\": { \"name\": \"Louisiana Fiery Hot Pepper Sauce\", \"category\": { \"name\": \"Condiments\" } } } ], \"customer\": { \"name\": \"Hanari Carnes\" } } ]","title":"Query on default stage"},{"location":"schema/Examples/SchemaExample-Composite/#same-query-on-insights-stage","text":"lambdaorm execute -e \".env\" -s insights -q \"Orders.filter(p => p.customerId == customerId).include(p => [p.customer.map(p => p.name), p.details.include(p => p.product.include(p => p.category.map(p => p.name)).map(p => p.name)).map(p => [p.quantity, p.unitPrice])]).order(p=> p.id).page(1,1)\" -d \"{\\\"customerId\\\": \\\"HANAR\\\"}\" Result: [ { \"id\": 3, \"customerId\": \"HANAR\", \"employeeId\": 4, \"orderDate\": \"1996-07-07T22:00:00.000Z\", \"requiredDate\": \"1996-08-04T22:00:00.000Z\", \"shippedDate\": \"1996-07-11T22:00:00.000Z\", \"shipViaId\": 2, \"freight\": 65.83, \"name\": \"Hanari Carnes\", \"address\": \"Rua do Pao, 67\", \"city\": \"Rio de Janeiro\", \"region\": \"RJ\", \"postalCode\": \"05454-876\", \"country\": \"Brazil\", \"customer\": { \"name\": \"Hanari Carnes\" }, \"details\": [ { \"quantity\": 10, \"unitPrice\": 7.7, \"product\": { \"name\": \"Jack's New England Clam Chowder\", \"category\": { \"name\": \"Seafood\" } } }, { \"quantity\": 35, \"unitPrice\": 42.4, \"product\": { \"name\": \"Manjimup Dried Apples\", \"category\": { \"name\": \"Produce\" } } }, { \"quantity\": 15, \"unitPrice\": 16.8, \"product\": { \"name\": \"Louisiana Fiery Hot Pepper Sauce\", \"category\": { \"name\": \"Condiments\" } } } ] } ]","title":"Same query on insights stage"},{"location":"schema/Examples/SchemaExample-Composite/#laboratories","text":"CLI - northwind CLI - northwind multiples datasources CLI - northwind multiples stages","title":"Laboratories"},{"location":"schema/Examples/SchemaExample-Extend/","text":"Extend Through the extends property we can extend the configuration in the schema. \\ Entities, mappings and mapping entities can be extended. Extend Entity In this scheme we can see how to extend entities. \\ In this case, the Countries and States entities are extended from the abstract entity Positions \\ It is not mandatory that the entity be abstract to be able to use it as a basis to extend domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States extends: Positions primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: sources: - name: source1 dialect: MySQL connection: host: localhost port: 3306 user: test password: test database: test Laboratories CLI - extend model","title":"Extend"},{"location":"schema/Examples/SchemaExample-Extend/#extend","text":"Through the extends property we can extend the configuration in the schema. \\ Entities, mappings and mapping entities can be extended.","title":"Extend"},{"location":"schema/Examples/SchemaExample-Extend/#extend-entity","text":"In this scheme we can see how to extend entities. \\ In this case, the Countries and States entities are extended from the abstract entity Positions \\ It is not mandatory that the entity be abstract to be able to use it as a basis to extend domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States extends: Positions primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: sources: - name: source1 dialect: MySQL connection: host: localhost port: 3306 user: test password: test database: test","title":"Extend Entity"},{"location":"schema/Examples/SchemaExample-Extend/#laboratories","text":"CLI - extend model","title":"Laboratories"},{"location":"schema/Examples/SchemaExample-Listener/","text":"Listener on Schema Listeners allow us to execute actions when an event occurs in the ORM. \\ events are set to the \"on\" property. \\ And the events that can be listened to are select, insert, bulkInsert, update and delete. \\ The \"condition\" property allows you to define an expression that is evaluated to determine if the listener is executed. \\ The expressions to be executed can be defined in the \"before\", \"after\" and \"error\" properties. \\ The parameters that we have to use in the expressions are: Parameter Description query The query expression that was executed data The data that was sent when the expression was executed options The options that were sent when the expression was executed result It is only available in the after event and contains the result of the expression execution action The action that was executed (select, insert, update, delete, upsert, merge, bulkInsert, bulkUpdate, bulkMerge) type The type of sentence that was executed (dql, ddl, dml) category The category of the sentence that was executed (select, insert, update, delete, upsert) sentence The sentence that was executed dialect The dialect of the source where the sentence was executed source The source where the sentence was executed entity The entity that was affected by the sentence error It is only available in the error event and contains the error that occurred Listener Example In this example we see how a Listener is declared to synchronize data in Insights. \\ When a record is inserted, updated or deleted in the default or cqrs stages, the listener is executed. \\ In this case, the expression is defined in the after property, which executes the same expression with the same data but in the stage insights. Part of the schema where the listener is defined: ... application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) Schema Complete: domain: enums: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights - name: cqrs sources: - name: Insights condition: action == \"select\" - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) Laboratories CLI - northwind cqrs","title":"Listener on Schema"},{"location":"schema/Examples/SchemaExample-Listener/#listener-on-schema","text":"Listeners allow us to execute actions when an event occurs in the ORM. \\ events are set to the \"on\" property. \\ And the events that can be listened to are select, insert, bulkInsert, update and delete. \\ The \"condition\" property allows you to define an expression that is evaluated to determine if the listener is executed. \\ The expressions to be executed can be defined in the \"before\", \"after\" and \"error\" properties. \\ The parameters that we have to use in the expressions are: Parameter Description query The query expression that was executed data The data that was sent when the expression was executed options The options that were sent when the expression was executed result It is only available in the after event and contains the result of the expression execution action The action that was executed (select, insert, update, delete, upsert, merge, bulkInsert, bulkUpdate, bulkMerge) type The type of sentence that was executed (dql, ddl, dml) category The category of the sentence that was executed (select, insert, update, delete, upsert) sentence The sentence that was executed dialect The dialect of the source where the sentence was executed source The source where the sentence was executed entity The entity that was affected by the sentence error It is only available in the error event and contains the error that occurred","title":"Listener on Schema"},{"location":"schema/Examples/SchemaExample-Listener/#listener-example","text":"In this example we see how a Listener is declared to synchronize data in Insights. \\ When a record is inserted, updated or deleted in the default or cqrs stages, the listener is executed. \\ In this case, the expression is defined in the after property, which executes the same expression with the same data but in the stage insights. Part of the schema where the listener is defined: ... application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"}) Schema Complete: domain: enums: entities: - name: Address abstract: true indexes: - name: postalCode fields: [\"postalCode\"] - name: region fields: [\"region\", \"country\"] - name: city fields: [\"city\"] properties: - name: address - name: city - name: region - name: postalCode length: 20 - name: country - name: Categories primaryKey: [\"id\"] uniqueKey: [\"name\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: Customers extends: Address primaryKey: [\"id\"] indexes: - name: name fields: [\"name\"] properties: - name: id length: 5 required: true - name: name required: true - name: Products primaryKey: [\"id\"] uniqueKey: [\"name\", \"supplierId\"] properties: - name: id type: integer required: true autoIncrement: true - name: name required: true - name: categoryId type: integer - name: quantity - name: price type: decimal default: 0 relations: - name: category from: categoryId entity: Categories to: id target: products - name: Orders primaryKey: [\"id\"] indexes: - name: orderDate fields: [\"orderDate\"] properties: - name: id type: integer required: true autoIncrement: true - name: customerId required: true length: 5 - name: orderDate type: dateTime relations: - name: customer from: customerId entity: Customers to: id target: orders - name: Orders.details primaryKey: [\"orderId\", \"productId\"] properties: - name: orderId required: true type: integer - name: productId required: true type: integer - name: unitPrice type: decimal - name: quantity type: decimal relations: - name: order from: orderId entity: Orders to: id target: details - name: product from: productId entity: Products to: id target: orderDetails infrastructure: views: - name: default mappings: - name: default entities: - name: Address abstract: true properties: - name: address mapping: Address - name: city mapping: City - name: region mapping: Region - name: postalCode mapping: PostalCode - name: country mapping: Country - name: Categories mapping: Categories properties: - name: id mapping: CategoryID - name: name mapping: CategoryName - name: Customers extends: Address mapping: Customers properties: - name: id mapping: CustomerID - name: name mapping: CompanyName - name: Products mapping: Products properties: - name: id mapping: ProductID - name: name mapping: ProductName - name: categoryId mapping: CategoryID - name: quantity mapping: QuantityPerUnit - name: price mapping: UnitPrice - name: Orders mapping: Orders properties: - name: id mapping: OrderID - name: customerId mapping: CustomerID - name: orderDate mapping: OrderDate - name: Orders.details mapping: Order Details properties: - name: orderId mapping: OrderID - name: productId mapping: ProductID - name: unitPrice mapping: UnitPrice - name: quantity mapping: Quantity - name: mongoDb extends: default entities: - name: Orders sequence: SQ_ORDERS properties: - name: id mapping: _id sources: - name: Catalog dialect: MySQL mapping: default connection: ${CNN_MYSQL} - name: Crm dialect: PostgreSQL mapping: default connection: ${CNN_POSTGRES} - name: Ordering dialect: MongoDB mapping: mongoDb connection: ${CNN_MONGODB} - name: Insights dialect: PostgreSQL mapping: default connection: ${CNN_INSIGHTS} stages: - name: default sources: - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) - name: insights sources: - name: Insights - name: cqrs sources: - name: Insights condition: action == \"select\" - name: Catalog condition: entity.in([\"Categories\",\"Products\"]) - name: Crm condition: entity.in([\"Address\",\"Customers\"]) - name: Ordering condition: entity.in([\"Orders\",\"Orders.details\"]) application: listeners: - name: syncInsights on: [insert, bulkInsert, update, delete ] condition: options.stage.in(\"default\",\"cqrs\") after: orm.execute(query,data,{stage:\"insights\"})","title":"Listener Example"},{"location":"schema/Examples/SchemaExample-Listener/#laboratories","text":"CLI - northwind cqrs","title":"Laboratories"},{"location":"schema/Examples/SchemaExample-MultiplesStages/","text":"Multiples Stages The scheme allows you to define different usage scenarios. These usage scenarios can be used for different reasons, for example: You can create a scenario to work with an Oracle Base and another with SqlServer with the same definition of the business model to perform performance tests. You can configure one stage as a source and another as a destination to perform data migrations. You can define one stage for read operations and another for write operations. You can define one stage for the development environment and another for the qa environment. Schema Example In this scheme we can see how to extend the schema. We use the extends attribute in the definition of the schema to extend it. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: mapping1 - name: mapping2 entities: - name: Countries mapping: TBL_COUNTRIES properties: - name: iso3 mapping: ISO3 - name: name mapping: NAME - name: States mapping: TBL_STATES properties: - name: id mapping: ID - name: name mapping: NAME - name: countryCode mapping: COUNTRY_CODE sources: - name: source1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: source2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES stages: - name: stage1 sources: - name: source1 - name: stage2 sources: - name: source2 Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"0.0.0.0\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} Laboratories CLI - two stages","title":"Multiples Stages"},{"location":"schema/Examples/SchemaExample-MultiplesStages/#multiples-stages","text":"The scheme allows you to define different usage scenarios. These usage scenarios can be used for different reasons, for example: You can create a scenario to work with an Oracle Base and another with SqlServer with the same definition of the business model to perform performance tests. You can configure one stage as a source and another as a destination to perform data migrations. You can define one stage for read operations and another for write operations. You can define one stage for the development environment and another for the qa environment.","title":"Multiples Stages"},{"location":"schema/Examples/SchemaExample-MultiplesStages/#schema-example","text":"In this scheme we can see how to extend the schema. We use the extends attribute in the definition of the schema to extend it. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: mapping1 - name: mapping2 entities: - name: Countries mapping: TBL_COUNTRIES properties: - name: iso3 mapping: ISO3 - name: name mapping: NAME - name: States mapping: TBL_STATES properties: - name: id mapping: ID - name: name mapping: NAME - name: countryCode mapping: COUNTRY_CODE sources: - name: source1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: source2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES stages: - name: stage1 sources: - name: source1 - name: stage2 sources: - name: source2 Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"0.0.0.0\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"}","title":"Schema Example"},{"location":"schema/Examples/SchemaExample-MultiplesStages/#laboratories","text":"CLI - two stages","title":"Laboratories"},{"location":"schema/Examples/SchemaExample-StageMultiplesSources/","text":"Stage related multiples Sources When the entities are in different databases, the data source for each entity must be specified in the stage configuration. This is done through the \"condition\" property, which is an expression that is evaluated for each entity and if true, the specified data source is used. Source conditions are evaluated in the order they are found in the stage, so if an entity meets the two-source condition, the data source from the first source that meets the condition will be used. Stage related to multiple Sources sharing the mapping This schema has two entities that are in different databases. The database attribute is used in the entity to be able to specify that an entity is in a database other than the default of the schema. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: sources: - name: dataSource1 dialect: MySQL connection: host: localhost port: 3306 user: test password: test database: test - name: dataSource2 dialect: PostgreSQL connection: host: localhost port: 5432 user: test password: test database: test stages: - name: stage1 sources: - name: dataSource2 condition: entity == \"States\" - name: dataSource1 Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"0.0.0.0\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} Stage related to multiple datasources with different mapping This example poses a stage where two sources are accessed. Data source 1 is mysql and contains the Countries table and source 2 is Postgres contains the States table. In the case of the Countries entity, both the name of the table and the fields coincide with the name of the entity and the name of the properties, so the mapping is transparent. But in the case of the States entity, the name of the table and its fields differ, so the mapping defines the mapping. domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true - name: region - name: subregion relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States extends: Positions primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: mapping1 - name: mapping2 entities: - name: States mapping: TBL_STATES properties: - name: id mapping: ID - name: name mapping: NAME - name: countryCode mapping: COUNTRY_CODE - name: latitude mapping: LATITUDE - name: longitude mapping: LONGITUDE sources: - name: dataSource1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: dataSource2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES stages: - name: stage1 sources: - name: dataSource2 condition: entity == \"States\" - name: dataSource1 Laboratories CLI - two datasource same query","title":"Stage related multiples Sources"},{"location":"schema/Examples/SchemaExample-StageMultiplesSources/#stage-related-multiples-sources","text":"When the entities are in different databases, the data source for each entity must be specified in the stage configuration. This is done through the \"condition\" property, which is an expression that is evaluated for each entity and if true, the specified data source is used. Source conditions are evaluated in the order they are found in the stage, so if an entity meets the two-source condition, the data source from the first source that meets the condition will be used.","title":"Stage related multiples Sources"},{"location":"schema/Examples/SchemaExample-StageMultiplesSources/#stage-related-to-multiple-sources-sharing-the-mapping","text":"This schema has two entities that are in different databases. The database attribute is used in the entity to be able to specify that an entity is in a database other than the default of the schema. domain: entities: - name: Countries primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: sources: - name: dataSource1 dialect: MySQL connection: host: localhost port: 3306 user: test password: test database: test - name: dataSource2 dialect: PostgreSQL connection: host: localhost port: 5432 user: test password: test database: test stages: - name: stage1 sources: - name: dataSource2 condition: entity == \"States\" - name: dataSource1 Environment Variables: CNN_MYSQL={\"host\":\"localhost\",\"port\":3306,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"} CNN_POSTGRES={\"host\":\"0.0.0.0\",\"port\":5433,\"user\":\"test\",\"password\":\"test\",\"database\":\"test\"}","title":"Stage related to multiple Sources sharing the mapping"},{"location":"schema/Examples/SchemaExample-StageMultiplesSources/#stage-related-to-multiple-datasources-with-different-mapping","text":"This example poses a stage where two sources are accessed. Data source 1 is mysql and contains the Countries table and source 2 is Postgres contains the States table. In the case of the Countries entity, both the name of the table and the fields coincide with the name of the entity and the name of the properties, so the mapping is transparent. But in the case of the States entity, the name of the table and its fields differ, so the mapping defines the mapping. domain: entities: - name: Positions abstract: true properties: - name: latitude length: 16 - name: longitude length: 16 - name: Countries extends: Positions primaryKey: [\"iso3\"] uniqueKey: [\"name\"] properties: - name: name required: true - name: iso3 length: 3 required: true - name: region - name: subregion relations: - name: states type: manyToOne composite: true from: iso3 entity: States to: countryCode - name: States extends: Positions primaryKey: [\"id\"] uniqueKey: [\"countryCode\", \"name\"] properties: - name: id type: integer required: true - name: name required: true - name: countryCode required: true length: 3 relations: - name: country from: countryCode entity: Countries to: iso3 infrastructure: mappings: - name: mapping1 - name: mapping2 entities: - name: States mapping: TBL_STATES properties: - name: id mapping: ID - name: name mapping: NAME - name: countryCode mapping: COUNTRY_CODE - name: latitude mapping: LATITUDE - name: longitude mapping: LONGITUDE sources: - name: dataSource1 dialect: MySQL mapping: mapping1 connection: $CNN_MYSQL - name: dataSource2 dialect: PostgreSQL mapping: mapping2 connection: $CNN_POSTGRES stages: - name: stage1 sources: - name: dataSource2 condition: entity == \"States\" - name: dataSource1","title":"Stage related to multiple datasources with different mapping"},{"location":"schema/Examples/SchemaExample-StageMultiplesSources/#laboratories","text":"CLI - two datasource same query","title":"Laboratories"},{"location":"schema/Synchronization/SchemaSynchronization-Fetch/","text":"Fetch The fetch is the process show differences between sources and schema but not apply changes.The pull process is done by the command lambdaorm fetch . CLI The fetch command allows you to obtain the mapping of the database tables. \\ Using the -o argument you can specify the output format, in this case yaml. \\ The mapping.yaml file will contain the mapping of the database tables. \\ Ejecuci\u00f3n del comando fetch lambdaorm fetch -o yaml > mapping.yaml View lab Node The fetch command allows you to obtain the mapping of the database tables. \\ Using the -o argument you can specify the output format, in this case yaml. \\ The mapping.yaml file will contain the mapping of the database tables. \\ import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const orm = new Orm(workspace) try{ const originalSchema = orm.helper.yaml.load(await orm.helper.fs.read(workspace + '/lambdaOrm.yaml')) await orm.init(originalSchema) const mappings = await orm.stage.fetch() await orm.helper.fs.write( workspace + '/mappings.yaml', orm.helper.yaml.dump(mappings)) }catch(e){ console.log(e) } finally { await orm.end() } })() View lab","title":"Fetch"},{"location":"schema/Synchronization/SchemaSynchronization-Fetch/#fetch","text":"The fetch is the process show differences between sources and schema but not apply changes.The pull process is done by the command lambdaorm fetch .","title":"Fetch"},{"location":"schema/Synchronization/SchemaSynchronization-Fetch/#cli","text":"The fetch command allows you to obtain the mapping of the database tables. \\ Using the -o argument you can specify the output format, in this case yaml. \\ The mapping.yaml file will contain the mapping of the database tables. \\ Ejecuci\u00f3n del comando fetch lambdaorm fetch -o yaml > mapping.yaml View lab","title":"CLI"},{"location":"schema/Synchronization/SchemaSynchronization-Fetch/#node","text":"The fetch command allows you to obtain the mapping of the database tables. \\ Using the -o argument you can specify the output format, in this case yaml. \\ The mapping.yaml file will contain the mapping of the database tables. \\ import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const orm = new Orm(workspace) try{ const originalSchema = orm.helper.yaml.load(await orm.helper.fs.read(workspace + '/lambdaOrm.yaml')) await orm.init(originalSchema) const mappings = await orm.stage.fetch() await orm.helper.fs.write( workspace + '/mappings.yaml', orm.helper.yaml.dump(mappings)) }catch(e){ console.log(e) } finally { await orm.end() } })() View lab","title":"Node"},{"location":"schema/Synchronization/SchemaSynchronization-Incorporate/","text":"Incorporate Onboarding is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (databases) and then importing the data into the sources (Databases). The introspection process is performed using the lambdaorm incorporate command. CLI The incorporate command does the following: Update the schema Generate and apply scripts to synchronize the schema with the data source Import data from data source Running the incorporate command: lambdaorm incorporate -d countries.json -n countries Files generated: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-data.json \u2502 \u251c\u2500\u2500 default-ddl-20240502T113912983Z-push-default.sql \u2502 \u2514\u2500\u2500 default-model.json Scripts generated in default-ddl-20240502T113912983Z-push-default.sql : CREATE TABLE CountriesLanguages (id INTEGER AUTO_INCREMENT,languageCode VARCHAR(4) NOT NULL ,countryName VARCHAR(32) NOT NULL ,CONSTRAINT CountriesLanguages_PK PRIMARY KEY (id)); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_UK UNIQUE (countryName,languageCode); CREATE TABLE Languages (code VARCHAR(4) NOT NULL ,name VARCHAR(16) NOT NULL ,CONSTRAINT Languages_PK PRIMARY KEY (code)); CREATE TABLE Regions (code VARCHAR(2) NOT NULL ,name VARCHAR(32) NOT NULL ,CONSTRAINT Regions_PK PRIMARY KEY (code)); CREATE TABLE Positions (lat DECIMAL(10,4) NOT NULL ,`long` DECIMAL(10,4) NOT NULL ,CONSTRAINT Positions_PK PRIMARY KEY (lat)); ALTER TABLE Positions ADD CONSTRAINT Positions_UK UNIQUE (`long`); CREATE TABLE Timezones (GmtOffset INTEGER ,name VARCHAR(32) NOT NULL ,positionLat DECIMAL(10,4) NOT NULL ,countryName VARCHAR(32) NOT NULL ,CONSTRAINT Timezones_PK PRIMARY KEY (name)); CREATE TABLE Countries (name VARCHAR(32) NOT NULL ,phoneCode INTEGER NOT NULL ,priority INTEGER NOT NULL ,regionCode VARCHAR(2) NOT NULL ,CONSTRAINT Countries_PK PRIMARY KEY (name)); ALTER TABLE Countries ADD CONSTRAINT Countries_UK UNIQUE (phoneCode); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_countries_FK FOREIGN KEY (countryName) REFERENCES Countries (name); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_languages_FK FOREIGN KEY (languageCode) REFERENCES Languages (code); ALTER TABLE Timezones ADD CONSTRAINT Timezones_position_FK FOREIGN KEY (positionLat) REFERENCES Positions (lat); ALTER TABLE Timezones ADD CONSTRAINT Timezones_countries_FK FOREIGN KEY (countryName) REFERENCES Countries (name); ALTER TABLE Countries ADD CONSTRAINT Countries_region_FK FOREIGN KEY (regionCode) REFERENCES Regions (code); View lab Node The incorporate command does the following: Update the schema Generate and apply scripts to synchronize the schema with the data source Import data from data source import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const schemaPath = workspace + '/lambdaOrm.yaml' const orm = new Orm(workspace) try{ const data = JSON.parse( await orm.helper.fs.read(workspace + '/countries.json') || '{}') await orm.init(schemaPath) await orm.stage.incorporate(data, 'countries') }catch(e){ console.log(e) } finally { await orm.end() } })() As a result: The \"lambdaORM.yaml\" file will be updated according to the type introspected from the data. The updated schema is synchronized with the data source. Files are created with the model status and update scripts. View lab","title":"Incorporate"},{"location":"schema/Synchronization/SchemaSynchronization-Incorporate/#incorporate","text":"Onboarding is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (databases) and then importing the data into the sources (Databases). The introspection process is performed using the lambdaorm incorporate command.","title":"Incorporate"},{"location":"schema/Synchronization/SchemaSynchronization-Incorporate/#cli","text":"The incorporate command does the following: Update the schema Generate and apply scripts to synchronize the schema with the data source Import data from data source Running the incorporate command: lambdaorm incorporate -d countries.json -n countries Files generated: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-data.json \u2502 \u251c\u2500\u2500 default-ddl-20240502T113912983Z-push-default.sql \u2502 \u2514\u2500\u2500 default-model.json Scripts generated in default-ddl-20240502T113912983Z-push-default.sql : CREATE TABLE CountriesLanguages (id INTEGER AUTO_INCREMENT,languageCode VARCHAR(4) NOT NULL ,countryName VARCHAR(32) NOT NULL ,CONSTRAINT CountriesLanguages_PK PRIMARY KEY (id)); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_UK UNIQUE (countryName,languageCode); CREATE TABLE Languages (code VARCHAR(4) NOT NULL ,name VARCHAR(16) NOT NULL ,CONSTRAINT Languages_PK PRIMARY KEY (code)); CREATE TABLE Regions (code VARCHAR(2) NOT NULL ,name VARCHAR(32) NOT NULL ,CONSTRAINT Regions_PK PRIMARY KEY (code)); CREATE TABLE Positions (lat DECIMAL(10,4) NOT NULL ,`long` DECIMAL(10,4) NOT NULL ,CONSTRAINT Positions_PK PRIMARY KEY (lat)); ALTER TABLE Positions ADD CONSTRAINT Positions_UK UNIQUE (`long`); CREATE TABLE Timezones (GmtOffset INTEGER ,name VARCHAR(32) NOT NULL ,positionLat DECIMAL(10,4) NOT NULL ,countryName VARCHAR(32) NOT NULL ,CONSTRAINT Timezones_PK PRIMARY KEY (name)); CREATE TABLE Countries (name VARCHAR(32) NOT NULL ,phoneCode INTEGER NOT NULL ,priority INTEGER NOT NULL ,regionCode VARCHAR(2) NOT NULL ,CONSTRAINT Countries_PK PRIMARY KEY (name)); ALTER TABLE Countries ADD CONSTRAINT Countries_UK UNIQUE (phoneCode); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_countries_FK FOREIGN KEY (countryName) REFERENCES Countries (name); ALTER TABLE CountriesLanguages ADD CONSTRAINT CountriesLanguages_languages_FK FOREIGN KEY (languageCode) REFERENCES Languages (code); ALTER TABLE Timezones ADD CONSTRAINT Timezones_position_FK FOREIGN KEY (positionLat) REFERENCES Positions (lat); ALTER TABLE Timezones ADD CONSTRAINT Timezones_countries_FK FOREIGN KEY (countryName) REFERENCES Countries (name); ALTER TABLE Countries ADD CONSTRAINT Countries_region_FK FOREIGN KEY (regionCode) REFERENCES Regions (code); View lab","title":"CLI"},{"location":"schema/Synchronization/SchemaSynchronization-Incorporate/#node","text":"The incorporate command does the following: Update the schema Generate and apply scripts to synchronize the schema with the data source Import data from data source import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const schemaPath = workspace + '/lambdaOrm.yaml' const orm = new Orm(workspace) try{ const data = JSON.parse( await orm.helper.fs.read(workspace + '/countries.json') || '{}') await orm.init(schemaPath) await orm.stage.incorporate(data, 'countries') }catch(e){ console.log(e) } finally { await orm.end() } })() As a result: The \"lambdaORM.yaml\" file will be updated according to the type introspected from the data. The updated schema is synchronized with the data source. Files are created with the model status and update scripts. View lab","title":"Node"},{"location":"schema/Synchronization/SchemaSynchronization-Introspect/","text":"Introspect Introspection is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (Databases). The introspection process is performed using the lambdaorm introspect command. CLI The introspect command allows you to obtain the schema from data introspection. Running the introspect command: lambdaorm introspect -d countries.json -n counties This command updates the schema based on data introspection, in this case from the country.json file. Files created: \u251c\u2500\u2500 countries.json \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20240502T182117031Z-push-default.sql \u2502 \u2514\u2500\u2500 default-model.json \u251c\u2500\u2500 docker compose.yaml \u2514\u2500\u2500 lambdaORM.yaml Script the synchronization in file \"default-ddl-20240502T182117031Z-push-default.sql\": CREATE TABLE CountiesLanguages (id INTEGER AUTO_INCREMENT,languageCode VARCHAR(4) NOT NULL ,countyName VARCHAR(32) NOT NULL ,CONSTRAINT CountiesLanguages_PK PRIMARY KEY (id)); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_UK UNIQUE (countyName,languageCode); CREATE TABLE Languages (code VARCHAR(4) NOT NULL ,name VARCHAR(16) NOT NULL ,CONSTRAINT Languages_PK PRIMARY KEY (code)); CREATE TABLE Regions (code VARCHAR(2) NOT NULL ,name VARCHAR(32) NOT NULL ,CONSTRAINT Regions_PK PRIMARY KEY (code)); CREATE TABLE Positions (lat DECIMAL(10,4) NOT NULL ,`long` DECIMAL(10,4) NOT NULL ,CONSTRAINT Positions_PK PRIMARY KEY (lat)); ALTER TABLE Positions ADD CONSTRAINT Positions_UK UNIQUE (`long`); CREATE TABLE Timezones (GmtOffset INTEGER ,name VARCHAR(32) NOT NULL ,positionLat DECIMAL(10,4) NOT NULL ,countyName VARCHAR(32) NOT NULL ,CONSTRAINT Timezones_PK PRIMARY KEY (name)); CREATE TABLE Counties (name VARCHAR(32) NOT NULL ,phoneCode INTEGER NOT NULL ,priority INTEGER NOT NULL ,regionCode VARCHAR(2) NOT NULL ,CONSTRAINT Counties_PK PRIMARY KEY (name)); ALTER TABLE Counties ADD CONSTRAINT Counties_UK UNIQUE (phoneCode); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_counties_FK FOREIGN KEY (countyName) REFERENCES Counties (name); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_languages_FK FOREIGN KEY (languageCode) REFERENCES Languages (code); ALTER TABLE Timezones ADD CONSTRAINT Timezones_position_FK FOREIGN KEY (positionLat) REFERENCES Positions (lat); ALTER TABLE Timezones ADD CONSTRAINT Timezones_counties_FK FOREIGN KEY (countyName) REFERENCES Counties (name); ALTER TABLE Counties ADD CONSTRAINT Counties_region_FK FOREIGN KEY (regionCode) REFERENCES Regions (code); View lab Node How to run the introspect method to: Update the schema according to the introspected type of data. Synchronize the schema with the data source. Create files with the model status and update scripts. import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const schemaPath = workspace + '/lambdaORM.yaml' const orm = new Orm(workspace) try{ const data = JSON.parse( await orm.helper.fs.read(workspace + '/countries.json') || '{}') await orm.init(schemaPath) await orm.stage.introspect(data, 'countries') }catch(e){ console.log(e) } finally { await orm.end() } })() As a result: The \"lambdaORM.yaml\" file will be updated according to the type introspected from the data. The updated schema is synchronized with the data source. Files are created with the model status and update scripts. View lab","title":"Introspect"},{"location":"schema/Synchronization/SchemaSynchronization-Introspect/#introspect","text":"Introspection is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (Databases). The introspection process is performed using the lambdaorm introspect command.","title":"Introspect"},{"location":"schema/Synchronization/SchemaSynchronization-Introspect/#cli","text":"The introspect command allows you to obtain the schema from data introspection. Running the introspect command: lambdaorm introspect -d countries.json -n counties This command updates the schema based on data introspection, in this case from the country.json file. Files created: \u251c\u2500\u2500 countries.json \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20240502T182117031Z-push-default.sql \u2502 \u2514\u2500\u2500 default-model.json \u251c\u2500\u2500 docker compose.yaml \u2514\u2500\u2500 lambdaORM.yaml Script the synchronization in file \"default-ddl-20240502T182117031Z-push-default.sql\": CREATE TABLE CountiesLanguages (id INTEGER AUTO_INCREMENT,languageCode VARCHAR(4) NOT NULL ,countyName VARCHAR(32) NOT NULL ,CONSTRAINT CountiesLanguages_PK PRIMARY KEY (id)); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_UK UNIQUE (countyName,languageCode); CREATE TABLE Languages (code VARCHAR(4) NOT NULL ,name VARCHAR(16) NOT NULL ,CONSTRAINT Languages_PK PRIMARY KEY (code)); CREATE TABLE Regions (code VARCHAR(2) NOT NULL ,name VARCHAR(32) NOT NULL ,CONSTRAINT Regions_PK PRIMARY KEY (code)); CREATE TABLE Positions (lat DECIMAL(10,4) NOT NULL ,`long` DECIMAL(10,4) NOT NULL ,CONSTRAINT Positions_PK PRIMARY KEY (lat)); ALTER TABLE Positions ADD CONSTRAINT Positions_UK UNIQUE (`long`); CREATE TABLE Timezones (GmtOffset INTEGER ,name VARCHAR(32) NOT NULL ,positionLat DECIMAL(10,4) NOT NULL ,countyName VARCHAR(32) NOT NULL ,CONSTRAINT Timezones_PK PRIMARY KEY (name)); CREATE TABLE Counties (name VARCHAR(32) NOT NULL ,phoneCode INTEGER NOT NULL ,priority INTEGER NOT NULL ,regionCode VARCHAR(2) NOT NULL ,CONSTRAINT Counties_PK PRIMARY KEY (name)); ALTER TABLE Counties ADD CONSTRAINT Counties_UK UNIQUE (phoneCode); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_counties_FK FOREIGN KEY (countyName) REFERENCES Counties (name); ALTER TABLE CountiesLanguages ADD CONSTRAINT CountiesLanguages_languages_FK FOREIGN KEY (languageCode) REFERENCES Languages (code); ALTER TABLE Timezones ADD CONSTRAINT Timezones_position_FK FOREIGN KEY (positionLat) REFERENCES Positions (lat); ALTER TABLE Timezones ADD CONSTRAINT Timezones_counties_FK FOREIGN KEY (countyName) REFERENCES Counties (name); ALTER TABLE Counties ADD CONSTRAINT Counties_region_FK FOREIGN KEY (regionCode) REFERENCES Regions (code); View lab","title":"CLI"},{"location":"schema/Synchronization/SchemaSynchronization-Introspect/#node","text":"How to run the introspect method to: Update the schema according to the introspected type of data. Synchronize the schema with the data source. Create files with the model status and update scripts. import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const schemaPath = workspace + '/lambdaORM.yaml' const orm = new Orm(workspace) try{ const data = JSON.parse( await orm.helper.fs.read(workspace + '/countries.json') || '{}') await orm.init(schemaPath) await orm.stage.introspect(data, 'countries') }catch(e){ console.log(e) } finally { await orm.end() } })() As a result: The \"lambdaORM.yaml\" file will be updated according to the type introspected from the data. The updated schema is synchronized with the data source. Files are created with the model status and update scripts. View lab","title":"Node"},{"location":"schema/Synchronization/SchemaSynchronization-Pull/","text":"Pull The pull is the process of updating the schema defined in the configuration file with the structure in the sources (Databases). The pull process is done by the command lambdaorm pull . CLI The pull command is used to update the schema with respect to the sources (Databases). \\ Once executed, the schema will be synchronized with the database. \\ It also adds a file with the pulling scripts. \\ Running the pull command: lambdaorm pull Once the command is executed, the schema file (lambdaORM.yaml in this case) will be updated with respect to the data source. Files created: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20240501T212640369Z-pull-default.sql \u2502 \u2514\u2500\u2500 default-model.json Content of the generated file default-ddl-20240501T212640369Z-pull-default.sql : CREATE TABLE Categories (CategoryID INTEGER AUTO_INCREMENT,CategoryName VARCHAR(15) NOT NULL ,Description TEXT ,Picture LONGBLOB ,CONSTRAINT Categories_PK PRIMARY KEY (CategoryID)); CREATE TABLE CustomerCustomerDemo (CustomerID VARCHAR(5) NOT NULL ,CustomerTypeID VARCHAR(10) NOT NULL ,CONSTRAINT CustomerCustomerDemo_PK PRIMARY KEY (CustomerID,CustomerTypeID)); CREATE TABLE CustomerDemographics (CustomerTypeID VARCHAR(10) NOT NULL ,CustomerDesc TEXT ,CONSTRAINT CustomerDemographics_PK PRIMARY KEY (CustomerTypeID)); CREATE TABLE Customers (CustomerID VARCHAR(5) NOT NULL ,CompanyName VARCHAR(40) NOT NULL ,ContactName VARCHAR(30) ,ContactTitle VARCHAR(30) ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,Phone VARCHAR(24) ,Fax VARCHAR(24) ,CONSTRAINT Customers_PK PRIMARY KEY (CustomerID)); CREATE TABLE EmployeeTerritories (EmployeeID INTEGER NOT NULL ,TerritoryID VARCHAR(20) NOT NULL ,CONSTRAINT EmployeeTerritories_PK PRIMARY KEY (EmployeeID,TerritoryID)); CREATE TABLE Employees (EmployeeID INTEGER AUTO_INCREMENT,LastName VARCHAR(20) NOT NULL ,FirstName VARCHAR(10) NOT NULL ,Title VARCHAR(30) ,TitleOfCourtesy VARCHAR(25) ,BirthDate DATETIME ,HireDate DATETIME ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,HomePhone VARCHAR(24) ,Extension VARCHAR(4) ,Photo LONGBLOB ,Notes TEXT NOT NULL ,ReportsTo INTEGER ,PhotoPath VARCHAR(255) ,Salary DECIMAL(10,4) ,CONSTRAINT Employees_PK PRIMARY KEY (EmployeeID)); CREATE TABLE `Order Details` (OrderID INTEGER NOT NULL ,ProductID INTEGER NOT NULL ,UnitPrice DECIMAL(10,4) NOT NULL ,Quantity INTEGER NOT NULL ,Discount DECIMAL(10,4) NOT NULL ,CONSTRAINT `Order Details_PK` PRIMARY KEY (OrderID,ProductID)); CREATE TABLE Orders (OrderID INTEGER AUTO_INCREMENT,CustomerID VARCHAR(5) NOT NULL ,EmployeeID INTEGER NOT NULL ,OrderDate DATETIME ,RequiredDate DATETIME ,ShippedDate DATETIME ,ShipVia INTEGER ,Freight DECIMAL(10,4) ,ShipName VARCHAR(40) ,ShipAddress VARCHAR(60) ,ShipCity VARCHAR(15) ,ShipRegion VARCHAR(15) ,ShipPostalCode VARCHAR(10) ,ShipCountry VARCHAR(15) ,CONSTRAINT Orders_PK PRIMARY KEY (CustomerID,EmployeeID,OrderID)); CREATE TABLE Products (ProductID INTEGER AUTO_INCREMENT,ProductName VARCHAR(40) NOT NULL ,SupplierID INTEGER NOT NULL ,CategoryID INTEGER NOT NULL ,QuantityPerUnit VARCHAR(20) ,UnitPrice DECIMAL(10,4) ,UnitsInStock INTEGER ,UnitsOnOrder INTEGER ,ReorderLevel INTEGER ,Discontinued INTEGER NOT NULL ,CONSTRAINT Products_PK PRIMARY KEY (CategoryID,ProductID,SupplierID)); CREATE TABLE Region (RegionID INTEGER NOT NULL ,RegionDescription VARCHAR(50) NOT NULL ,CONSTRAINT Region_PK PRIMARY KEY (RegionID)); CREATE TABLE Shippers (ShipperID INTEGER AUTO_INCREMENT,CompanyName VARCHAR(40) NOT NULL ,Phone VARCHAR(24) ,CONSTRAINT Shippers_PK PRIMARY KEY (ShipperID)); CREATE TABLE Suppliers (SupplierID INTEGER AUTO_INCREMENT,CompanyName VARCHAR(40) NOT NULL ,ContactName VARCHAR(30) ,ContactTitle VARCHAR(30) ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,Phone VARCHAR(24) ,Fax VARCHAR(24) ,HomePage TEXT ,CONSTRAINT Suppliers_PK PRIMARY KEY (SupplierID)); CREATE TABLE Territories (TerritoryID VARCHAR(20) NOT NULL ,TerritoryDescription VARCHAR(50) NOT NULL ,RegionID INTEGER NOT NULL ,CONSTRAINT Territories_PK PRIMARY KEY (TerritoryID,RegionID)); ALTER TABLE CustomerCustomerDemo ADD CONSTRAINT CustomerCustomerDemo_customerCustomerDemo_FK FOREIGN KEY (CustomerTypeID) REFERENCES CustomerDemographics (CustomerTypeID); ALTER TABLE CustomerCustomerDemo ADD CONSTRAINT CustomerCustomerDemo_customerCustomerDemo_FK FOREIGN KEY (CustomerID) REFERENCES Customers (CustomerID); ALTER TABLE EmployeeTerritories ADD CONSTRAINT EmployeeTerritories_employeeTerritories_FK FOREIGN KEY (EmployeeID) REFERENCES Employees (EmployeeID); ALTER TABLE Employees ADD CONSTRAINT Employees_employees_FK FOREIGN KEY (ReportsTo) REFERENCES Employees (EmployeeID); ALTER TABLE `Order Details` ADD CONSTRAINT `Order Details_order_FK` FOREIGN KEY (OrderID) REFERENCES Orders (OrderID); ALTER TABLE `Order Details` ADD CONSTRAINT `Order Details_order_FK` FOREIGN KEY (ProductID) REFERENCES Products (ProductID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (CustomerID) REFERENCES Customers (CustomerID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (EmployeeID) REFERENCES Employees (EmployeeID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (ShipVia) REFERENCES Shippers (ShipperID); ALTER TABLE Products ADD CONSTRAINT Products_products_FK FOREIGN KEY (CategoryID) REFERENCES Categories (CategoryID); ALTER TABLE Products ADD CONSTRAINT Products_products_FK FOREIGN KEY (SupplierID) REFERENCES Suppliers (SupplierID); ALTER TABLE Territories ADD CONSTRAINT Territories_territories_FK FOREIGN KEY (RegionID) REFERENCES Region (RegionID); View lab Node import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const orm = new Orm(workspace) try{ await orm.helper.fs.removeDir(workspace + '/data') const originalSchema = orm.helper.yaml.load(await orm.helper.fs.read(workspace + '/lambdaOrm.yaml')) await orm.init(originalSchema) await orm.stage.pull() }catch(e){ console.log(e) } finally { await orm.end() } })() view lab","title":"Pull"},{"location":"schema/Synchronization/SchemaSynchronization-Pull/#pull","text":"The pull is the process of updating the schema defined in the configuration file with the structure in the sources (Databases). The pull process is done by the command lambdaorm pull .","title":"Pull"},{"location":"schema/Synchronization/SchemaSynchronization-Pull/#cli","text":"The pull command is used to update the schema with respect to the sources (Databases). \\ Once executed, the schema will be synchronized with the database. \\ It also adds a file with the pulling scripts. \\ Running the pull command: lambdaorm pull Once the command is executed, the schema file (lambdaORM.yaml in this case) will be updated with respect to the data source. Files created: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20240501T212640369Z-pull-default.sql \u2502 \u2514\u2500\u2500 default-model.json Content of the generated file default-ddl-20240501T212640369Z-pull-default.sql : CREATE TABLE Categories (CategoryID INTEGER AUTO_INCREMENT,CategoryName VARCHAR(15) NOT NULL ,Description TEXT ,Picture LONGBLOB ,CONSTRAINT Categories_PK PRIMARY KEY (CategoryID)); CREATE TABLE CustomerCustomerDemo (CustomerID VARCHAR(5) NOT NULL ,CustomerTypeID VARCHAR(10) NOT NULL ,CONSTRAINT CustomerCustomerDemo_PK PRIMARY KEY (CustomerID,CustomerTypeID)); CREATE TABLE CustomerDemographics (CustomerTypeID VARCHAR(10) NOT NULL ,CustomerDesc TEXT ,CONSTRAINT CustomerDemographics_PK PRIMARY KEY (CustomerTypeID)); CREATE TABLE Customers (CustomerID VARCHAR(5) NOT NULL ,CompanyName VARCHAR(40) NOT NULL ,ContactName VARCHAR(30) ,ContactTitle VARCHAR(30) ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,Phone VARCHAR(24) ,Fax VARCHAR(24) ,CONSTRAINT Customers_PK PRIMARY KEY (CustomerID)); CREATE TABLE EmployeeTerritories (EmployeeID INTEGER NOT NULL ,TerritoryID VARCHAR(20) NOT NULL ,CONSTRAINT EmployeeTerritories_PK PRIMARY KEY (EmployeeID,TerritoryID)); CREATE TABLE Employees (EmployeeID INTEGER AUTO_INCREMENT,LastName VARCHAR(20) NOT NULL ,FirstName VARCHAR(10) NOT NULL ,Title VARCHAR(30) ,TitleOfCourtesy VARCHAR(25) ,BirthDate DATETIME ,HireDate DATETIME ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,HomePhone VARCHAR(24) ,Extension VARCHAR(4) ,Photo LONGBLOB ,Notes TEXT NOT NULL ,ReportsTo INTEGER ,PhotoPath VARCHAR(255) ,Salary DECIMAL(10,4) ,CONSTRAINT Employees_PK PRIMARY KEY (EmployeeID)); CREATE TABLE `Order Details` (OrderID INTEGER NOT NULL ,ProductID INTEGER NOT NULL ,UnitPrice DECIMAL(10,4) NOT NULL ,Quantity INTEGER NOT NULL ,Discount DECIMAL(10,4) NOT NULL ,CONSTRAINT `Order Details_PK` PRIMARY KEY (OrderID,ProductID)); CREATE TABLE Orders (OrderID INTEGER AUTO_INCREMENT,CustomerID VARCHAR(5) NOT NULL ,EmployeeID INTEGER NOT NULL ,OrderDate DATETIME ,RequiredDate DATETIME ,ShippedDate DATETIME ,ShipVia INTEGER ,Freight DECIMAL(10,4) ,ShipName VARCHAR(40) ,ShipAddress VARCHAR(60) ,ShipCity VARCHAR(15) ,ShipRegion VARCHAR(15) ,ShipPostalCode VARCHAR(10) ,ShipCountry VARCHAR(15) ,CONSTRAINT Orders_PK PRIMARY KEY (CustomerID,EmployeeID,OrderID)); CREATE TABLE Products (ProductID INTEGER AUTO_INCREMENT,ProductName VARCHAR(40) NOT NULL ,SupplierID INTEGER NOT NULL ,CategoryID INTEGER NOT NULL ,QuantityPerUnit VARCHAR(20) ,UnitPrice DECIMAL(10,4) ,UnitsInStock INTEGER ,UnitsOnOrder INTEGER ,ReorderLevel INTEGER ,Discontinued INTEGER NOT NULL ,CONSTRAINT Products_PK PRIMARY KEY (CategoryID,ProductID,SupplierID)); CREATE TABLE Region (RegionID INTEGER NOT NULL ,RegionDescription VARCHAR(50) NOT NULL ,CONSTRAINT Region_PK PRIMARY KEY (RegionID)); CREATE TABLE Shippers (ShipperID INTEGER AUTO_INCREMENT,CompanyName VARCHAR(40) NOT NULL ,Phone VARCHAR(24) ,CONSTRAINT Shippers_PK PRIMARY KEY (ShipperID)); CREATE TABLE Suppliers (SupplierID INTEGER AUTO_INCREMENT,CompanyName VARCHAR(40) NOT NULL ,ContactName VARCHAR(30) ,ContactTitle VARCHAR(30) ,Address VARCHAR(60) ,City VARCHAR(15) ,Region VARCHAR(15) ,PostalCode VARCHAR(10) ,Country VARCHAR(15) ,Phone VARCHAR(24) ,Fax VARCHAR(24) ,HomePage TEXT ,CONSTRAINT Suppliers_PK PRIMARY KEY (SupplierID)); CREATE TABLE Territories (TerritoryID VARCHAR(20) NOT NULL ,TerritoryDescription VARCHAR(50) NOT NULL ,RegionID INTEGER NOT NULL ,CONSTRAINT Territories_PK PRIMARY KEY (TerritoryID,RegionID)); ALTER TABLE CustomerCustomerDemo ADD CONSTRAINT CustomerCustomerDemo_customerCustomerDemo_FK FOREIGN KEY (CustomerTypeID) REFERENCES CustomerDemographics (CustomerTypeID); ALTER TABLE CustomerCustomerDemo ADD CONSTRAINT CustomerCustomerDemo_customerCustomerDemo_FK FOREIGN KEY (CustomerID) REFERENCES Customers (CustomerID); ALTER TABLE EmployeeTerritories ADD CONSTRAINT EmployeeTerritories_employeeTerritories_FK FOREIGN KEY (EmployeeID) REFERENCES Employees (EmployeeID); ALTER TABLE Employees ADD CONSTRAINT Employees_employees_FK FOREIGN KEY (ReportsTo) REFERENCES Employees (EmployeeID); ALTER TABLE `Order Details` ADD CONSTRAINT `Order Details_order_FK` FOREIGN KEY (OrderID) REFERENCES Orders (OrderID); ALTER TABLE `Order Details` ADD CONSTRAINT `Order Details_order_FK` FOREIGN KEY (ProductID) REFERENCES Products (ProductID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (CustomerID) REFERENCES Customers (CustomerID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (EmployeeID) REFERENCES Employees (EmployeeID); ALTER TABLE Orders ADD CONSTRAINT Orders_orders_FK FOREIGN KEY (ShipVia) REFERENCES Shippers (ShipperID); ALTER TABLE Products ADD CONSTRAINT Products_products_FK FOREIGN KEY (CategoryID) REFERENCES Categories (CategoryID); ALTER TABLE Products ADD CONSTRAINT Products_products_FK FOREIGN KEY (SupplierID) REFERENCES Suppliers (SupplierID); ALTER TABLE Territories ADD CONSTRAINT Territories_territories_FK FOREIGN KEY (RegionID) REFERENCES Region (RegionID); View lab","title":"CLI"},{"location":"schema/Synchronization/SchemaSynchronization-Pull/#node","text":"import { Orm } from 'lambdaorm' (async () => { const workspace = process.cwd() const orm = new Orm(workspace) try{ await orm.helper.fs.removeDir(workspace + '/data') const originalSchema = orm.helper.yaml.load(await orm.helper.fs.read(workspace + '/lambdaOrm.yaml')) await orm.init(originalSchema) await orm.stage.pull() }catch(e){ console.log(e) } finally { await orm.end() } })() view lab","title":"Node"},{"location":"schema/Synchronization/SchemaSynchronization-Push/","text":"Push The push is the process of updating the sources (Databases) with the schema defined in the configuration file. The push process is done by the command lambdaorm push . CLI When executing the push command, ddl code will be executed according to the definition in the lambdaorm schema file. Tables, indexes and keys will be created The executed code is added to a file in the data folder. The [source-name]-model.json file will be created or updated which maintains the source state since the last synchronization. lambdaorm push Files generated: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20231122T154351640Z-push-test.sql \u2502 \u2514\u2500\u2500 default-model.json Content of the generated file default-ddl-20231122T154351640Z-push-test.sql : CREATE TABLE Countries (name VARCHAR(80) NOT NULL ,iso3 VARCHAR(3) NOT NULL ,CONSTRAINT Countries_PK PRIMARY KEY (iso3)); ALTER TABLE Countries ADD CONSTRAINT Countries_UK UNIQUE (name); CREATE TABLE States (id INTEGER NOT NULL ,name VARCHAR(80) NOT NULL ,countryCode VARCHAR(3) NOT NULL ,CONSTRAINT States_PK PRIMARY KEY (id)); ALTER TABLE States ADD CONSTRAINT States_UK UNIQUE (countryCode,name); ALTER TABLE States ADD CONSTRAINT States_country_FK FOREIGN KEY (countryCode) REFERENCES Countries (iso3); View labs: Simple Two stages Northwind Northwind multiple datasources Northwind CQRS","title":"Push"},{"location":"schema/Synchronization/SchemaSynchronization-Push/#push","text":"The push is the process of updating the sources (Databases) with the schema defined in the configuration file. The push process is done by the command lambdaorm push .","title":"Push"},{"location":"schema/Synchronization/SchemaSynchronization-Push/#cli","text":"When executing the push command, ddl code will be executed according to the definition in the lambdaorm schema file. Tables, indexes and keys will be created The executed code is added to a file in the data folder. The [source-name]-model.json file will be created or updated which maintains the source state since the last synchronization. lambdaorm push Files generated: \u251c\u2500\u2500 orm_state \u2502 \u251c\u2500\u2500 default-ddl-20231122T154351640Z-push-test.sql \u2502 \u2514\u2500\u2500 default-model.json Content of the generated file default-ddl-20231122T154351640Z-push-test.sql : CREATE TABLE Countries (name VARCHAR(80) NOT NULL ,iso3 VARCHAR(3) NOT NULL ,CONSTRAINT Countries_PK PRIMARY KEY (iso3)); ALTER TABLE Countries ADD CONSTRAINT Countries_UK UNIQUE (name); CREATE TABLE States (id INTEGER NOT NULL ,name VARCHAR(80) NOT NULL ,countryCode VARCHAR(3) NOT NULL ,CONSTRAINT States_PK PRIMARY KEY (id)); ALTER TABLE States ADD CONSTRAINT States_UK UNIQUE (countryCode,name); ALTER TABLE States ADD CONSTRAINT States_country_FK FOREIGN KEY (countryCode) REFERENCES Countries (iso3); View labs: Simple Two stages Northwind Northwind multiple datasources Northwind CQRS","title":"CLI"},{"location":"schema/Synchronization/SchemaSynchronization/","text":"Synchronization The synchronization is the process of updating the schema defined in yaml/json configuration file with structure in sources (Databases). The synchronization is a process that can be done in both directions, from the schema configuration to the sources (Databases) and from the source to the schema file configuration. Push The push is the process of updating the sources (Databases) with the schema defined in the configuration file. The push process is done by the command lambdaorm push . more info Pull The pull is the process of updating the schema defined in the configuration file with the structure in the sources (Databases). The pull process is done by the command lambdaorm pull . more info Fetch The fetch is the process show differences between sources and schema but not apply changes.The pull process is done by the command lambdaorm fetch . more info Introspect Introspection is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (Databases). The introspection process is performed using the lambdaorm introspect command. more info Incorporate Onboarding is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (databases) and then importing the data into the sources (Databases). The introspection process is performed using the lambdaorm incorporate command. more info","title":"Synchronization"},{"location":"schema/Synchronization/SchemaSynchronization/#synchronization","text":"The synchronization is the process of updating the schema defined in yaml/json configuration file with structure in sources (Databases). The synchronization is a process that can be done in both directions, from the schema configuration to the sources (Databases) and from the source to the schema file configuration.","title":"Synchronization"},{"location":"schema/Synchronization/SchemaSynchronization/#push","text":"The push is the process of updating the sources (Databases) with the schema defined in the configuration file. The push process is done by the command lambdaorm push . more info","title":"Push"},{"location":"schema/Synchronization/SchemaSynchronization/#pull","text":"The pull is the process of updating the schema defined in the configuration file with the structure in the sources (Databases). The pull process is done by the command lambdaorm pull . more info","title":"Pull"},{"location":"schema/Synchronization/SchemaSynchronization/#fetch","text":"The fetch is the process show differences between sources and schema but not apply changes.The pull process is done by the command lambdaorm fetch . more info","title":"Fetch"},{"location":"schema/Synchronization/SchemaSynchronization/#introspect","text":"Introspection is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (Databases). The introspection process is performed using the lambdaorm introspect command. more info","title":"Introspect"},{"location":"schema/Synchronization/SchemaSynchronization/#incorporate","text":"Onboarding is the process of updating the schema defined in the configuration file by introspecting a data file and then applying the changes to the sources (databases) and then importing the data into the sources (Databases). The introspection process is performed using the lambdaorm incorporate command. more info","title":"Incorporate"}]}